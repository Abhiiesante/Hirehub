/* Copyright 2017 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("pdfjs-dist/build/pdf.worker", [], factory);
	else if(typeof exports === 'object')
		exports["pdfjs-dist/build/pdf.worker"] = factory();
	else
		root["pdfjs-dist/build/pdf.worker"] = root.pdfjsDistBuildPdfWorker = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__w_pdfjs_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__w_pdfjs_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__w_pdfjs_require__.d = function(exports, name, getter) {
/******/ 		if(!__w_pdfjs_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__w_pdfjs_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__w_pdfjs_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__w_pdfjs_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__w_pdfjs_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __w_pdfjs_require__(__w_pdfjs_require__.s = 82);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unreachable = exports.warn = exports.utf8StringToString = exports.stringToUTF8String = exports.stringToPDFString = exports.stringToBytes = exports.string32 = exports.shadow = exports.setVerbosityLevel = exports.ReadableStream = exports.removeNullCharacters = exports.readUint32 = exports.readUint16 = exports.readInt8 = exports.log2 = exports.loadJpegStream = exports.isEvalSupported = exports.isLittleEndian = exports.createValidAbsoluteUrl = exports.isSameOrigin = exports.isNodeJS = exports.isSpace = exports.isString = exports.isNum = exports.isEmptyObj = exports.isBool = exports.isArrayBuffer = exports.info = exports.getVerbosityLevel = exports.getLookupTableFactory = exports.deprecated = exports.createObjectURL = exports.createPromiseCapability = exports.createBlob = exports.bytesToString = exports.assert = exports.arraysToBytes = exports.arrayByteLength = exports.FormatError = exports.XRefParseException = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.StatTimer = exports.PasswordResponses = exports.PasswordException = exports.PageViewport = exports.NotImplementedException = exports.NativeImageDecoding = exports.MissingPDFException = exports.MissingDataException = exports.MessageHandler = exports.InvalidPDFException = exports.AbortException = exports.CMapCompressionType = exports.ImageKind = exports.FontType = exports.AnnotationType = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.UNSUPPORTED_FEATURES = exports.VERBOSITY_LEVELS = exports.OPS = exports.IDENTITY_MATRIX = exports.FONT_IDENTITY_MATRIX = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

__w_pdfjs_require__(84);

var _streams_polyfill = __w_pdfjs_require__(125);

var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
var NativeImageDecoding = {
  NONE: 'none',
  DECODE: 'decode',
  DISPLAY: 'display'
};
var TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};
var ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
var AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
};
var AnnotationFlag = {
  INVISIBLE: 0x01,
  HIDDEN: 0x02,
  PRINT: 0x04,
  NOZOOM: 0x08,
  NOROTATE: 0x10,
  NOVIEW: 0x20,
  READONLY: 0x40,
  LOCKED: 0x80,
  TOGGLENOVIEW: 0x100,
  LOCKEDCONTENTS: 0x200
};
var AnnotationFieldFlag = {
  READONLY: 0x0000001,
  REQUIRED: 0x0000002,
  NOEXPORT: 0x0000004,
  MULTILINE: 0x0001000,
  PASSWORD: 0x0002000,
  NOTOGGLETOOFF: 0x0004000,
  RADIO: 0x0008000,
  PUSHBUTTON: 0x0010000,
  COMBO: 0x0020000,
  EDIT: 0x0040000,
  SORT: 0x0080000,
  FILESELECT: 0x0100000,
  MULTISELECT: 0x0200000,
  DONOTSPELLCHECK: 0x0400000,
  DONOTSCROLL: 0x0800000,
  COMB: 0x1000000,
  RICHTEXT: 0x2000000,
  RADIOSINUNISON: 0x2000000,
  COMMITONSELCHANGE: 0x4000000
};
var AnnotationBorderStyleType = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
};
var StreamType = {
  UNKNOWN: 0,
  FLATE: 1,
  LZW: 2,
  DCT: 3,
  JPX: 4,
  JBIG: 5,
  A85: 6,
  AHX: 7,
  CCF: 8,
  RL: 9
};
var FontType = {
  UNKNOWN: 0,
  TYPE1: 1,
  TYPE1C: 2,
  CIDFONTTYPE0: 3,
  CIDFONTTYPE0C: 4,
  TRUETYPE: 5,
  CIDFONTTYPE2: 6,
  TYPE3: 7,
  OPENTYPE: 8,
  TYPE0: 9,
  MMTYPE1: 10
};
var VERBOSITY_LEVELS = {
  errors: 0,
  warnings: 1,
  infos: 5
};
var CMapCompressionType = {
  NONE: 0,
  BINARY: 1,
  STREAM: 2
};
var OPS = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotations: 78,
  endAnnotations: 79,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintJpegXObject: 82,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};
var verbosity = VERBOSITY_LEVELS.warnings;
function setVerbosityLevel(level) {
  verbosity = level;
}
function getVerbosityLevel() {
  return verbosity;
}
function info(msg) {
  if (verbosity >= VERBOSITY_LEVELS.infos) {
    console.log('Info: ' + msg);
  }
}
function warn(msg) {
  if (verbosity >= VERBOSITY_LEVELS.warnings) {
    console.log('Warning: ' + msg);
  }
}
function deprecated(details) {
  console.log('Deprecated API usage: ' + details);
}
function unreachable(msg) {
  throw new Error(msg);
}
function assert(cond, msg) {
  if (!cond) {
    unreachable(msg);
  }
}
var UNSUPPORTED_FEATURES = {
  unknown: 'unknown',
  forms: 'forms',
  javaScript: 'javaScript',
  smask: 'smask',
  shadingPattern: 'shadingPattern',
  font: 'font'
};
function isSameOrigin(baseUrl, otherUrl) {
  try {
    var base = new URL(baseUrl);
    if (!base.origin || base.origin === 'null') {
      return false;
    }
  } catch (e) {
    return false;
  }
  var other = new URL(otherUrl, base);
  return base.origin === other.origin;
}
function isValidProtocol(url) {
  if (!url) {
    return false;
  }
  switch (url.protocol) {
    case 'http:':
    case 'https:':
    case 'ftp:':
    case 'mailto:':
    case 'tel:':
      return true;
    default:
      return false;
  }
}
function createValidAbsoluteUrl(url, baseUrl) {
  if (!url) {
    return null;
  }
  try {
    var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
    if (isValidProtocol(absoluteUrl)) {
      return absoluteUrl;
    }
  } catch (ex) {}
  return null;
}
function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    value: value,
    enumerable: true,
    configurable: true,
    writable: false
  });
  return value;
}
function getLookupTableFactory(initializer) {
  var lookup;
  return function () {
    if (initializer) {
      lookup = Object.create(null);
      initializer(lookup);
      initializer = null;
    }
    return lookup;
  };
}
var PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
var PasswordException = function PasswordExceptionClosure() {
  function PasswordException(msg, code) {
    this.name = 'PasswordException';
    this.message = msg;
    this.code = code;
  }
  PasswordException.prototype = new Error();
  PasswordException.constructor = PasswordException;
  return PasswordException;
}();
var UnknownErrorException = function UnknownErrorExceptionClosure() {
  function UnknownErrorException(msg, details) {
    this.name = 'UnknownErrorException';
    this.message = msg;
    this.details = details;
  }
  UnknownErrorException.prototype = new Error();
  UnknownErrorException.constructor = UnknownErrorException;
  return UnknownErrorException;
}();
var InvalidPDFException = function InvalidPDFExceptionClosure() {
  function InvalidPDFException(msg) {
    this.name = 'InvalidPDFException';
    this.message = msg;
  }
  InvalidPDFException.prototype = new Error();
  InvalidPDFException.constructor = InvalidPDFException;
  return InvalidPDFException;
}();
var MissingPDFException = function MissingPDFExceptionClosure() {
  function MissingPDFException(msg) {
    this.name = 'MissingPDFException';
    this.message = msg;
  }
  MissingPDFException.prototype = new Error();
  MissingPDFException.constructor = MissingPDFException;
  return MissingPDFException;
}();
var UnexpectedResponseException = function UnexpectedResponseExceptionClosure() {
  function UnexpectedResponseException(msg, status) {
    this.name = 'UnexpectedResponseException';
    this.message = msg;
    this.status = status;
  }
  UnexpectedResponseException.prototype = new Error();
  UnexpectedResponseException.constructor = UnexpectedResponseException;
  return UnexpectedResponseException;
}();
var NotImplementedException = function NotImplementedExceptionClosure() {
  function NotImplementedException(msg) {
    this.message = msg;
  }
  NotImplementedException.prototype = new Error();
  NotImplementedException.prototype.name = 'NotImplementedException';
  NotImplementedException.constructor = NotImplementedException;
  return NotImplementedException;
}();
var MissingDataException = function MissingDataExceptionClosure() {
  function MissingDataException(begin, end) {
    this.begin = begin;
    this.end = end;
    this.message = 'Missing data [' + begin + ', ' + end + ')';
  }
  MissingDataException.prototype = new Error();
  MissingDataException.prototype.name = 'MissingDataException';
  MissingDataException.constructor = MissingDataException;
  return MissingDataException;
}();
var XRefParseException = function XRefParseExceptionClosure() {
  function XRefParseException(msg) {
    this.message = msg;
  }
  XRefParseException.prototype = new Error();
  XRefParseException.prototype.name = 'XRefParseException';
  XRefParseException.constructor = XRefParseException;
  return XRefParseException;
}();
var FormatError = function FormatErrorClosure() {
  function FormatError(msg) {
    this.message = msg;
  }
  FormatError.prototype = new Error();
  FormatError.prototype.name = 'FormatError';
  FormatError.constructor = FormatError;
  return FormatError;
}();
var AbortException = function AbortExceptionClosure() {
  function AbortException(msg) {
    this.name = 'AbortException';
    this.message = msg;
  }
  AbortException.prototype = new Error();
  AbortException.constructor = AbortException;
  return AbortException;
}();
var NullCharactersRegExp = /\x00/g;
function removeNullCharacters(str) {
  if (typeof str !== 'string') {
    warn('The argument for removeNullCharacters must be a string.');
    return str;
  }
  return str.replace(NullCharactersRegExp, '');
}
function bytesToString(bytes) {
  assert(bytes !== null && (typeof bytes === 'undefined' ? 'undefined' : _typeof(bytes)) === 'object' && bytes.length !== undefined, 'Invalid argument for bytesToString');
  var length = bytes.length;
  var MAX_ARGUMENT_COUNT = 8192;
  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }
  var strBuf = [];
  for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    var chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }
  return strBuf.join('');
}
function stringToBytes(str) {
  assert(typeof str === 'string', 'Invalid argument for stringToBytes');
  var length = str.length;
  var bytes = new Uint8Array(length);
  for (var i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xFF;
  }
  return bytes;
}
function arrayByteLength(arr) {
  if (arr.length !== undefined) {
    return arr.length;
  }
  assert(arr.byteLength !== undefined);
  return arr.byteLength;
}
function arraysToBytes(arr) {
  if (arr.length === 1 && arr[0] instanceof Uint8Array) {
    return arr[0];
  }
  var resultLength = 0;
  var i,
      ii = arr.length;
  var item, itemLength;
  for (i = 0; i < ii; i++) {
    item = arr[i];
    itemLength = arrayByteLength(item);
    resultLength += itemLength;
  }
  var pos = 0;
  var data = new Uint8Array(resultLength);
  for (i = 0; i < ii; i++) {
    item = arr[i];
    if (!(item instanceof Uint8Array)) {
      if (typeof item === 'string') {
        item = stringToBytes(item);
      } else {
        item = new Uint8Array(item);
      }
    }
    itemLength = item.byteLength;
    data.set(item, pos);
    pos += itemLength;
  }
  return data;
}
function string32(value) {
  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
}
function log2(x) {
  var n = 1,
      i = 0;
  while (x > n) {
    n <<= 1;
    i++;
  }
  return i;
}
function readInt8(data, start) {
  return data[start] << 24 >> 24;
}
function readUint16(data, offset) {
  return data[offset] << 8 | data[offset + 1];
}
function readUint32(data, offset) {
  return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
}
function isLittleEndian() {
  var buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  var view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}
function isEvalSupported() {
  try {
    new Function('');
    return true;
  } catch (e) {
    return false;
  }
}
var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
var Util = function UtilClosure() {
  function Util() {}
  var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];
  Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {
    rgbBuf[1] = r;
    rgbBuf[3] = g;
    rgbBuf[5] = b;
    return rgbBuf.join('');
  };
  Util.transform = function Util_transform(m1, m2) {
    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
  };
  Util.applyTransform = function Util_applyTransform(p, m) {
    var xt = p[0] * m[0] + p[1] * m[2] + m[4];
    var yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  };
  Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {
    var d = m[0] * m[3] - m[1] * m[2];
    var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  };
  Util.getAxialAlignedBoundingBox = function Util_getAxialAlignedBoundingBox(r, m) {
    var p1 = Util.applyTransform(r, m);
    var p2 = Util.applyTransform(r.slice(2, 4), m);
    var p3 = Util.applyTransform([r[0], r[3]], m);
    var p4 = Util.applyTransform([r[2], r[1]], m);
    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
  };
  Util.inverseTransform = function Util_inverseTransform(m) {
    var d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  };
  Util.apply3dTransform = function Util_apply3dTransform(m, v) {
    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
  };
  Util.singularValueDecompose2dScale = function Util_singularValueDecompose2dScale(m) {
    var transpose = [m[0], m[2], m[1], m[3]];
    var a = m[0] * transpose[0] + m[1] * transpose[2];
    var b = m[0] * transpose[1] + m[1] * transpose[3];
    var c = m[2] * transpose[0] + m[3] * transpose[2];
    var d = m[2] * transpose[1] + m[3] * transpose[3];
    var first = (a + d) / 2;
    var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
    var sx = first + second || 1;
    var sy = first - second || 1;
    return [Math.sqrt(sx), Math.sqrt(sy)];
  };
  Util.normalizeRect = function Util_normalizeRect(rect) {
    var r = rect.slice(0);
    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }
    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }
    return r;
  };
  Util.intersect = function Util_intersect(rect1, rect2) {
    function compare(a, b) {
      return a - b;
    }
    var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),
        orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),
        result = [];
    rect1 = Util.normalizeRect(rect1);
    rect2 = Util.normalizeRect(rect2);
    if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
      result[0] = orderedX[1];
      result[2] = orderedX[2];
    } else {
      return false;
    }
    if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
      result[1] = orderedY[1];
      result[3] = orderedY[2];
    } else {
      return false;
    }
    return result;
  };
  var ROMAN_NUMBER_MAP = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];
  Util.toRoman = function Util_toRoman(number, lowerCase) {
    assert(Number.isInteger(number) && number > 0, 'The number should be a positive integer.');
    var pos,
        romanBuf = [];
    while (number >= 1000) {
      number -= 1000;
      romanBuf.push('M');
    }
    pos = number / 100 | 0;
    number %= 100;
    romanBuf.push(ROMAN_NUMBER_MAP[pos]);
    pos = number / 10 | 0;
    number %= 10;
    romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
    romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
    var romanStr = romanBuf.join('');
    return lowerCase ? romanStr.toLowerCase() : romanStr;
  };
  Util.appendToArray = function Util_appendToArray(arr1, arr2) {
    Array.prototype.push.apply(arr1, arr2);
  };
  Util.prependToArray = function Util_prependToArray(arr1, arr2) {
    Array.prototype.unshift.apply(arr1, arr2);
  };
  Util.extendObj = function extendObj(obj1, obj2) {
    for (var key in obj2) {
      obj1[key] = obj2[key];
    }
  };
  Util.getInheritableProperty = function Util_getInheritableProperty(dict, name, getArray) {
    while (dict && !dict.has(name)) {
      dict = dict.get('Parent');
    }
    if (!dict) {
      return null;
    }
    return getArray ? dict.getArray(name) : dict.get(name);
  };
  Util.inherit = function Util_inherit(sub, base, prototype) {
    sub.prototype = Object.create(base.prototype);
    sub.prototype.constructor = sub;
    for (var prop in prototype) {
      sub.prototype[prop] = prototype[prop];
    }
  };
  Util.loadScript = function Util_loadScript(src, callback) {
    var script = document.createElement('script');
    var loaded = false;
    script.setAttribute('src', src);
    if (callback) {
      script.onload = function () {
        if (!loaded) {
          callback();
        }
        loaded = true;
      };
    }
    document.getElementsByTagName('head')[0].appendChild(script);
  };
  return Util;
}();
var PageViewport = function PageViewportClosure() {
  function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    var centerX = (viewBox[2] + viewBox[0]) / 2;
    var centerY = (viewBox[3] + viewBox[1]) / 2;
    var rotateA, rotateB, rotateC, rotateD;
    rotation = rotation % 360;
    rotation = rotation < 0 ? rotation + 360 : rotation;
    switch (rotation) {
      case 180:
        rotateA = -1;
        rotateB = 0;
        rotateC = 0;
        rotateD = 1;
        break;
      case 90:
        rotateA = 0;
        rotateB = 1;
        rotateC = 1;
        rotateD = 0;
        break;
      case 270:
        rotateA = 0;
        rotateB = -1;
        rotateC = -1;
        rotateD = 0;
        break;
      default:
        rotateA = 1;
        rotateB = 0;
        rotateC = 0;
        rotateD = -1;
        break;
    }
    if (dontFlip) {
      rotateC = -rotateC;
      rotateD = -rotateD;
    }
    var offsetCanvasX, offsetCanvasY;
    var width, height;
    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
    }
    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
    this.width = width;
    this.height = height;
    this.fontScale = scale;
  }
  PageViewport.prototype = {
    clone: function PageViewPort_clone(args) {
      args = args || {};
      var scale = 'scale' in args ? args.scale : this.scale;
      var rotation = 'rotation' in args ? args.rotation : this.rotation;
      return new PageViewport(this.viewBox.slice(), scale, rotation, this.offsetX, this.offsetY, args.dontFlip);
    },
    convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
      return Util.applyTransform([x, y], this.transform);
    },
    convertToViewportRectangle: function PageViewport_convertToViewportRectangle(rect) {
      var tl = Util.applyTransform([rect[0], rect[1]], this.transform);
      var br = Util.applyTransform([rect[2], rect[3]], this.transform);
      return [tl[0], tl[1], br[0], br[1]];
    },
    convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
      return Util.applyInverseTransform([x, y], this.transform);
    }
  };
  return PageViewport;
}();
var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];
function stringToPDFString(str) {
  var i,
      n = str.length,
      strBuf = [];
  if (str[0] === '\xFE' && str[1] === '\xFF') {
    for (i = 2; i < n; i += 2) {
      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
    }
  } else {
    for (i = 0; i < n; ++i) {
      var code = PDFStringTranslateTable[str.charCodeAt(i)];
      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
    }
  }
  return strBuf.join('');
}
function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}
function utf8StringToString(str) {
  return unescape(encodeURIComponent(str));
}
function isEmptyObj(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
}
function isBool(v) {
  return typeof v === 'boolean';
}
function isNum(v) {
  return typeof v === 'number';
}
function isString(v) {
  return typeof v === 'string';
}
function isArrayBuffer(v) {
  return (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' && v !== null && v.byteLength !== undefined;
}
function isSpace(ch) {
  return ch === 0x20 || ch === 0x09 || ch === 0x0D || ch === 0x0A;
}
function isNodeJS() {
  return (typeof process === 'undefined' ? 'undefined' : _typeof(process)) === 'object' && process + '' === '[object process]';
}
function createPromiseCapability() {
  var capability = {};
  capability.promise = new Promise(function (resolve, reject) {
    capability.resolve = resolve;
    capability.reject = reject;
  });
  return capability;
}
var StatTimer = function StatTimerClosure() {
  function rpad(str, pad, length) {
    while (str.length < length) {
      str += pad;
    }
    return str;
  }
  function StatTimer() {
    this.started = Object.create(null);
    this.times = [];
    this.enabled = true;
  }
  StatTimer.prototype = {
    time: function StatTimer_time(name) {
      if (!this.enabled) {
        return;
      }
      if (name in this.started) {
        warn('Timer is already running for ' + name);
      }
      this.started[name] = Date.now();
    },
    timeEnd: function StatTimer_timeEnd(name) {
      if (!this.enabled) {
        return;
      }
      if (!(name in this.started)) {
        warn('Timer has not been started for ' + name);
      }
      this.times.push({
        'name': name,
        'start': this.started[name],
        'end': Date.now()
      });
      delete this.started[name];
    },
    toString: function StatTimer_toString() {
      var i, ii;
      var times = this.times;
      var out = '';
      var longest = 0;
      for (i = 0, ii = times.length; i < ii; ++i) {
        var name = times[i]['name'];
        if (name.length > longest) {
          longest = name.length;
        }
      }
      for (i = 0, ii = times.length; i < ii; ++i) {
        var span = times[i];
        var duration = span.end - span.start;
        out += rpad(span['name'], ' ', longest) + ' ' + duration + 'ms\n';
      }
      return out;
    }
  };
  return StatTimer;
}();
var createBlob = function createBlob(data, contentType) {
  if (typeof Blob !== 'undefined') {
    return new Blob([data], { type: contentType });
  }
  throw new Error('The "Blob" constructor is not supported.');
};
var createObjectURL = function createObjectURLClosure() {
  var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  return function createObjectURL(data, contentType) {
    var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (!forceDataSchema && URL.createObjectURL) {
      var blob = createBlob(data, contentType);
      return URL.createObjectURL(blob);
    }
    var buffer = 'data:' + contentType + ';base64,';
    for (var i = 0, ii = data.length; i < ii; i += 3) {
      var b1 = data[i] & 0xFF;
      var b2 = data[i + 1] & 0xFF;
      var b3 = data[i + 2] & 0xFF;
      var d1 = b1 >> 2,
          d2 = (b1 & 3) << 4 | b2 >> 4;
      var d3 = i + 1 < ii ? (b2 & 0xF) << 2 | b3 >> 6 : 64;
      var d4 = i + 2 < ii ? b3 & 0x3F : 64;
      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
    }
    return buffer;
  };
}();
function resolveCall(fn, args) {
  var thisArg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (!fn) {
    return Promise.resolve(undefined);
  }
  return new Promise(function (resolve, reject) {
    resolve(fn.apply(thisArg, args));
  });
}
function wrapReason(reason) {
  if ((typeof reason === 'undefined' ? 'undefined' : _typeof(reason)) !== 'object') {
    return reason;
  }
  switch (reason.name) {
    case 'AbortException':
      return new AbortException(reason.message);
    case 'MissingPDFException':
      return new MissingPDFException(reason.message);
    case 'UnexpectedResponseException':
      return new UnexpectedResponseException(reason.message, reason.status);
    default:
      return new UnknownErrorException(reason.message, reason.details);
  }
}
function makeReasonSerializable(reason) {
  if (!(reason instanceof Error) || reason instanceof AbortException || reason instanceof MissingPDFException || reason instanceof UnexpectedResponseException || reason instanceof UnknownErrorException) {
    return reason;
  }
  return new UnknownErrorException(reason.message, reason.toString());
}
function resolveOrReject(capability, success, reason) {
  if (success) {
    capability.resolve();
  } else {
    capability.reject(reason);
  }
}
function finalize(promise) {
  return Promise.resolve(promise).catch(function () {});
}
function MessageHandler(sourceName, targetName, comObj) {
  var _this = this;

  this.sourceName = sourceName;
  this.targetName = targetName;
  this.comObj = comObj;
  this.callbackId = 1;
  this.streamId = 1;
  this.postMessageTransfers = true;
  this.streamSinks = Object.create(null);
  this.streamControllers = Object.create(null);
  var callbacksCapabilities = this.callbacksCapabilities = Object.create(null);
  var ah = this.actionHandler = Object.create(null);
  this._onComObjOnMessage = function (event) {
    var data = event.data;
    if (data.targetName !== _this.sourceName) {
      return;
    }
    if (data.stream) {
      _this._processStreamMessage(data);
    } else if (data.isReply) {
      var callbackId = data.callbackId;
      if (data.callbackId in callbacksCapabilities) {
        var callback = callbacksCapabilities[callbackId];
        delete callbacksCapabilities[callbackId];
        if ('error' in data) {
          callback.reject(wrapReason(data.error));
        } else {
          callback.resolve(data.data);
        }
      } else {
        throw new Error('Cannot resolve callback ' + callbackId);
      }
    } else if (data.action in ah) {
      var action = ah[data.action];
      if (data.callbackId) {
        var _sourceName = _this.sourceName;
        var _targetName = data.sourceName;
        Promise.resolve().then(function () {
          return action[0].call(action[1], data.data);
        }).then(function (result) {
          comObj.postMessage({
            sourceName: _sourceName,
            targetName: _targetName,
            isReply: true,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName: _sourceName,
            targetName: _targetName,
            isReply: true,
            callbackId: data.callbackId,
            error: makeReasonSerializable(reason)
          });
        });
      } else if (data.streamId) {
        _this._createStreamSink(data);
      } else {
        action[0].call(action[1], data.data);
      }
    } else {
      throw new Error('Unknown action from worker: ' + data.action);
    }
  };
  comObj.addEventListener('message', this._onComObjOnMessage);
}
MessageHandler.prototype = {
  on: function on(actionName, handler, scope) {
    var ah = this.actionHandler;
    if (ah[actionName]) {
      throw new Error('There is already an actionName called "' + actionName + '"');
    }
    ah[actionName] = [handler, scope];
  },
  send: function send(actionName, data, transfers) {
    var message = {
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data: data
    };
    this.postMessage(message, transfers);
  },
  sendWithPromise: function sendWithPromise(actionName, data, transfers) {
    var callbackId = this.callbackId++;
    var message = {
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data: data,
      callbackId: callbackId
    };
    var capability = createPromiseCapability();
    this.callbacksCapabilities[callbackId] = capability;
    try {
      this.postMessage(message, transfers);
    } catch (e) {
      capability.reject(e);
    }
    return capability.promise;
  },
  sendWithStream: function sendWithStream(actionName, data, queueingStrategy, transfers) {
    var _this2 = this;

    var streamId = this.streamId++;
    var sourceName = this.sourceName;
    var targetName = this.targetName;
    return new _streams_polyfill.ReadableStream({
      start: function start(controller) {
        var startCapability = createPromiseCapability();
        _this2.streamControllers[streamId] = {
          controller: controller,
          startCall: startCapability,
          isClosed: false
        };
        _this2.postMessage({
          sourceName: sourceName,
          targetName: targetName,
          action: actionName,
          streamId: streamId,
          data: data,
          desiredSize: controller.desiredSize
        });
        return startCapability.promise;
      },
      pull: function pull(controller) {
        var pullCapability = createPromiseCapability();
        _this2.streamControllers[streamId].pullCall = pullCapability;
        _this2.postMessage({
          sourceName: sourceName,
          targetName: targetName,
          stream: 'pull',
          streamId: streamId,
          desiredSize: controller.desiredSize
        });
        return pullCapability.promise;
      },
      cancel: function cancel(reason) {
        var cancelCapability = createPromiseCapability();
        _this2.streamControllers[streamId].cancelCall = cancelCapability;
        _this2.streamControllers[streamId].isClosed = true;
        _this2.postMessage({
          sourceName: sourceName,
          targetName: targetName,
          stream: 'cancel',
          reason: reason,
          streamId: streamId
        });
        return cancelCapability.promise;
      }
    }, queueingStrategy);
  },
  _createStreamSink: function _createStreamSink(data) {
    var _this3 = this;

    var self = this;
    var action = this.actionHandler[data.action];
    var streamId = data.streamId;
    var desiredSize = data.desiredSize;
    var sourceName = this.sourceName;
    var targetName = data.sourceName;
    var capability = createPromiseCapability();
    var sendStreamRequest = function sendStreamRequest(_ref) {
      var stream = _ref.stream,
          chunk = _ref.chunk,
          transfers = _ref.transfers,
          success = _ref.success,
          reason = _ref.reason;

      _this3.postMessage({
        sourceName: sourceName,
        targetName: targetName,
        stream: stream,
        streamId: streamId,
        chunk: chunk,
        success: success,
        reason: reason
      }, transfers);
    };
    var streamSink = {
      enqueue: function enqueue(chunk) {
        var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var transfers = arguments[2];

        if (this.isCancelled) {
          return;
        }
        var lastDesiredSize = this.desiredSize;
        this.desiredSize -= size;
        if (lastDesiredSize > 0 && this.desiredSize <= 0) {
          this.sinkCapability = createPromiseCapability();
          this.ready = this.sinkCapability.promise;
        }
        sendStreamRequest({
          stream: 'enqueue',
          chunk: chunk,
          transfers: transfers
        });
      },
      close: function close() {
        if (this.isCancelled) {
          return;
        }
        this.isCancelled = true;
        sendStreamRequest({ stream: 'close' });
        delete self.streamSinks[streamId];
      },
      error: function error(reason) {
        if (this.isCancelled) {
          return;
        }
        this.isCancelled = true;
        sendStreamRequest({
          stream: 'error',
          reason: reason
        });
      },

      sinkCapability: capability,
      onPull: null,
      onCancel: null,
      isCancelled: false,
      desiredSize: desiredSize,
      ready: null
    };
    streamSink.sinkCapability.resolve();
    streamSink.ready = streamSink.sinkCapability.promise;
    this.streamSinks[streamId] = streamSink;
    resolveCall(action[0], [data.data, streamSink], action[1]).then(function () {
      sendStreamRequest({
        stream: 'start_complete',
        success: true
      });
    }, function (reason) {
      sendStreamRequest({
        stream: 'start_complete',
        success: false,
        reason: reason
      });
    });
  },
  _processStreamMessage: function _processStreamMessage(data) {
    var _this4 = this;

    var sourceName = this.sourceName;
    var targetName = data.sourceName;
    var streamId = data.streamId;
    var sendStreamResponse = function sendStreamResponse(_ref2) {
      var stream = _ref2.stream,
          success = _ref2.success,
          reason = _ref2.reason;

      _this4.comObj.postMessage({
        sourceName: sourceName,
        targetName: targetName,
        stream: stream,
        success: success,
        streamId: streamId,
        reason: reason
      });
    };
    var deleteStreamController = function deleteStreamController() {
      Promise.all([_this4.streamControllers[data.streamId].startCall, _this4.streamControllers[data.streamId].pullCall, _this4.streamControllers[data.streamId].cancelCall].map(function (capability) {
        return capability && finalize(capability.promise);
      })).then(function () {
        delete _this4.streamControllers[data.streamId];
      });
    };
    switch (data.stream) {
      case 'start_complete':
        resolveOrReject(this.streamControllers[data.streamId].startCall, data.success, wrapReason(data.reason));
        break;
      case 'pull_complete':
        resolveOrReject(this.streamControllers[data.streamId].pullCall, data.success, wrapReason(data.reason));
        break;
      case 'pull':
        if (!this.streamSinks[data.streamId]) {
          sendStreamResponse({
            stream: 'pull_complete',
            success: true
          });
          break;
        }
        if (this.streamSinks[data.streamId].desiredSize <= 0 && data.desiredSize > 0) {
          this.streamSinks[data.streamId].sinkCapability.resolve();
        }
        this.streamSinks[data.streamId].desiredSize = data.desiredSize;
        resolveCall(this.streamSinks[data.streamId].onPull).then(function () {
          sendStreamResponse({
            stream: 'pull_complete',
            success: true
          });
        }, function (reason) {
          sendStreamResponse({
            stream: 'pull_complete',
            success: false,
            reason: reason
          });
        });
        break;
      case 'enqueue':
        assert(this.streamControllers[data.streamId], 'enqueue should have stream controller');
        if (!this.streamControllers[data.streamId].isClosed) {
          this.streamControllers[data.streamId].controller.enqueue(data.chunk);
        }
        break;
      case 'close':
        assert(this.streamControllers[data.streamId], 'close should have stream controller');
        if (this.streamControllers[data.streamId].isClosed) {
          break;
        }
        this.streamControllers[data.streamId].isClosed = true;
        this.streamControllers[data.streamId].controller.close();
        deleteStreamController();
        break;
      case 'error':
        assert(this.streamControllers[data.streamId], 'error should have stream controller');
        this.streamControllers[data.streamId].controller.error(wrapReason(data.reason));
        deleteStreamController();
        break;
      case 'cancel_complete':
        resolveOrReject(this.streamControllers[data.streamId].cancelCall, data.success, wrapReason(data.reason));
        deleteStreamController();
        break;
      case 'cancel':
        if (!this.streamSinks[data.streamId]) {
          break;
        }
        resolveCall(this.streamSinks[data.streamId].onCancel, [wrapReason(data.reason)]).then(function () {
          sendStreamResponse({
            stream: 'cancel_complete',
            success: true
          });
        }, function (reason) {
          sendStreamResponse({
            stream: 'cancel_complete',
            success: false,
            reason: reason
          });
        });
        this.streamSinks[data.streamId].sinkCapability.reject(wrapReason(data.reason));
        this.streamSinks[data.streamId].isCancelled = true;
        delete this.streamSinks[data.streamId];
        break;
      default:
        throw new Error('Unexpected stream case');
    }
  },
  postMessage: function postMessage(message, transfers) {
    if (transfers && this.postMessageTransfers) {
      this.comObj.postMessage(message, transfers);
    } else {
      this.comObj.postMessage(message);
    }
  },
  destroy: function destroy() {
    this.comObj.removeEventListener('message', this._onComObjOnMessage);
  }
};
function loadJpegStream(id, imageUrl, objs) {
  var img = new Image();
  img.onload = function loadJpegStream_onloadClosure() {
    objs.resolve(id, img);
  };
  img.onerror = function loadJpegStream_onerrorClosure() {
    objs.resolve(id, null);
    warn('Error during JPEG image loading');
  };
  img.src = imageUrl;
}
exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
exports.OPS = OPS;
exports.VERBOSITY_LEVELS = VERBOSITY_LEVELS;
exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
exports.AnnotationFieldFlag = AnnotationFieldFlag;
exports.AnnotationFlag = AnnotationFlag;
exports.AnnotationType = AnnotationType;
exports.FontType = FontType;
exports.ImageKind = ImageKind;
exports.CMapCompressionType = CMapCompressionType;
exports.AbortException = AbortException;
exports.InvalidPDFException = InvalidPDFException;
exports.MessageHandler = MessageHandler;
exports.MissingDataException = MissingDataException;
exports.MissingPDFException = MissingPDFException;
exports.NativeImageDecoding = NativeImageDecoding;
exports.NotImplementedException = NotImplementedException;
exports.PageViewport = PageViewport;
exports.PasswordException = PasswordException;
exports.PasswordResponses = PasswordResponses;
exports.StatTimer = StatTimer;
exports.StreamType = StreamType;
exports.TextRenderingMode = TextRenderingMode;
exports.UnexpectedResponseException = UnexpectedResponseException;
exports.UnknownErrorException = UnknownErrorException;
exports.Util = Util;
exports.XRefParseException = XRefParseException;
exports.FormatError = FormatError;
exports.arrayByteLength = arrayByteLength;
exports.arraysToBytes = arraysToBytes;
exports.assert = assert;
exports.bytesToString = bytesToString;
exports.createBlob = createBlob;
exports.createPromiseCapability = createPromiseCapability;
exports.createObjectURL = createObjectURL;
exports.deprecated = deprecated;
exports.getLookupTableFactory = getLookupTableFactory;
exports.getVerbosityLevel = getVerbosityLevel;
exports.info = info;
exports.isArrayBuffer = isArrayBuffer;
exports.isBool = isBool;
exports.isEmptyObj = isEmptyObj;
exports.isNum = isNum;
exports.isString = isString;
exports.isSpace = isSpace;
exports.isNodeJS = isNodeJS;
exports.isSameOrigin = isSameOrigin;
exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
exports.isLittleEndian = isLittleEndian;
exports.isEvalSupported = isEvalSupported;
exports.loadJpegStream = loadJpegStream;
exports.log2 = log2;
exports.readInt8 = readInt8;
exports.readUint16 = readUint16;
exports.readUint32 = readUint32;
exports.removeNullCharacters = removeNullCharacters;
exports.ReadableStream = _streams_polyfill.ReadableStream;
exports.setVerbosityLevel = setVerbosityLevel;
exports.shadow = shadow;
exports.string32 = string32;
exports.stringToBytes = stringToBytes;
exports.stringToPDFString = stringToPDFString;
exports.stringToUTF8String = stringToUTF8String;
exports.utf8StringToString = utf8StringToString;
exports.warn = warn;
exports.unreachable = unreachable;

/***/ }),
/* 1 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if (typeof __g == 'number') __g = global;

/***/ }),
/* 2 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var EOF = {};
var Name = function NameClosure() {
  function Name(name) {
    this.name = name;
  }
  Name.prototype = {};
  var nameCache = Object.create(null);
  Name.get = function Name_get(name) {
    var nameValue = nameCache[name];
    return nameValue ? nameValue : nameCache[name] = new Name(name);
  };
  return Name;
}();
var Cmd = function CmdClosure() {
  function Cmd(cmd) {
    this.cmd = cmd;
  }
  Cmd.prototype = {};
  var cmdCache = Object.create(null);
  Cmd.get = function Cmd_get(cmd) {
    var cmdValue = cmdCache[cmd];
    return cmdValue ? cmdValue : cmdCache[cmd] = new Cmd(cmd);
  };
  return Cmd;
}();
var Dict = function DictClosure() {
  var nonSerializable = function nonSerializableClosure() {
    return nonSerializable;
  };
  function Dict(xref) {
    this._map = Object.create(null);
    this.xref = xref;
    this.objId = null;
    this.suppressEncryption = false;
    this.__nonSerializable__ = nonSerializable;
  }
  Dict.prototype = {
    assignXref: function Dict_assignXref(newXref) {
      this.xref = newXref;
    },
    get: function Dict_get(key1, key2, key3) {
      var value;
      var xref = this.xref,
          suppressEncryption = this.suppressEncryption;
      if (typeof (value = this._map[key1]) !== 'undefined' || key1 in this._map || typeof key2 === 'undefined') {
        return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
      }
      if (typeof (value = this._map[key2]) !== 'undefined' || key2 in this._map || typeof key3 === 'undefined') {
        return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
      }
      value = this._map[key3] || null;
      return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
    },
    getAsync: function Dict_getAsync(key1, key2, key3) {
      var value;
      var xref = this.xref,
          suppressEncryption = this.suppressEncryption;
      if (typeof (value = this._map[key1]) !== 'undefined' || key1 in this._map || typeof key2 === 'undefined') {
        if (xref) {
          return xref.fetchIfRefAsync(value, suppressEncryption);
        }
        return Promise.resolve(value);
      }
      if (typeof (value = this._map[key2]) !== 'undefined' || key2 in this._map || typeof key3 === 'undefined') {
        if (xref) {
          return xref.fetchIfRefAsync(value, suppressEncryption);
        }
        return Promise.resolve(value);
      }
      value = this._map[key3] || null;
      if (xref) {
        return xref.fetchIfRefAsync(value, suppressEncryption);
      }
      return Promise.resolve(value);
    },
    getArray: function Dict_getArray(key1, key2, key3) {
      var value = this.get(key1, key2, key3);
      var xref = this.xref,
          suppressEncryption = this.suppressEncryption;
      if (!Array.isArray(value) || !xref) {
        return value;
      }
      value = value.slice();
      for (var i = 0, ii = value.length; i < ii; i++) {
        if (!isRef(value[i])) {
          continue;
        }
        value[i] = xref.fetch(value[i], suppressEncryption);
      }
      return value;
    },
    getRaw: function Dict_getRaw(key) {
      return this._map[key];
    },
    getKeys: function Dict_getKeys() {
      return Object.keys(this._map);
    },
    set: function Dict_set(key, value) {
      this._map[key] = value;
    },
    has: function Dict_has(key) {
      return key in this._map;
    },
    forEach: function Dict_forEach(callback) {
      for (var key in this._map) {
        callback(key, this.get(key));
      }
    }
  };
  Dict.empty = new Dict(null);
  Dict.merge = function (xref, dictArray) {
    var mergedDict = new Dict(xref);
    for (var i = 0, ii = dictArray.length; i < ii; i++) {
      var dict = dictArray[i];
      if (!isDict(dict)) {
        continue;
      }
      for (var keyName in dict._map) {
        if (mergedDict._map[keyName] !== undefined) {
          continue;
        }
        mergedDict._map[keyName] = dict._map[keyName];
      }
    }
    return mergedDict;
  };
  return Dict;
}();
var Ref = function RefClosure() {
  function Ref(num, gen) {
    this.num = num;
    this.gen = gen;
  }
  Ref.prototype = {
    toString: function Ref_toString() {
      var str = this.num + 'R';
      if (this.gen !== 0) {
        str += this.gen;
      }
      return str;
    }
  };
  return Ref;
}();
var RefSet = function RefSetClosure() {
  function RefSet() {
    this.dict = Object.create(null);
  }
  RefSet.prototype = {
    has: function RefSet_has(ref) {
      return ref.toString() in this.dict;
    },
    put: function RefSet_put(ref) {
      this.dict[ref.toString()] = true;
    },
    remove: function RefSet_remove(ref) {
      delete this.dict[ref.toString()];
    }
  };
  return RefSet;
}();
var RefSetCache = function RefSetCacheClosure() {
  function RefSetCache() {
    this.dict = Object.create(null);
  }
  RefSetCache.prototype = {
    get: function RefSetCache_get(ref) {
      return this.dict[ref.toString()];
    },
    has: function RefSetCache_has(ref) {
      return ref.toString() in this.dict;
    },
    put: function RefSetCache_put(ref, obj) {
      this.dict[ref.toString()] = obj;
    },
    putAlias: function RefSetCache_putAlias(ref, aliasRef) {
      this.dict[ref.toString()] = this.get(aliasRef);
    },
    forEach: function RefSetCache_forEach(fn, thisArg) {
      for (var i in this.dict) {
        fn.call(thisArg, this.dict[i]);
      }
    },
    clear: function RefSetCache_clear() {
      this.dict = Object.create(null);
    }
  };
  return RefSetCache;
}();
function isEOF(v) {
  return v === EOF;
}
function isName(v, name) {
  return v instanceof Name && (name === undefined || v.name === name);
}
function isCmd(v, cmd) {
  return v instanceof Cmd && (cmd === undefined || v.cmd === cmd);
}
function isDict(v, type) {
  return v instanceof Dict && (type === undefined || isName(v.get('Type'), type));
}
function isRef(v) {
  return v instanceof Ref;
}
function isRefsEqual(v1, v2) {
  return v1.num === v2.num && v1.gen === v2.gen;
}
function isStream(v) {
  return (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' && v !== null && v.getBytes !== undefined;
}
exports.EOF = EOF;
exports.Cmd = Cmd;
exports.Dict = Dict;
exports.Name = Name;
exports.Ref = Ref;
exports.RefSet = RefSet;
exports.RefSetCache = RefSetCache;
exports.isEOF = isEOF;
exports.isCmd = isCmd;
exports.isDict = isDict;
exports.isName = isName;
exports.isRef = isRef;
exports.isRefsEqual = isRefsEqual;
exports.isStream = isStream;

/***/ }),
/* 3 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function (it) {
  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var store = __w_pdfjs_require__(54)('wks');
var uid = __w_pdfjs_require__(17);
var _Symbol = __w_pdfjs_require__(1).Symbol;
var USE_SYMBOL = typeof _Symbol == 'function';
var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
};
$exports.store = store;

/***/ }),
/* 5 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LZWStream = exports.StringStream = exports.StreamsSequenceStream = exports.Stream = exports.RunLengthStream = exports.PredictorStream = exports.NullStream = exports.JpxStream = exports.JpegStream = exports.FlateStream = exports.DecodeStream = exports.DecryptStream = exports.AsciiHexStream = exports.Ascii85Stream = undefined;

var _util = __w_pdfjs_require__(0);

var _primitives = __w_pdfjs_require__(2);

var _jpg = __w_pdfjs_require__(129);

var _jpx = __w_pdfjs_require__(74);

var Stream = function StreamClosure() {
  function Stream(arrayBuffer, start, length, dict) {
    this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
    this.start = start || 0;
    this.pos = this.start;
    this.end = start + length || this.bytes.length;
    this.dict = dict;
  }
  Stream.prototype = {
    get length() {
      return this.end - this.start;
    },
    get isEmpty() {
      return this.length === 0;
    },
    getByte: function Stream_getByte() {
      if (this.pos >= this.end) {
        return -1;
      }
      return this.bytes[this.pos++];
    },
    getUint16: function Stream_getUint16() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      if (b0 === -1 || b1 === -1) {
        return -1;
      }
      return (b0 << 8) + b1;
    },
    getInt32: function Stream_getInt32() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      var b2 = this.getByte();
      var b3 = this.getByte();
      return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
    },
    getBytes: function Stream_getBytes(length) {
      var bytes = this.bytes;
      var pos = this.pos;
      var strEnd = this.end;
      if (!length) {
        return bytes.subarray(pos, strEnd);
      }
      var end = pos + length;
      if (end > strEnd) {
        end = strEnd;
      }
      this.pos = end;
      return bytes.subarray(pos, end);
    },
    peekByte: function Stream_peekByte() {
      var peekedByte = this.getByte();
      this.pos--;
      return peekedByte;
    },
    peekBytes: function Stream_peekBytes(length) {
      var bytes = this.getBytes(length);
      this.pos -= bytes.length;
      return bytes;
    },
    skip: function Stream_skip(n) {
      if (!n) {
        n = 1;
      }
      this.pos += n;
    },
    reset: function Stream_reset() {
      this.pos = this.start;
    },
    moveStart: function Stream_moveStart() {
      this.start = this.pos;
    },
    makeSubStream: function Stream_makeSubStream(start, length, dict) {
      return new Stream(this.bytes.buffer, start, length, dict);
    }
  };
  return Stream;
}();
var StringStream = function StringStreamClosure() {
  function StringStream(str) {
    var bytes = (0, _util.stringToBytes)(str);
    Stream.call(this, bytes);
  }
  StringStream.prototype = Stream.prototype;
  return StringStream;
}();
var DecodeStream = function DecodeStreamClosure() {
  var emptyBuffer = new Uint8Array(0);
  function DecodeStream(maybeMinBufferLength) {
    this.pos = 0;
    this.bufferLength = 0;
    this.eof = false;
    this.buffer = emptyBuffer;
    this.minBufferLength = 512;
    if (maybeMinBufferLength) {
      while (this.minBufferLength < maybeMinBufferLength) {
        this.minBufferLength *= 2;
      }
    }
  }
  DecodeStream.prototype = {
    get isEmpty() {
      while (!this.eof && this.bufferLength === 0) {
        this.readBlock();
      }
      return this.bufferLength === 0;
    },
    ensureBuffer: function DecodeStream_ensureBuffer(requested) {
      var buffer = this.buffer;
      if (requested <= buffer.byteLength) {
        return buffer;
      }
      var size = this.minBufferLength;
      while (size < requested) {
        size *= 2;
      }
      var buffer2 = new Uint8Array(size);
      buffer2.set(buffer);
      return this.buffer = buffer2;
    },
    getByte: function DecodeStream_getByte() {
      var pos = this.pos;
      while (this.bufferLength <= pos) {
        if (this.eof) {
          return -1;
        }
        this.readBlock();
      }
      return this.buffer[this.pos++];
    },
    getUint16: function DecodeStream_getUint16() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      if (b0 === -1 || b1 === -1) {
        return -1;
      }
      return (b0 << 8) + b1;
    },
    getInt32: function DecodeStream_getInt32() {
      var b0 = this.getByte();
      var b1 = this.getByte();
      var b2 = this.getByte();
      var b3 = this.getByte();
      return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
    },
    getBytes: function DecodeStream_getBytes(length) {
      var end,
          pos = this.pos;
      if (length) {
        this.ensureBuffer(pos + length);
        end = pos + length;
        while (!this.eof && this.bufferLength < end) {
          this.readBlock();
        }
        var bufEnd = this.bufferLength;
        if (end > bufEnd) {
          end = bufEnd;
        }
      } else {
        while (!this.eof) {
          this.readBlock();
        }
        end = this.bufferLength;
      }
      this.pos = end;
      return this.buffer.subarray(pos, end);
    },
    peekByte: function DecodeStream_peekByte() {
      var peekedByte = this.getByte();
      this.pos--;
      return peekedByte;
    },
    peekBytes: function DecodeStream_peekBytes(length) {
      var bytes = this.getBytes(length);
      this.pos -= bytes.length;
      return bytes;
    },
    makeSubStream: function DecodeStream_makeSubStream(start, length, dict) {
      var end = start + length;
      while (this.bufferLength <= end && !this.eof) {
        this.readBlock();
      }
      return new Stream(this.buffer, start, length, dict);
    },
    skip: function DecodeStream_skip(n) {
      if (!n) {
        n = 1;
      }
      this.pos += n;
    },
    reset: function DecodeStream_reset() {
      this.pos = 0;
    },
    getBaseStreams: function DecodeStream_getBaseStreams() {
      if (this.str && this.str.getBaseStreams) {
        return this.str.getBaseStreams();
      }
      return [];
    }
  };
  return DecodeStream;
}();
var StreamsSequenceStream = function StreamsSequenceStreamClosure() {
  function StreamsSequenceStream(streams) {
    this.streams = streams;
    DecodeStream.call(this, null);
  }
  StreamsSequenceStream.prototype = Object.create(DecodeStream.prototype);
  StreamsSequenceStream.prototype.readBlock = function streamSequenceStreamReadBlock() {
    var streams = this.streams;
    if (streams.length === 0) {
      this.eof = true;
      return;
    }
    var stream = streams.shift();
    var chunk = stream.getBytes();
    var bufferLength = this.bufferLength;
    var newLength = bufferLength + chunk.length;
    var buffer = this.ensureBuffer(newLength);
    buffer.set(chunk, bufferLength);
    this.bufferLength = newLength;
  };
  StreamsSequenceStream.prototype.getBaseStreams = function StreamsSequenceStream_getBaseStreams() {
    var baseStreams = [];
    for (var i = 0, ii = this.streams.length; i < ii; i++) {
      var stream = this.streams[i];
      if (stream.getBaseStreams) {
        _util.Util.appendToArray(baseStreams, stream.getBaseStreams());
      }
    }
    return baseStreams;
  };
  return StreamsSequenceStream;
}();
var FlateStream = function FlateStreamClosure() {
  var codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var lengthDecode = new Int32Array([0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a, 0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f, 0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073, 0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102]);
  var distDecode = new Int32Array([0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d, 0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1, 0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01, 0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001]);
  var fixedLitCodeTab = [new Int32Array([0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0, 0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0, 0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0, 0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8, 0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8, 0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8, 0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4, 0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4, 0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4, 0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc, 0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec, 0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc, 0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2, 0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2, 0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2, 0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca, 0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea, 0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da, 0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6, 0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6, 0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6, 0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce, 0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee, 0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de, 0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe, 0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1, 0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1, 0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1, 0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9, 0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9, 0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9, 0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5, 0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5, 0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5, 0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd, 0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed, 0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd, 0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3, 0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3, 0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3, 0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb, 0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb, 0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db, 0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7, 0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7, 0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7, 0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf, 0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef, 0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df, 0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff]), 9];
  var fixedDistCodeTab = [new Int32Array([0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c, 0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000, 0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d, 0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000]), 5];
  function FlateStream(str, maybeLength) {
    this.str = str;
    this.dict = str.dict;
    var cmf = str.getByte();
    var flg = str.getByte();
    if (cmf === -1 || flg === -1) {
      throw new _util.FormatError('Invalid header in flate stream: ' + cmf + ', ' + flg);
    }
    if ((cmf & 0x0f) !== 0x08) {
      throw new _util.FormatError('Unknown compression method in flate stream: ' + cmf + ', ' + flg);
    }
    if (((cmf << 8) + flg) % 31 !== 0) {
      throw new _util.FormatError('Bad FCHECK in flate stream: ' + cmf + ', ' + flg);
    }
    if (flg & 0x20) {
      throw new _util.FormatError('FDICT bit set in flate stream: ' + cmf + ', ' + flg);
    }
    this.codeSize = 0;
    this.codeBuf = 0;
    DecodeStream.call(this, maybeLength);
  }
  FlateStream.prototype = Object.create(DecodeStream.prototype);
  FlateStream.prototype.getBits = function FlateStream_getBits(bits) {
    var str = this.str;
    var codeSize = this.codeSize;
    var codeBuf = this.codeBuf;
    var b;
    while (codeSize < bits) {
      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError('Bad encoding in flate stream');
      }
      codeBuf |= b << codeSize;
      codeSize += 8;
    }
    b = codeBuf & (1 << bits) - 1;
    this.codeBuf = codeBuf >> bits;
    this.codeSize = codeSize -= bits;
    return b;
  };
  FlateStream.prototype.getCode = function FlateStream_getCode(table) {
    var str = this.str;
    var codes = table[0];
    var maxLen = table[1];
    var codeSize = this.codeSize;
    var codeBuf = this.codeBuf;
    var b;
    while (codeSize < maxLen) {
      if ((b = str.getByte()) === -1) {
        break;
      }
      codeBuf |= b << codeSize;
      codeSize += 8;
    }
    var code = codes[codeBuf & (1 << maxLen) - 1];
    var codeLen = code >> 16;
    var codeVal = code & 0xffff;
    if (codeLen < 1 || codeSize < codeLen) {
      throw new _util.FormatError('Bad encoding in flate stream');
    }
    this.codeBuf = codeBuf >> codeLen;
    this.codeSize = codeSize - codeLen;
    return codeVal;
  };
  FlateStream.prototype.generateHuffmanTable = function flateStreamGenerateHuffmanTable(lengths) {
    var n = lengths.length;
    var maxLen = 0;
    var i;
    for (i = 0; i < n; ++i) {
      if (lengths[i] > maxLen) {
        maxLen = lengths[i];
      }
    }
    var size = 1 << maxLen;
    var codes = new Int32Array(size);
    for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
      for (var val = 0; val < n; ++val) {
        if (lengths[val] === len) {
          var code2 = 0;
          var t = code;
          for (i = 0; i < len; ++i) {
            code2 = code2 << 1 | t & 1;
            t >>= 1;
          }
          for (i = code2; i < size; i += skip) {
            codes[i] = len << 16 | val;
          }
          ++code;
        }
      }
    }
    return [codes, maxLen];
  };
  FlateStream.prototype.readBlock = function FlateStream_readBlock() {
    var buffer, len;
    var str = this.str;
    var hdr = this.getBits(3);
    if (hdr & 1) {
      this.eof = true;
    }
    hdr >>= 1;
    if (hdr === 0) {
      var b;
      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError('Bad block header in flate stream');
      }
      var blockLen = b;
      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError('Bad block header in flate stream');
      }
      blockLen |= b << 8;
      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError('Bad block header in flate stream');
      }
      var check = b;
      if ((b = str.getByte()) === -1) {
        throw new _util.FormatError('Bad block header in flate stream');
      }
      check |= b << 8;
      if (check !== (~blockLen & 0xffff) && (blockLen !== 0 || check !== 0)) {
        throw new _util.FormatError('Bad uncompressed block length in flate stream');
      }
      this.codeBuf = 0;
      this.codeSize = 0;
      var bufferLength = this.bufferLength;
      buffer = this.ensureBuffer(bufferLength + blockLen);
      var end = bufferLength + blockLen;
      this.bufferLength = end;
      if (blockLen === 0) {
        if (str.peekByte() === -1) {
          this.eof = true;
        }
      } else {
        for (var n = bufferLength; n < end; ++n) {
          if ((b = str.getByte()) === -1) {
            this.eof = true;
            break;
          }
          buffer[n] = b;
        }
      }
      return;
    }
    var litCodeTable;
    var distCodeTable;
    if (hdr === 1) {
      litCodeTable = fixedLitCodeTab;
      distCodeTable = fixedDistCodeTab;
    } else if (hdr === 2) {
      var numLitCodes = this.getBits(5) + 257;
      var numDistCodes = this.getBits(5) + 1;
      var numCodeLenCodes = this.getBits(4) + 4;
      var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
      var i;
      for (i = 0; i < numCodeLenCodes; ++i) {
        codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
      }
      var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
      len = 0;
      i = 0;
      var codes = numLitCodes + numDistCodes;
      var codeLengths = new Uint8Array(codes);
      var bitsLength, bitsOffset, what;
      while (i < codes) {
        var code = this.getCode(codeLenCodeTab);
        if (code === 16) {
          bitsLength = 2;
          bitsOffset = 3;
          what = len;
        } else if (code === 17) {
          bitsLength = 3;
          bitsOffset = 3;
          what = len = 0;
        } else if (code === 18) {
          bitsLength = 7;
          bitsOffset = 11;
          what = len = 0;
        } else {
          codeLengths[i++] = len = code;
          continue;
        }
        var repeatLength = this.getBits(bitsLength) + bitsOffset;
        while (repeatLength-- > 0) {
          codeLengths[i++] = what;
        }
      }
      litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
      distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
    } else {
      throw new _util.FormatError('Unknown block type in flate stream');
    }
    buffer = this.buffer;
    var limit = buffer ? buffer.length : 0;
    var pos = this.bufferLength;
    while (true) {
      var code1 = this.getCode(litCodeTable);
      if (code1 < 256) {
        if (pos + 1 >= limit) {
          buffer = this.ensureBuffer(pos + 1);
          limit = buffer.length;
        }
        buffer[pos++] = code1;
        continue;
      }
      if (code1 === 256) {
        this.bufferLength = pos;
        return;
      }
      code1 -= 257;
      code1 = lengthDecode[code1];
      var code2 = code1 >> 16;
      if (code2 > 0) {
        code2 = this.getBits(code2);
      }
      len = (code1 & 0xffff) + code2;
      code1 = this.getCode(distCodeTable);
      code1 = distDecode[code1];
      code2 = code1 >> 16;
      if (code2 > 0) {
        code2 = this.getBits(code2);
      }
      var dist = (code1 & 0xffff) + code2;
      if (pos + len >= limit) {
        buffer = this.ensureBuffer(pos + len);
        limit = buffer.length;
      }
      for (var k = 0; k < len; ++k, ++pos) {
        buffer[pos] = buffer[pos - dist];
      }
    }
  };
  return FlateStream;
}();
var PredictorStream = function PredictorStreamClosure() {
  function PredictorStream(str, maybeLength, params) {
    if (!(0, _primitives.isDict)(params)) {
      return str;
    }
    var predictor = this.predictor = params.get('Predictor') || 1;
    if (predictor <= 1) {
      return str;
    }
    if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
      throw new _util.FormatError('Unsupported predictor: ' + predictor);
    }
    if (predictor === 2) {
      this.readBlock = this.readBlockTiff;
    } else {
      this.readBlock = this.readBlockPng;
    }
    this.str = str;
    this.dict = str.dict;
    var colors = this.colors = params.get('Colors') || 1;
    var bits = this.bits = params.get('BitsPerComponent') || 8;
    var columns = this.columns = params.get('Columns') || 1;
    this.pixBytes = colors * bits + 7 >> 3;
    this.rowBytes = columns * colors * bits + 7 >> 3;
    DecodeStream.call(this, maybeLength);
    return this;
  }
  PredictorStream.prototype = Object.create(DecodeStream.prototype);
  PredictorStream.prototype.readBlockTiff = function predictorStreamReadBlockTiff() {
    var rowBytes = this.rowBytes;
    var bufferLength = this.bufferLength;
    var buffer = this.ensureBuffer(bufferLength + rowBytes);
    var bits = this.bits;
    var colors = this.colors;
    var rawBytes = this.str.getBytes(rowBytes);
    this.eof = !rawBytes.length;
    if (this.eof) {
      return;
    }
    var inbuf = 0,
        outbuf = 0;
    var inbits = 0,
        outbits = 0;
    var pos = bufferLength;
    var i;
    if (bits === 1 && colors === 1) {
      for (i = 0; i < rowBytes; ++i) {
        var c = rawBytes[i] ^ inbuf;
        c ^= c >> 1;
        c ^= c >> 2;
        c ^= c >> 4;
        inbuf = (c & 1) << 7;
        buffer[pos++] = c;
      }
    } else if (bits === 8) {
      for (i = 0; i < colors; ++i) {
        buffer[pos++] = rawBytes[i];
      }
      for (; i < rowBytes; ++i) {
        buffer[pos] = buffer[pos - colors] + rawBytes[i];
        pos++;
      }
    } else if (bits === 16) {
      var bytesPerPixel = colors * 2;
      for (i = 0; i < bytesPerPixel; ++i) {
        buffer[pos++] = rawBytes[i];
      }
      for (; i < rowBytes; i += 2) {
        var sum = ((rawBytes[i] & 0xFF) << 8) + (rawBytes[i + 1] & 0xFF) + ((buffer[pos - bytesPerPixel] & 0xFF) << 8) + (buffer[pos - bytesPerPixel + 1] & 0xFF);
        buffer[pos++] = sum >> 8 & 0xFF;
        buffer[pos++] = sum & 0xFF;
      }
    } else {
      var compArray = new Uint8Array(colors + 1);
      var bitMask = (1 << bits) - 1;
      var j = 0,
          k = bufferLength;
      var columns = this.columns;
      for (i = 0; i < columns; ++i) {
        for (var kk = 0; kk < colors; ++kk) {
          if (inbits < bits) {
            inbuf = inbuf << 8 | rawBytes[j++] & 0xFF;
            inbits += 8;
          }
          compArray[kk] = compArray[kk] + (inbuf >> inbits - bits) & bitMask;
          inbits -= bits;
          outbuf = outbuf << bits | compArray[kk];
          outbits += bits;
          if (outbits >= 8) {
            buffer[k++] = outbuf >> outbits - 8 & 0xFF;
            outbits -= 8;
          }
        }
      }
      if (outbits > 0) {
        buffer[k++] = (outbuf << 8 - outbits) + (inbuf & (1 << 8 - outbits) - 1);
      }
    }
    this.bufferLength += rowBytes;
  };
  PredictorStream.prototype.readBlockPng = function predictorStreamReadBlockPng() {
    var rowBytes = this.rowBytes;
    var pixBytes = this.pixBytes;
    var predictor = this.str.getByte();
    var rawBytes = this.str.getBytes(rowBytes);
    this.eof = !rawBytes.length;
    if (this.eof) {
      return;
    }
    var bufferLength = this.bufferLength;
    var buffer = this.ensureBuffer(bufferLength + rowBytes);
    var prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
    if (prevRow.length === 0) {
      prevRow = new Uint8Array(rowBytes);
    }
    var i,
        j = bufferLength,
        up,
        c;
    switch (predictor) {
      case 0:
        for (i = 0; i < rowBytes; ++i) {
          buffer[j++] = rawBytes[i];
        }
        break;
      case 1:
        for (i = 0; i < pixBytes; ++i) {
          buffer[j++] = rawBytes[i];
        }
        for (; i < rowBytes; ++i) {
          buffer[j] = buffer[j - pixBytes] + rawBytes[i] & 0xFF;
          j++;
        }
        break;
      case 2:
        for (i = 0; i < rowBytes; ++i) {
          buffer[j++] = prevRow[i] + rawBytes[i] & 0xFF;
        }
        break;
      case 3:
        for (i = 0; i < pixBytes; ++i) {
          buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];
        }
        for (; i < rowBytes; ++i) {
          buffer[j] = (prevRow[i] + buffer[j - pixBytes] >> 1) + rawBytes[i] & 0xFF;
          j++;
        }
        break;
      case 4:
        for (i = 0; i < pixBytes; ++i) {
          up = prevRow[i];
          c = rawBytes[i];
          buffer[j++] = up + c;
        }
        for (; i < rowBytes; ++i) {
          up = prevRow[i];
          var upLeft = prevRow[i - pixBytes];
          var left = buffer[j - pixBytes];
          var p = left + up - upLeft;
          var pa = p - left;
          if (pa < 0) {
            pa = -pa;
          }
          var pb = p - up;
          if (pb < 0) {
            pb = -pb;
          }
          var pc = p - upLeft;
          if (pc < 0) {
            pc = -pc;
          }
          c = rawBytes[i];
          if (pa <= pb && pa <= pc) {
            buffer[j++] = left + c;
          } else if (pb <= pc) {
            buffer[j++] = up + c;
          } else {
            buffer[j++] = upLeft + c;
          }
        }
        break;
      default:
        throw new _util.FormatError('Unsupported predictor: ' + predictor);
    }
    this.bufferLength += rowBytes;
  };
  return PredictorStream;
}();
var JpegStream = function JpegStreamClosure() {
  function JpegStream(stream, maybeLength, dict, params) {
    var ch;
    while ((ch = stream.getByte()) !== -1) {
      if (ch === 0xFF) {
        stream.skip(-1);
        break;
      }
    }
    this.stream = stream;
    this.maybeLength = maybeLength;
    this.dict = dict;
    this.params = params;
    DecodeStream.call(this, maybeLength);
  }
  JpegStream.prototype = Object.create(DecodeStream.prototype);
  Object.defineProperty(JpegStream.prototype, 'bytes', {
    get: function JpegStream_bytes() {
      return (0, _util.shadow)(this, 'bytes', this.stream.getBytes(this.maybeLength));
    },
    configurable: true
  });
  JpegStream.prototype.ensureBuffer = function JpegStream_ensureBuffer(req) {
    if (this.bufferLength) {
      return;
    }
    var jpegImage = new _jpg.JpegImage();
    var decodeArr = this.dict.getArray('Decode', 'D');
    if (this.forceRGB && Array.isArray(decodeArr)) {
      var bitsPerComponent = this.dict.get('BitsPerComponent') || 8;
      var decodeArrLength = decodeArr.length;
      var transform = new Int32Array(decodeArrLength);
      var transformNeeded = false;
      var maxValue = (1 << bitsPerComponent) - 1;
      for (var i = 0; i < decodeArrLength; i += 2) {
        transform[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0;
        transform[i + 1] = decodeArr[i] * maxValue | 0;
        if (transform[i] !== 256 || transform[i + 1] !== 0) {
          transformNeeded = true;
        }
      }
      if (transformNeeded) {
        jpegImage.decodeTransform = transform;
      }
    }
    if ((0, _primitives.isDict)(this.params)) {
      var colorTransform = this.params.get('ColorTransform');
      if (Number.isInteger(colorTransform)) {
        jpegImage.colorTransform = colorTransform;
      }
    }
    jpegImage.parse(this.bytes);
    var data = jpegImage.getData(this.drawWidth, this.drawHeight, this.forceRGB);
    this.buffer = data;
    this.bufferLength = data.length;
    this.eof = true;
  };
  JpegStream.prototype.getBytes = function JpegStream_getBytes(length) {
    this.ensureBuffer();
    return this.buffer;
  };
  JpegStream.prototype.getIR = function JpegStream_getIR(forceDataSchema) {
    return (0, _util.createObjectURL)(this.bytes, 'image/jpeg', forceDataSchema);
  };
  return JpegStream;
}();
var JpxStream = function JpxStreamClosure() {
  function JpxStream(stream, maybeLength, dict, params) {
    this.stream = stream;
    this.maybeLength = maybeLength;
    this.dict = dict;
    this.params = params;
    DecodeStream.call(this, maybeLength);
  }
  JpxStream.prototype = Object.create(DecodeStream.prototype);
  Object.defineProperty(JpxStream.prototype, 'bytes', {
    get: function JpxStream_bytes() {
      return (0, _util.shadow)(this, 'bytes', this.stream.getBytes(this.maybeLength));
    },
    configurable: true
  });
  JpxStream.prototype.ensureBuffer = function JpxStream_ensureBuffer(req) {
    if (this.bufferLength) {
      return;
    }
    var jpxImage = new _jpx.JpxImage();
    jpxImage.parse(this.bytes);
    var width = jpxImage.width;
    var height = jpxImage.height;
    var componentsCount = jpxImage.componentsCount;
    var tileCount = jpxImage.tiles.length;
    if (tileCount === 1) {
      this.buffer = jpxImage.tiles[0].items;
    } else {
      var data = new Uint8ClampedArray(width * height * componentsCount);
      for (var k = 0; k < tileCount; k++) {
        var tileComponents = jpxImage.tiles[k];
        var tileWidth = tileComponents.width;
        var tileHeight = tileComponents.height;
        var tileLeft = tileComponents.left;
        var tileTop = tileComponents.top;
        var src = tileComponents.items;
        var srcPosition = 0;
        var dataPosition = (width * tileTop + tileLeft) * componentsCount;
        var imgRowSize = width * componentsCount;
        var tileRowSize = tileWidth * componentsCount;
        for (var j = 0; j < tileHeight; j++) {
          var rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize);
          data.set(rowBytes, dataPosition);
          srcPosition += tileRowSize;
          dataPosition += imgRowSize;
        }
      }
      this.buffer = data;
    }
    this.bufferLength = this.buffer.length;
    this.eof = true;
  };
  return JpxStream;
}();
var DecryptStream = function DecryptStreamClosure() {
  function DecryptStream(str, maybeLength, decrypt) {
    this.str = str;
    this.dict = str.dict;
    this.decrypt = decrypt;
    this.nextChunk = null;
    this.initialized = false;
    DecodeStream.call(this, maybeLength);
  }
  var chunkSize = 512;
  DecryptStream.prototype = Object.create(DecodeStream.prototype);
  DecryptStream.prototype.readBlock = function DecryptStream_readBlock() {
    var chunk;
    if (this.initialized) {
      chunk = this.nextChunk;
    } else {
      chunk = this.str.getBytes(chunkSize);
      this.initialized = true;
    }
    if (!chunk || chunk.length === 0) {
      this.eof = true;
      return;
    }
    this.nextChunk = this.str.getBytes(chunkSize);
    var hasMoreData = this.nextChunk && this.nextChunk.length > 0;
    var decrypt = this.decrypt;
    chunk = decrypt(chunk, !hasMoreData);
    var bufferLength = this.bufferLength;
    var i,
        n = chunk.length;
    var buffer = this.ensureBuffer(bufferLength + n);
    for (i = 0; i < n; i++) {
      buffer[bufferLength++] = chunk[i];
    }
    this.bufferLength = bufferLength;
  };
  return DecryptStream;
}();
var Ascii85Stream = function Ascii85StreamClosure() {
  function Ascii85Stream(str, maybeLength) {
    this.str = str;
    this.dict = str.dict;
    this.input = new Uint8Array(5);
    if (maybeLength) {
      maybeLength = 0.8 * maybeLength;
    }
    DecodeStream.call(this, maybeLength);
  }
  Ascii85Stream.prototype = Object.create(DecodeStream.prototype);
  Ascii85Stream.prototype.readBlock = function Ascii85Stream_readBlock() {
    var TILDA_CHAR = 0x7E;
    var Z_LOWER_CHAR = 0x7A;
    var EOF = -1;
    var str = this.str;
    var c = str.getByte();
    while ((0, _util.isSpace)(c)) {
      c = str.getByte();
    }
    if (c === EOF || c === TILDA_CHAR) {
      this.eof = true;
      return;
    }
    var bufferLength = this.bufferLength,
        buffer;
    var i;
    if (c === Z_LOWER_CHAR) {
      buffer = this.ensureBuffer(bufferLength + 4);
      for (i = 0; i < 4; ++i) {
        buffer[bufferLength + i] = 0;
      }
      this.bufferLength += 4;
    } else {
      var input = this.input;
      input[0] = c;
      for (i = 1; i < 5; ++i) {
        c = str.getByte();
        while ((0, _util.isSpace)(c)) {
          c = str.getByte();
        }
        input[i] = c;
        if (c === EOF || c === TILDA_CHAR) {
          break;
        }
      }
      buffer = this.ensureBuffer(bufferLength + i - 1);
      this.bufferLength += i - 1;
      if (i < 5) {
        for (; i < 5; ++i) {
          input[i] = 0x21 + 84;
        }
        this.eof = true;
      }
      var t = 0;
      for (i = 0; i < 5; ++i) {
        t = t * 85 + (input[i] - 0x21);
      }
      for (i = 3; i >= 0; --i) {
        buffer[bufferLength + i] = t & 0xFF;
        t >>= 8;
      }
    }
  };
  return Ascii85Stream;
}();
var AsciiHexStream = function AsciiHexStreamClosure() {
  function AsciiHexStream(str, maybeLength) {
    this.str = str;
    this.dict = str.dict;
    this.firstDigit = -1;
    if (maybeLength) {
      maybeLength = 0.5 * maybeLength;
    }
    DecodeStream.call(this, maybeLength);
  }
  AsciiHexStream.prototype = Object.create(DecodeStream.prototype);
  AsciiHexStream.prototype.readBlock = function AsciiHexStream_readBlock() {
    var UPSTREAM_BLOCK_SIZE = 8000;
    var bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE);
    if (!bytes.length) {
      this.eof = true;
      return;
    }
    var maxDecodeLength = bytes.length + 1 >> 1;
    var buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
    var bufferLength = this.bufferLength;
    var firstDigit = this.firstDigit;
    for (var i = 0, ii = bytes.length; i < ii; i++) {
      var ch = bytes[i],
          digit;
      if (ch >= 0x30 && ch <= 0x39) {
        digit = ch & 0x0F;
      } else if (ch >= 0x41 && ch <= 0x46 || ch >= 0x61 && ch <= 0x66) {
        digit = (ch & 0x0F) + 9;
      } else if (ch === 0x3E) {
        this.eof = true;
        break;
      } else {
        continue;
      }
      if (firstDigit < 0) {
        firstDigit = digit;
      } else {
        buffer[bufferLength++] = firstDigit << 4 | digit;
        firstDigit = -1;
      }
    }
    if (firstDigit >= 0 && this.eof) {
      buffer[bufferLength++] = firstDigit << 4;
      firstDigit = -1;
    }
    this.firstDigit = firstDigit;
    this.bufferLength = bufferLength;
  };
  return AsciiHexStream;
}();
var RunLengthStream = function RunLengthStreamClosure() {
  function RunLengthStream(str, maybeLength) {
    this.str = str;
    this.dict = str.dict;
    DecodeStream.call(this, maybeLength);
  }
  RunLengthStream.prototype = Object.create(DecodeStream.prototype);
  RunLengthStream.prototype.readBlock = function RunLengthStream_readBlock() {
    var repeatHeader = this.str.getBytes(2);
    if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
      this.eof = true;
      return;
    }
    var buffer;
    var bufferLength = this.bufferLength;
    var n = repeatHeader[0];
    if (n < 128) {
      buffer = this.ensureBuffer(bufferLength + n + 1);
      buffer[bufferLength++] = repeatHeader[1];
      if (n > 0) {
        var source = this.str.getBytes(n);
        buffer.set(source, bufferLength);
        bufferLength += n;
      }
    } else {
      n = 257 - n;
      var b = repeatHeader[1];
      buffer = this.ensureBuffer(bufferLength + n + 1);
      for (var i = 0; i < n; i++) {
        buffer[bufferLength++] = b;
      }
    }
    this.bufferLength = bufferLength;
  };
  return RunLengthStream;
}();
var LZWStream = function LZWStreamClosure() {
  function LZWStream(str, maybeLength, earlyChange) {
    this.str = str;
    this.dict = str.dict;
    this.cachedData = 0;
    this.bitsCached = 0;
    var maxLzwDictionarySize = 4096;
    var lzwState = {
      earlyChange: earlyChange,
      codeLength: 9,
      nextCode: 258,
      dictionaryValues: new Uint8Array(maxLzwDictionarySize),
      dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
      dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
      currentSequence: new Uint8Array(maxLzwDictionarySize),
      currentSequenceLength: 0
    };
    for (var i = 0; i < 256; ++i) {
      lzwState.dictionaryValues[i] = i;
      lzwState.dictionaryLengths[i] = 1;
    }
    this.lzwState = lzwState;
    DecodeStream.call(this, maybeLength);
  }
  LZWStream.prototype = Object.create(DecodeStream.prototype);
  LZWStream.prototype.readBits = function LZWStream_readBits(n) {
    var bitsCached = this.bitsCached;
    var cachedData = this.cachedData;
    while (bitsCached < n) {
      var c = this.str.getByte();
      if (c === -1) {
        this.eof = true;
        return null;
      }
      cachedData = cachedData << 8 | c;
      bitsCached += 8;
    }
    this.bitsCached = bitsCached -= n;
    this.cachedData = cachedData;
    this.lastCode = null;
    return cachedData >>> bitsCached & (1 << n) - 1;
  };
  LZWStream.prototype.readBlock = function LZWStream_readBlock() {
    var blockSize = 512;
    var estimatedDecodedSize = blockSize * 2,
        decodedSizeDelta = blockSize;
    var i, j, q;
    var lzwState = this.lzwState;
    if (!lzwState) {
      return;
    }
    var earlyChange = lzwState.earlyChange;
    var nextCode = lzwState.nextCode;
    var dictionaryValues = lzwState.dictionaryValues;
    var dictionaryLengths = lzwState.dictionaryLengths;
    var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
    var codeLength = lzwState.codeLength;
    var prevCode = lzwState.prevCode;
    var currentSequence = lzwState.currentSequence;
    var currentSequenceLength = lzwState.currentSequenceLength;
    var decodedLength = 0;
    var currentBufferLength = this.bufferLength;
    var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
    for (i = 0; i < blockSize; i++) {
      var code = this.readBits(codeLength);
      var hasPrev = currentSequenceLength > 0;
      if (code < 256) {
        currentSequence[0] = code;
        currentSequenceLength = 1;
      } else if (code >= 258) {
        if (code < nextCode) {
          currentSequenceLength = dictionaryLengths[code];
          for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
            currentSequence[j] = dictionaryValues[q];
            q = dictionaryPrevCodes[q];
          }
        } else {
          currentSequence[currentSequenceLength++] = currentSequence[0];
        }
      } else if (code === 256) {
        codeLength = 9;
        nextCode = 258;
        currentSequenceLength = 0;
        continue;
      } else {
        this.eof = true;
        delete this.lzwState;
        break;
      }
      if (hasPrev) {
        dictionaryPrevCodes[nextCode] = prevCode;
        dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
        dictionaryValues[nextCode] = currentSequence[0];
        nextCode++;
        codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
      }
      prevCode = code;
      decodedLength += currentSequenceLength;
      if (estimatedDecodedSize < decodedLength) {
        do {
          estimatedDecodedSize += decodedSizeDelta;
        } while (estimatedDecodedSize < decodedLength);
        buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
      }
      for (j = 0; j < currentSequenceLength; j++) {
        buffer[currentBufferLength++] = currentSequence[j];
      }
    }
    lzwState.nextCode = nextCode;
    lzwState.codeLength = codeLength;
    lzwState.prevCode = prevCode;
    lzwState.currentSequenceLength = currentSequenceLength;
    this.bufferLength = currentBufferLength;
  };
  return LZWStream;
}();
var NullStream = function NullStreamClosure() {
  function NullStream() {
    Stream.call(this, new Uint8Array(0));
  }
  NullStream.prototype = Stream.prototype;
  return NullStream;
}();
exports.Ascii85Stream = Ascii85Stream;
exports.AsciiHexStream = AsciiHexStream;
exports.DecryptStream = DecryptStream;
exports.DecodeStream = DecodeStream;
exports.FlateStream = FlateStream;
exports.JpegStream = JpegStream;
exports.JpxStream = JpxStream;
exports.NullStream = NullStream;
exports.PredictorStream = PredictorStream;
exports.RunLengthStream = RunLengthStream;
exports.Stream = Stream;
exports.StreamsSequenceStream = StreamsSequenceStream;
exports.StringStream = StringStream;
exports.LZWStream = LZWStream;

/***/ }),
/* 6 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var core = module.exports = { version: '2.5.7' };
if (typeof __e == 'number') __e = core;

/***/ }),
/* 7 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var global = __w_pdfjs_require__(1);
var core = __w_pdfjs_require__(6);
var hide = __w_pdfjs_require__(8);
var redefine = __w_pdfjs_require__(16);
var ctx = __w_pdfjs_require__(13);
var PROTOTYPE = 'prototype';
var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    own = !IS_FORCED && target && target[key] !== undefined;
    out = (own ? target : source)[key];
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    if (target) redefine(target, key, out, type & $export.U);
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
$export.F = 1;
$export.G = 2;
$export.S = 4;
$export.P = 8;
$export.B = 16;
$export.W = 32;
$export.U = 64;
$export.R = 128;
module.exports = $export;

/***/ }),
/* 8 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var dP = __w_pdfjs_require__(15);
var createDesc = __w_pdfjs_require__(29);
module.exports = __w_pdfjs_require__(10) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var isObject = __w_pdfjs_require__(3);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = !__w_pdfjs_require__(11)(function () {
  return Object.defineProperty({}, 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),
/* 11 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var aFunction = __w_pdfjs_require__(22);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function () {
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var toInteger = __w_pdfjs_require__(18);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var anObject = __w_pdfjs_require__(9);
var IE8_DOM_DEFINE = __w_pdfjs_require__(48);
var toPrimitive = __w_pdfjs_require__(36);
var dP = Object.defineProperty;
exports.f = __w_pdfjs_require__(10) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var global = __w_pdfjs_require__(1);
var hide = __w_pdfjs_require__(8);
var has = __w_pdfjs_require__(12);
var SRC = __w_pdfjs_require__(17)('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);
__w_pdfjs_require__(6).inspectSource = function (it) {
  return $toString.call(it);
};
(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),
/* 17 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var defined = __w_pdfjs_require__(38);
module.exports = function (it) {
  return Object(defined(it));
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = {};

/***/ }),
/* 21 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = false;

/***/ }),
/* 22 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var redefine = __w_pdfjs_require__(16);
module.exports = function (target, src, safe) {
  for (var key in src) {
    redefine(target, key, src[key], safe);
  }return target;
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }
  return it;
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var toString = {}.toString;
module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 26 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var def = __w_pdfjs_require__(15).f;
var has = __w_pdfjs_require__(12);
var TAG = __w_pdfjs_require__(4)('toStringTag');
module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
    configurable: true,
    value: tag
  });
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorSpace = undefined;

var _util = __w_pdfjs_require__(0);

var _primitives = __w_pdfjs_require__(2);

var ColorSpace = function ColorSpaceClosure() {
  function resizeRgbImage(src, bpc, w1, h1, w2, h2, alpha01, dest) {
    var COMPONENTS = 3;
    alpha01 = alpha01 !== 1 ? 0 : alpha01;
    var xRatio = w1 / w2;
    var yRatio = h1 / h2;
    var i,
        j,
        py,
        newIndex = 0,
        oldIndex;
    var xScaled = new Uint16Array(w2);
    var w1Scanline = w1 * COMPONENTS;
    for (i = 0; i < w2; i++) {
      xScaled[i] = Math.floor(i * xRatio) * COMPONENTS;
    }
    for (i = 0; i < h2; i++) {
      py = Math.floor(i * yRatio) * w1Scanline;
      for (j = 0; j < w2; j++) {
        oldIndex = py + xScaled[j];
        dest[newIndex++] = src[oldIndex++];
        dest[newIndex++] = src[oldIndex++];
        dest[newIndex++] = src[oldIndex++];
        newIndex += alpha01;
      }
    }
  }
  function ColorSpace() {
    throw new Error('should not call ColorSpace constructor');
  }
  ColorSpace.prototype = {
    getRgb: function ColorSpace_getRgb(src, srcOffset) {
      var rgb = new Uint8Array(3);
      this.getRgbItem(src, srcOffset, rgb, 0);
      return rgb;
    },
    getRgbItem: function ColorSpace_getRgbItem(src, srcOffset, dest, destOffset) {
      throw new Error('Should not call ColorSpace.getRgbItem');
    },
    getRgbBuffer: function ColorSpace_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      throw new Error('Should not call ColorSpace.getRgbBuffer');
    },
    getOutputLength: function ColorSpace_getOutputLength(inputLength, alpha01) {
      throw new Error('Should not call ColorSpace.getOutputLength');
    },
    isPassthrough: function ColorSpace_isPassthrough(bits) {
      return false;
    },
    fillRgb: function ColorSpace_fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) {
      var count = originalWidth * originalHeight;
      var rgbBuf = null;
      var numComponentColors = 1 << bpc;
      var needsResizing = originalHeight !== height || originalWidth !== width;
      var i, ii;
      if (this.isPassthrough(bpc)) {
        rgbBuf = comps;
      } else if (this.numComps === 1 && count > numComponentColors && this.name !== 'DeviceGray' && this.name !== 'DeviceRGB') {
        var allColors = bpc <= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors);
        var key;
        for (i = 0; i < numComponentColors; i++) {
          allColors[i] = i;
        }
        var colorMap = new Uint8Array(numComponentColors * 3);
        this.getRgbBuffer(allColors, 0, numComponentColors, colorMap, 0, bpc, 0);
        var destPos, rgbPos;
        if (!needsResizing) {
          destPos = 0;
          for (i = 0; i < count; ++i) {
            key = comps[i] * 3;
            dest[destPos++] = colorMap[key];
            dest[destPos++] = colorMap[key + 1];
            dest[destPos++] = colorMap[key + 2];
            destPos += alpha01;
          }
        } else {
          rgbBuf = new Uint8Array(count * 3);
          rgbPos = 0;
          for (i = 0; i < count; ++i) {
            key = comps[i] * 3;
            rgbBuf[rgbPos++] = colorMap[key];
            rgbBuf[rgbPos++] = colorMap[key + 1];
            rgbBuf[rgbPos++] = colorMap[key + 2];
          }
        }
      } else {
        if (!needsResizing) {
          this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01);
        } else {
          rgbBuf = new Uint8Array(count * 3);
          this.getRgbBuffer(comps, 0, count, rgbBuf, 0, bpc, 0);
        }
      }
      if (rgbBuf) {
        if (needsResizing) {
          resizeRgbImage(rgbBuf, bpc, originalWidth, originalHeight, width, height, alpha01, dest);
        } else {
          rgbPos = 0;
          destPos = 0;
          for (i = 0, ii = width * actualHeight; i < ii; i++) {
            dest[destPos++] = rgbBuf[rgbPos++];
            dest[destPos++] = rgbBuf[rgbPos++];
            dest[destPos++] = rgbBuf[rgbPos++];
            destPos += alpha01;
          }
        }
      }
    },
    usesZeroToOneRange: true
  };
  ColorSpace.parse = function (cs, xref, res, pdfFunctionFactory) {
    var IR = ColorSpace.parseToIR(cs, xref, res, pdfFunctionFactory);
    return ColorSpace.fromIR(IR);
  };
  ColorSpace.fromIR = function (IR) {
    var name = Array.isArray(IR) ? IR[0] : IR;
    var whitePoint, blackPoint, gamma;
    switch (name) {
      case 'DeviceGrayCS':
        return this.singletons.gray;
      case 'DeviceRgbCS':
        return this.singletons.rgb;
      case 'DeviceCmykCS':
        return this.singletons.cmyk;
      case 'CalGrayCS':
        whitePoint = IR[1];
        blackPoint = IR[2];
        gamma = IR[3];
        return new CalGrayCS(whitePoint, blackPoint, gamma);
      case 'CalRGBCS':
        whitePoint = IR[1];
        blackPoint = IR[2];
        gamma = IR[3];
        var matrix = IR[4];
        return new CalRGBCS(whitePoint, blackPoint, gamma, matrix);
      case 'PatternCS':
        var basePatternCS = IR[1];
        if (basePatternCS) {
          basePatternCS = ColorSpace.fromIR(basePatternCS);
        }
        return new PatternCS(basePatternCS);
      case 'IndexedCS':
        var baseIndexedCS = IR[1];
        var hiVal = IR[2];
        var lookup = IR[3];
        return new IndexedCS(ColorSpace.fromIR(baseIndexedCS), hiVal, lookup);
      case 'AlternateCS':
        var numComps = IR[1];
        var alt = IR[2];
        var tintFn = IR[3];
        return new AlternateCS(numComps, ColorSpace.fromIR(alt), tintFn);
      case 'LabCS':
        whitePoint = IR[1];
        blackPoint = IR[2];
        var range = IR[3];
        return new LabCS(whitePoint, blackPoint, range);
      default:
        throw new _util.FormatError('Unknown colorspace name: ' + name);
    }
  };
  ColorSpace.parseToIR = function (cs, xref, res, pdfFunctionFactory) {
    if ((0, _primitives.isName)(cs)) {
      var colorSpaces = res.get('ColorSpace');
      if ((0, _primitives.isDict)(colorSpaces)) {
        var refcs = colorSpaces.get(cs.name);
        if (refcs) {
          cs = refcs;
        }
      }
    }
    cs = xref.fetchIfRef(cs);
    if ((0, _primitives.isName)(cs)) {
      switch (cs.name) {
        case 'DeviceGray':
        case 'G':
          return 'DeviceGrayCS';
        case 'DeviceRGB':
        case 'RGB':
          return 'DeviceRgbCS';
        case 'DeviceCMYK':
        case 'CMYK':
          return 'DeviceCmykCS';
        case 'Pattern':
          return ['PatternCS', null];
        default:
          throw new _util.FormatError('unrecognized colorspace ' + cs.name);
      }
    }
    if (Array.isArray(cs)) {
      var mode = xref.fetchIfRef(cs[0]).name;
      var numComps, params, alt, whitePoint, blackPoint, gamma;
      switch (mode) {
        case 'DeviceGray':
        case 'G':
          return 'DeviceGrayCS';
        case 'DeviceRGB':
        case 'RGB':
          return 'DeviceRgbCS';
        case 'DeviceCMYK':
        case 'CMYK':
          return 'DeviceCmykCS';
        case 'CalGray':
          params = xref.fetchIfRef(cs[1]);
          whitePoint = params.getArray('WhitePoint');
          blackPoint = params.getArray('BlackPoint');
          gamma = params.get('Gamma');
          return ['CalGrayCS', whitePoint, blackPoint, gamma];
        case 'CalRGB':
          params = xref.fetchIfRef(cs[1]);
          whitePoint = params.getArray('WhitePoint');
          blackPoint = params.getArray('BlackPoint');
          gamma = params.getArray('Gamma');
          var matrix = params.getArray('Matrix');
          return ['CalRGBCS', whitePoint, blackPoint, gamma, matrix];
        case 'ICCBased':
          var stream = xref.fetchIfRef(cs[1]);
          var dict = stream.dict;
          numComps = dict.get('N');
          alt = dict.get('Alternate');
          if (alt) {
            var altIR = ColorSpace.parseToIR(alt, xref, res, pdfFunctionFactory);
            var altCS = ColorSpace.fromIR(altIR, pdfFunctionFactory);
            if (altCS.numComps === numComps) {
              return altIR;
            }
            (0, _util.warn)('ICCBased color space: Ignoring incorrect /Alternate entry.');
          }
          if (numComps === 1) {
            return 'DeviceGrayCS';
          } else if (numComps === 3) {
            return 'DeviceRgbCS';
          } else if (numComps === 4) {
            return 'DeviceCmykCS';
          }
          break;
        case 'Pattern':
          var basePatternCS = cs[1] || null;
          if (basePatternCS) {
            basePatternCS = ColorSpace.parseToIR(basePatternCS, xref, res, pdfFunctionFactory);
          }
          return ['PatternCS', basePatternCS];
        case 'Indexed':
        case 'I':
          var baseIndexedCS = ColorSpace.parseToIR(cs[1], xref, res, pdfFunctionFactory);
          var hiVal = xref.fetchIfRef(cs[2]) + 1;
          var lookup = xref.fetchIfRef(cs[3]);
          if ((0, _primitives.isStream)(lookup)) {
            lookup = lookup.getBytes();
          }
          return ['IndexedCS', baseIndexedCS, hiVal, lookup];
        case 'Separation':
        case 'DeviceN':
          var name = xref.fetchIfRef(cs[1]);
          numComps = Array.isArray(name) ? name.length : 1;
          alt = ColorSpace.parseToIR(cs[2], xref, res, pdfFunctionFactory);
          var tintFn = pdfFunctionFactory.create(xref.fetchIfRef(cs[3]));
          return ['AlternateCS', numComps, alt, tintFn];
        case 'Lab':
          params = xref.fetchIfRef(cs[1]);
          whitePoint = params.getArray('WhitePoint');
          blackPoint = params.getArray('BlackPoint');
          var range = params.getArray('Range');
          return ['LabCS', whitePoint, blackPoint, range];
        default:
          throw new _util.FormatError('unimplemented color space object "' + mode + '"');
      }
    }
    throw new _util.FormatError('unrecognized color space object: "' + cs + '"');
  };
  ColorSpace.isDefaultDecode = function ColorSpace_isDefaultDecode(decode, n) {
    if (!Array.isArray(decode)) {
      return true;
    }
    if (n * 2 !== decode.length) {
      (0, _util.warn)('The decode map is not the correct length');
      return true;
    }
    for (var i = 0, ii = decode.length; i < ii; i += 2) {
      if (decode[i] !== 0 || decode[i + 1] !== 1) {
        return false;
      }
    }
    return true;
  };
  ColorSpace.singletons = {
    get gray() {
      return (0, _util.shadow)(this, 'gray', new DeviceGrayCS());
    },
    get rgb() {
      return (0, _util.shadow)(this, 'rgb', new DeviceRgbCS());
    },
    get cmyk() {
      return (0, _util.shadow)(this, 'cmyk', new DeviceCmykCS());
    }
  };
  return ColorSpace;
}();
var AlternateCS = function AlternateCSClosure() {
  function AlternateCS(numComps, base, tintFn) {
    this.name = 'Alternate';
    this.numComps = numComps;
    this.defaultColor = new Float32Array(numComps);
    for (var i = 0; i < numComps; ++i) {
      this.defaultColor[i] = 1;
    }
    this.base = base;
    this.tintFn = tintFn;
    this.tmpBuf = new Float32Array(base.numComps);
  }
  AlternateCS.prototype = {
    getRgb: ColorSpace.prototype.getRgb,
    getRgbItem: function AlternateCS_getRgbItem(src, srcOffset, dest, destOffset) {
      var tmpBuf = this.tmpBuf;
      this.tintFn(src, srcOffset, tmpBuf, 0);
      this.base.getRgbItem(tmpBuf, 0, dest, destOffset);
    },
    getRgbBuffer: function AlternateCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      var tintFn = this.tintFn;
      var base = this.base;
      var scale = 1 / ((1 << bits) - 1);
      var baseNumComps = base.numComps;
      var usesZeroToOneRange = base.usesZeroToOneRange;
      var isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) && alpha01 === 0;
      var pos = isPassthrough ? destOffset : 0;
      var baseBuf = isPassthrough ? dest : new Uint8Array(baseNumComps * count);
      var numComps = this.numComps;
      var scaled = new Float32Array(numComps);
      var tinted = new Float32Array(baseNumComps);
      var i, j;
      for (i = 0; i < count; i++) {
        for (j = 0; j < numComps; j++) {
          scaled[j] = src[srcOffset++] * scale;
        }
        tintFn(scaled, 0, tinted, 0);
        if (usesZeroToOneRange) {
          for (j = 0; j < baseNumComps; j++) {
            baseBuf[pos++] = tinted[j] * 255;
          }
        } else {
          base.getRgbItem(tinted, 0, baseBuf, pos);
          pos += baseNumComps;
        }
      }
      if (!isPassthrough) {
        base.getRgbBuffer(baseBuf, 0, count, dest, destOffset, 8, alpha01);
      }
    },
    getOutputLength: function AlternateCS_getOutputLength(inputLength, alpha01) {
      return this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01);
    },
    isPassthrough: ColorSpace.prototype.isPassthrough,
    fillRgb: ColorSpace.prototype.fillRgb,
    isDefaultDecode: function AlternateCS_isDefaultDecode(decodeMap) {
      return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
    },
    usesZeroToOneRange: true
  };
  return AlternateCS;
}();
var PatternCS = function PatternCSClosure() {
  function PatternCS(baseCS) {
    this.name = 'Pattern';
    this.base = baseCS;
  }
  PatternCS.prototype = {};
  return PatternCS;
}();
var IndexedCS = function IndexedCSClosure() {
  function IndexedCS(base, highVal, lookup) {
    this.name = 'Indexed';
    this.numComps = 1;
    this.defaultColor = new Uint8Array(this.numComps);
    this.base = base;
    this.highVal = highVal;
    var baseNumComps = base.numComps;
    var length = baseNumComps * highVal;
    if ((0, _primitives.isStream)(lookup)) {
      this.lookup = new Uint8Array(length);
      var bytes = lookup.getBytes(length);
      this.lookup.set(bytes);
    } else if ((0, _util.isString)(lookup)) {
      this.lookup = new Uint8Array(length);
      for (var i = 0; i < length; ++i) {
        this.lookup[i] = lookup.charCodeAt(i);
      }
    } else if (lookup instanceof Uint8Array || lookup instanceof Array) {
      this.lookup = lookup;
    } else {
      throw new _util.FormatError('Unrecognized lookup table: ' + lookup);
    }
  }
  IndexedCS.prototype = {
    getRgb: ColorSpace.prototype.getRgb,
    getRgbItem: function IndexedCS_getRgbItem(src, srcOffset, dest, destOffset) {
      var numComps = this.base.numComps;
      var start = src[srcOffset] * numComps;
      this.base.getRgbBuffer(this.lookup, start, 1, dest, destOffset, 8, 0);
    },
    getRgbBuffer: function IndexedCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      var base = this.base;
      var numComps = base.numComps;
      var outputDelta = base.getOutputLength(numComps, alpha01);
      var lookup = this.lookup;
      for (var i = 0; i < count; ++i) {
        var lookupPos = src[srcOffset++] * numComps;
        base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);
        destOffset += outputDelta;
      }
    },
    getOutputLength: function IndexedCS_getOutputLength(inputLength, alpha01) {
      return this.base.getOutputLength(inputLength * this.base.numComps, alpha01);
    },
    isPassthrough: ColorSpace.prototype.isPassthrough,
    fillRgb: ColorSpace.prototype.fillRgb,
    isDefaultDecode: function IndexedCS_isDefaultDecode(decodeMap) {
      return true;
    },
    usesZeroToOneRange: true
  };
  return IndexedCS;
}();
var DeviceGrayCS = function DeviceGrayCSClosure() {
  function DeviceGrayCS() {
    this.name = 'DeviceGray';
    this.numComps = 1;
    this.defaultColor = new Float32Array(this.numComps);
  }
  DeviceGrayCS.prototype = {
    getRgb: ColorSpace.prototype.getRgb,
    getRgbItem: function DeviceGrayCS_getRgbItem(src, srcOffset, dest, destOffset) {
      var c = src[srcOffset] * 255 | 0;
      c = c < 0 ? 0 : c > 255 ? 255 : c;
      dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c;
    },
    getRgbBuffer: function DeviceGrayCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      var scale = 255 / ((1 << bits) - 1);
      var j = srcOffset,
          q = destOffset;
      for (var i = 0; i < count; ++i) {
        var c = scale * src[j++] | 0;
        dest[q++] = c;
        dest[q++] = c;
        dest[q++] = c;
        q += alpha01;
      }
    },
    getOutputLength: function DeviceGrayCS_getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01);
    },
    isPassthrough: ColorSpace.prototype.isPassthrough,
    fillRgb: ColorSpace.prototype.fillRgb,
    isDefaultDecode: function DeviceGrayCS_isDefaultDecode(decodeMap) {
      return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
    },
    usesZeroToOneRange: true
  };
  return DeviceGrayCS;
}();
var DeviceRgbCS = function DeviceRgbCSClosure() {
  function DeviceRgbCS() {
    this.name = 'DeviceRGB';
    this.numComps = 3;
    this.defaultColor = new Float32Array(this.numComps);
  }
  DeviceRgbCS.prototype = {
    getRgb: ColorSpace.prototype.getRgb,
    getRgbItem: function DeviceRgbCS_getRgbItem(src, srcOffset, dest, destOffset) {
      var r = src[srcOffset] * 255 | 0;
      var g = src[srcOffset + 1] * 255 | 0;
      var b = src[srcOffset + 2] * 255 | 0;
      dest[destOffset] = r < 0 ? 0 : r > 255 ? 255 : r;
      dest[destOffset + 1] = g < 0 ? 0 : g > 255 ? 255 : g;
      dest[destOffset + 2] = b < 0 ? 0 : b > 255 ? 255 : b;
    },
    getRgbBuffer: function DeviceRgbCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      if (bits === 8 && alpha01 === 0) {
        dest.set(src.subarray(srcOffset, srcOffset + count * 3), destOffset);
        return;
      }
      var scale = 255 / ((1 << bits) - 1);
      var j = srcOffset,
          q = destOffset;
      for (var i = 0; i < count; ++i) {
        dest[q++] = scale * src[j++] | 0;
        dest[q++] = scale * src[j++] | 0;
        dest[q++] = scale * src[j++] | 0;
        q += alpha01;
      }
    },
    getOutputLength: function DeviceRgbCS_getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01) / 3 | 0;
    },
    isPassthrough: function DeviceRgbCS_isPassthrough(bits) {
      return bits === 8;
    },
    fillRgb: ColorSpace.prototype.fillRgb,
    isDefaultDecode: function DeviceRgbCS_isDefaultDecode(decodeMap) {
      return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
    },
    usesZeroToOneRange: true
  };
  return DeviceRgbCS;
}();
var DeviceCmykCS = function DeviceCmykCSClosure() {
  function convertToRgb(src, srcOffset, srcScale, dest, destOffset) {
    var c = src[srcOffset + 0] * srcScale;
    var m = src[srcOffset + 1] * srcScale;
    var y = src[srcOffset + 2] * srcScale;
    var k = src[srcOffset + 3] * srcScale;
    var r = c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747) + 255 | 0;
    var g = c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) + k * (-20.737325471181034 * k - 187.80453709719578) + 255 | 0;
    var b = c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505) + k * (-22.33816807309886 * k - 180.12613974708367) + 255 | 0;
    dest[destOffset] = r > 255 ? 255 : r < 0 ? 0 : r;
    dest[destOffset + 1] = g > 255 ? 255 : g < 0 ? 0 : g;
    dest[destOffset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;
  }
  function DeviceCmykCS() {
    this.name = 'DeviceCMYK';
    this.numComps = 4;
    this.defaultColor = new Float32Array(this.numComps);
    this.defaultColor[3] = 1;
  }
  DeviceCmykCS.prototype = {
    getRgb: ColorSpace.prototype.getRgb,
    getRgbItem: function DeviceCmykCS_getRgbItem(src, srcOffset, dest, destOffset) {
      convertToRgb(src, srcOffset, 1, dest, destOffset);
    },
    getRgbBuffer: function DeviceCmykCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      var scale = 1 / ((1 << bits) - 1);
      for (var i = 0; i < count; i++) {
        convertToRgb(src, srcOffset, scale, dest, destOffset);
        srcOffset += 4;
        destOffset += 3 + alpha01;
      }
    },
    getOutputLength: function DeviceCmykCS_getOutputLength(inputLength, alpha01) {
      return inputLength / 4 * (3 + alpha01) | 0;
    },
    isPassthrough: ColorSpace.prototype.isPassthrough,
    fillRgb: ColorSpace.prototype.fillRgb,
    isDefaultDecode: function DeviceCmykCS_isDefaultDecode(decodeMap) {
      return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
    },
    usesZeroToOneRange: true
  };
  return DeviceCmykCS;
}();
var CalGrayCS = function CalGrayCSClosure() {
  function CalGrayCS(whitePoint, blackPoint, gamma) {
    this.name = 'CalGray';
    this.numComps = 1;
    this.defaultColor = new Float32Array(this.numComps);
    if (!whitePoint) {
      throw new _util.FormatError('WhitePoint missing - required for color space CalGray');
    }
    blackPoint = blackPoint || [0, 0, 0];
    gamma = gamma || 1;
    this.XW = whitePoint[0];
    this.YW = whitePoint[1];
    this.ZW = whitePoint[2];
    this.XB = blackPoint[0];
    this.YB = blackPoint[1];
    this.ZB = blackPoint[2];
    this.G = gamma;
    if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
      throw new _util.FormatError('Invalid WhitePoint components for ' + this.name + ', no fallback available');
    }
    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
      (0, _util.info)('Invalid BlackPoint for ' + this.name + ', falling back to default');
      this.XB = this.YB = this.ZB = 0;
    }
    if (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) {
      (0, _util.warn)(this.name + ', BlackPoint: XB: ' + this.XB + ', YB: ' + this.YB + ', ZB: ' + this.ZB + ', only default values are supported.');
    }
    if (this.G < 1) {
      (0, _util.info)('Invalid Gamma: ' + this.G + ' for ' + this.name + ', falling back to default');
      this.G = 1;
    }
  }
  function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
    var A = src[srcOffset] * scale;
    var AG = Math.pow(A, cs.G);
    var L = cs.YW * AG;
    var val = Math.max(295.8 * Math.pow(L, 0.333333333333333333) - 40.8, 0) | 0;
    dest[destOffset] = val;
    dest[destOffset + 1] = val;
    dest[destOffset + 2] = val;
  }
  CalGrayCS.prototype = {
    getRgb: ColorSpace.prototype.getRgb,
    getRgbItem: function CalGrayCS_getRgbItem(src, srcOffset, dest, destOffset) {
      convertToRgb(this, src, srcOffset, dest, destOffset, 1);
    },
    getRgbBuffer: function CalGrayCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      var scale = 1 / ((1 << bits) - 1);
      for (var i = 0; i < count; ++i) {
        convertToRgb(this, src, srcOffset, dest, destOffset, scale);
        srcOffset += 1;
        destOffset += 3 + alpha01;
      }
    },
    getOutputLength: function CalGrayCS_getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01);
    },
    isPassthrough: ColorSpace.prototype.isPassthrough,
    fillRgb: ColorSpace.prototype.fillRgb,
    isDefaultDecode: function CalGrayCS_isDefaultDecode(decodeMap) {
      return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
    },
    usesZeroToOneRange: true
  };
  return CalGrayCS;
}();
var CalRGBCS = function CalRGBCSClosure() {
  var BRADFORD_SCALE_MATRIX = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
  var BRADFORD_SCALE_INVERSE_MATRIX = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -0.0085287, 0.0400428, 0.9684867]);
  var SRGB_D65_XYZ_TO_RGB_MATRIX = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.9692660, 1.8760108, 0.0415560, 0.0556434, -0.2040259, 1.0572252]);
  var FLAT_WHITEPOINT_MATRIX = new Float32Array([1, 1, 1]);
  var tempNormalizeMatrix = new Float32Array(3);
  var tempConvertMatrix1 = new Float32Array(3);
  var tempConvertMatrix2 = new Float32Array(3);
  var DECODE_L_CONSTANT = Math.pow((8 + 16) / 116, 3) / 8.0;
  function CalRGBCS(whitePoint, blackPoint, gamma, matrix) {
    this.name = 'CalRGB';
    this.numComps = 3;
    this.defaultColor = new Float32Array(this.numComps);
    if (!whitePoint) {
      throw new _util.FormatError('WhitePoint missing - required for color space CalRGB');
    }
    blackPoint = blackPoint || new Float32Array(3);
    gamma = gamma || new Float32Array([1, 1, 1]);
    matrix = matrix || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    var XW = whitePoint[0];
    var YW = whitePoint[1];
    var ZW = whitePoint[2];
    this.whitePoint = whitePoint;
    var XB = blackPoint[0];
    var YB = blackPoint[1];
    var ZB = blackPoint[2];
    this.blackPoint = blackPoint;
    this.GR = gamma[0];
    this.GG = gamma[1];
    this.GB = gamma[2];
    this.MXA = matrix[0];
    this.MYA = matrix[1];
    this.MZA = matrix[2];
    this.MXB = matrix[3];
    this.MYB = matrix[4];
    this.MZB = matrix[5];
    this.MXC = matrix[6];
    this.MYC = matrix[7];
    this.MZC = matrix[8];
    if (XW < 0 || ZW < 0 || YW !== 1) {
      throw new _util.FormatError('Invalid WhitePoint components for ' + this.name + ', no fallback available');
    }
    if (XB < 0 || YB < 0 || ZB < 0) {
      (0, _util.info)('Invalid BlackPoint for ' + this.name + ' [' + XB + ', ' + YB + ', ' + ZB + '], falling back to default');
      this.blackPoint = new Float32Array(3);
    }
    if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
      (0, _util.info)('Invalid Gamma [' + this.GR + ', ' + this.GG + ', ' + this.GB + '] for ' + this.name + ', falling back to default');
      this.GR = this.GG = this.GB = 1;
    }
    if (this.MXA < 0 || this.MYA < 0 || this.MZA < 0 || this.MXB < 0 || this.MYB < 0 || this.MZB < 0 || this.MXC < 0 || this.MYC < 0 || this.MZC < 0) {
      (0, _util.info)('Invalid Matrix for ' + this.name + ' [' + this.MXA + ', ' + this.MYA + ', ' + this.MZA + this.MXB + ', ' + this.MYB + ', ' + this.MZB + this.MXC + ', ' + this.MYC + ', ' + this.MZC + '], falling back to default');
      this.MXA = this.MYB = this.MZC = 1;
      this.MXB = this.MYA = this.MZA = this.MXC = this.MYC = this.MZB = 0;
    }
  }
  function matrixProduct(a, b, result) {
    result[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    result[1] = a[3] * b[0] + a[4] * b[1] + a[5] * b[2];
    result[2] = a[6] * b[0] + a[7] * b[1] + a[8] * b[2];
  }
  function convertToFlat(sourceWhitePoint, LMS, result) {
    result[0] = LMS[0] * 1 / sourceWhitePoint[0];
    result[1] = LMS[1] * 1 / sourceWhitePoint[1];
    result[2] = LMS[2] * 1 / sourceWhitePoint[2];
  }
  function convertToD65(sourceWhitePoint, LMS, result) {
    var D65X = 0.95047;
    var D65Y = 1;
    var D65Z = 1.08883;
    result[0] = LMS[0] * D65X / sourceWhitePoint[0];
    result[1] = LMS[1] * D65Y / sourceWhitePoint[1];
    result[2] = LMS[2] * D65Z / sourceWhitePoint[2];
  }
  function sRGBTransferFunction(color) {
    if (color <= 0.0031308) {
      return adjustToRange(0, 1, 12.92 * color);
    }
    return adjustToRange(0, 1, (1 + 0.055) * Math.pow(color, 1 / 2.4) - 0.055);
  }
  function adjustToRange(min, max, value) {
    return Math.max(min, Math.min(max, value));
  }
  function decodeL(L) {
    if (L < 0) {
      return -decodeL(-L);
    }
    if (L > 8.0) {
      return Math.pow((L + 16) / 116, 3);
    }
    return L * DECODE_L_CONSTANT;
  }
  function compensateBlackPoint(sourceBlackPoint, XYZ_Flat, result) {
    if (sourceBlackPoint[0] === 0 && sourceBlackPoint[1] === 0 && sourceBlackPoint[2] === 0) {
      result[0] = XYZ_Flat[0];
      result[1] = XYZ_Flat[1];
      result[2] = XYZ_Flat[2];
      return;
    }
    var zeroDecodeL = decodeL(0);
    var X_DST = zeroDecodeL;
    var X_SRC = decodeL(sourceBlackPoint[0]);
    var Y_DST = zeroDecodeL;
    var Y_SRC = decodeL(sourceBlackPoint[1]);
    var Z_DST = zeroDecodeL;
    var Z_SRC = decodeL(sourceBlackPoint[2]);
    var X_Scale = (1 - X_DST) / (1 - X_SRC);
    var X_Offset = 1 - X_Scale;
    var Y_Scale = (1 - Y_DST) / (1 - Y_SRC);
    var Y_Offset = 1 - Y_Scale;
    var Z_Scale = (1 - Z_DST) / (1 - Z_SRC);
    var Z_Offset = 1 - Z_Scale;
    result[0] = XYZ_Flat[0] * X_Scale + X_Offset;
    result[1] = XYZ_Flat[1] * Y_Scale + Y_Offset;
    result[2] = XYZ_Flat[2] * Z_Scale + Z_Offset;
  }
  function normalizeWhitePointToFlat(sourceWhitePoint, XYZ_In, result) {
    if (sourceWhitePoint[0] === 1 && sourceWhitePoint[2] === 1) {
      result[0] = XYZ_In[0];
      result[1] = XYZ_In[1];
      result[2] = XYZ_In[2];
      return;
    }
    var LMS = result;
    matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
    var LMS_Flat = tempNormalizeMatrix;
    convertToFlat(sourceWhitePoint, LMS, LMS_Flat);
    matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_Flat, result);
  }
  function normalizeWhitePointToD65(sourceWhitePoint, XYZ_In, result) {
    var LMS = result;
    matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
    var LMS_D65 = tempNormalizeMatrix;
    convertToD65(sourceWhitePoint, LMS, LMS_D65);
    matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_D65, result);
  }
  function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
    var A = adjustToRange(0, 1, src[srcOffset] * scale);
    var B = adjustToRange(0, 1, src[srcOffset + 1] * scale);
    var C = adjustToRange(0, 1, src[srcOffset + 2] * scale);
    var AGR = Math.pow(A, cs.GR);
    var BGG = Math.pow(B, cs.GG);
    var CGB = Math.pow(C, cs.GB);
    var X = cs.MXA * AGR + cs.MXB * BGG + cs.MXC * CGB;
    var Y = cs.MYA * AGR + cs.MYB * BGG + cs.MYC * CGB;
    var Z = cs.MZA * AGR + cs.MZB * BGG + cs.MZC * CGB;
    var XYZ = tempConvertMatrix1;
    XYZ[0] = X;
    XYZ[1] = Y;
    XYZ[2] = Z;
    var XYZ_Flat = tempConvertMatrix2;
    normalizeWhitePointToFlat(cs.whitePoint, XYZ, XYZ_Flat);
    var XYZ_Black = tempConvertMatrix1;
    compensateBlackPoint(cs.blackPoint, XYZ_Flat, XYZ_Black);
    var XYZ_D65 = tempConvertMatrix2;
    normalizeWhitePointToD65(FLAT_WHITEPOINT_MATRIX, XYZ_Black, XYZ_D65);
    var SRGB = tempConvertMatrix1;
    matrixProduct(SRGB_D65_XYZ_TO_RGB_MATRIX, XYZ_D65, SRGB);
    var sR = sRGBTransferFunction(SRGB[0]);
    var sG = sRGBTransferFunction(SRGB[1]);
    var sB = sRGBTransferFunction(SRGB[2]);
    dest[destOffset] = Math.round(sR * 255);
    dest[destOffset + 1] = Math.round(sG * 255);
    dest[destOffset + 2] = Math.round(sB * 255);
  }
  CalRGBCS.prototype = {
    getRgb: ColorSpace.prototype.getRgb,
    getRgbItem: function CalRGBCS_getRgbItem(src, srcOffset, dest, destOffset) {
      convertToRgb(this, src, srcOffset, dest, destOffset, 1);
    },
    getRgbBuffer: function CalRGBCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      var scale = 1 / ((1 << bits) - 1);
      for (var i = 0; i < count; ++i) {
        convertToRgb(this, src, srcOffset, dest, destOffset, scale);
        srcOffset += 3;
        destOffset += 3 + alpha01;
      }
    },
    getOutputLength: function CalRGBCS_getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01) / 3 | 0;
    },
    isPassthrough: ColorSpace.prototype.isPassthrough,
    fillRgb: ColorSpace.prototype.fillRgb,
    isDefaultDecode: function CalRGBCS_isDefaultDecode(decodeMap) {
      return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
    },
    usesZeroToOneRange: true
  };
  return CalRGBCS;
}();
var LabCS = function LabCSClosure() {
  function LabCS(whitePoint, blackPoint, range) {
    this.name = 'Lab';
    this.numComps = 3;
    this.defaultColor = new Float32Array(this.numComps);
    if (!whitePoint) {
      throw new _util.FormatError('WhitePoint missing - required for color space Lab');
    }
    blackPoint = blackPoint || [0, 0, 0];
    range = range || [-100, 100, -100, 100];
    this.XW = whitePoint[0];
    this.YW = whitePoint[1];
    this.ZW = whitePoint[2];
    this.amin = range[0];
    this.amax = range[1];
    this.bmin = range[2];
    this.bmax = range[3];
    this.XB = blackPoint[0];
    this.YB = blackPoint[1];
    this.ZB = blackPoint[2];
    if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
      throw new _util.FormatError('Invalid WhitePoint components, no fallback available');
    }
    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
      (0, _util.info)('Invalid BlackPoint, falling back to default');
      this.XB = this.YB = this.ZB = 0;
    }
    if (this.amin > this.amax || this.bmin > this.bmax) {
      (0, _util.info)('Invalid Range, falling back to defaults');
      this.amin = -100;
      this.amax = 100;
      this.bmin = -100;
      this.bmax = 100;
    }
  }
  function fn_g(x) {
    var result;
    if (x >= 6 / 29) {
      result = x * x * x;
    } else {
      result = 108 / 841 * (x - 4 / 29);
    }
    return result;
  }
  function decode(value, high1, low2, high2) {
    return low2 + value * (high2 - low2) / high1;
  }
  function convertToRgb(cs, src, srcOffset, maxVal, dest, destOffset) {
    var Ls = src[srcOffset];
    var as = src[srcOffset + 1];
    var bs = src[srcOffset + 2];
    if (maxVal !== false) {
      Ls = decode(Ls, maxVal, 0, 100);
      as = decode(as, maxVal, cs.amin, cs.amax);
      bs = decode(bs, maxVal, cs.bmin, cs.bmax);
    }
    as = as > cs.amax ? cs.amax : as < cs.amin ? cs.amin : as;
    bs = bs > cs.bmax ? cs.bmax : bs < cs.bmin ? cs.bmin : bs;
    var M = (Ls + 16) / 116;
    var L = M + as / 500;
    var N = M - bs / 200;
    var X = cs.XW * fn_g(L);
    var Y = cs.YW * fn_g(M);
    var Z = cs.ZW * fn_g(N);
    var r, g, b;
    if (cs.ZW < 1) {
      r = X * 3.1339 + Y * -1.6170 + Z * -0.4906;
      g = X * -0.9785 + Y * 1.9160 + Z * 0.0333;
      b = X * 0.0720 + Y * -0.2290 + Z * 1.4057;
    } else {
      r = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
      g = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
      b = X * 0.0557 + Y * -0.2040 + Z * 1.0570;
    }
    dest[destOffset] = r <= 0 ? 0 : r >= 1 ? 255 : Math.sqrt(r) * 255 | 0;
    dest[destOffset + 1] = g <= 0 ? 0 : g >= 1 ? 255 : Math.sqrt(g) * 255 | 0;
    dest[destOffset + 2] = b <= 0 ? 0 : b >= 1 ? 255 : Math.sqrt(b) * 255 | 0;
  }
  LabCS.prototype = {
    getRgb: ColorSpace.prototype.getRgb,
    getRgbItem: function LabCS_getRgbItem(src, srcOffset, dest, destOffset) {
      convertToRgb(this, src, srcOffset, false, dest, destOffset);
    },
    getRgbBuffer: function LabCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
      var maxVal = (1 << bits) - 1;
      for (var i = 0; i < count; i++) {
        convertToRgb(this, src, srcOffset, maxVal, dest, destOffset);
        srcOffset += 3;
        destOffset += 3 + alpha01;
      }
    },
    getOutputLength: function LabCS_getOutputLength(inputLength, alpha01) {
      return inputLength * (3 + alpha01) / 3 | 0;
    },
    isPassthrough: ColorSpace.prototype.isPassthrough,
    fillRgb: ColorSpace.prototype.fillRgb,
    isDefaultDecode: function LabCS_isDefaultDecode(decodeMap) {
      return true;
    },
    usesZeroToOneRange: false
  };
  return LabCS;
}();
exports.ColorSpace = ColorSpace;

/***/ }),
/* 28 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var ExpertEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior', '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '', '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];
var MacExpertEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', 'centoldstyle', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', '', 'threequartersemdash', '', 'questionsmall', '', '', '', '', 'Ethsmall', '', '', 'onequarter', 'onehalf', 'threequarters', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '', '', '', '', '', '', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hypheninferior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', 'asuperior', 'centsuperior', '', '', '', '', 'Aacutesmall', 'Agravesmall', 'Acircumflexsmall', 'Adieresissmall', 'Atildesmall', 'Aringsmall', 'Ccedillasmall', 'Eacutesmall', 'Egravesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Iacutesmall', 'Igravesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ntildesmall', 'Oacutesmall', 'Ogravesmall', 'Ocircumflexsmall', 'Odieresissmall', 'Otildesmall', 'Uacutesmall', 'Ugravesmall', 'Ucircumflexsmall', 'Udieresissmall', '', 'eightsuperior', 'fourinferior', 'threeinferior', 'sixinferior', 'eightinferior', 'seveninferior', 'Scaronsmall', '', 'centinferior', 'twoinferior', '', 'Dieresissmall', '', 'Caronsmall', 'osuperior', 'fiveinferior', '', 'commainferior', 'periodinferior', 'Yacutesmall', '', 'dollarinferior', '', 'Thornsmall', '', 'nineinferior', 'zeroinferior', 'Zcaronsmall', 'AEsmall', 'Oslashsmall', 'questiondownsmall', 'oneinferior', 'Lslashsmall', '', '', '', '', '', '', 'Cedillasmall', '', '', '', '', '', 'OEsmall', 'figuredash', 'hyphensuperior', '', '', '', '', 'exclamdownsmall', '', 'Ydieresissmall', '', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'ninesuperior', 'zerosuperior', '', 'esuperior', 'rsuperior', 'tsuperior', '', '', 'isuperior', 'ssuperior', 'dsuperior', '', '', '', '', '', 'lsuperior', 'Ogoneksmall', 'Brevesmall', 'Macronsmall', 'bsuperior', 'nsuperior', 'msuperior', 'commasuperior', 'periodsuperior', 'Dotaccentsmall', 'Ringsmall'];
var MacRomanEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', 'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave', 'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis', 'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis', 'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section', 'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal', 'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation', 'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown', 'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright', 'ellipsis', 'space', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft', 'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction', 'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase', 'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex', 'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron'];
var StandardEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger', 'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron', 'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '', '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '', 'lslash', 'oslash', 'oe', 'germandbls'];
var WinAnsiEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'bullet', 'Euro', 'bullet', 'quotesinglbase', 'florin', 'quotedblbase', 'ellipsis', 'dagger', 'daggerdbl', 'circumflex', 'perthousand', 'Scaron', 'guilsinglleft', 'OE', 'bullet', 'Zcaron', 'bullet', 'bullet', 'quoteleft', 'quoteright', 'quotedblleft', 'quotedblright', 'bullet', 'endash', 'emdash', 'tilde', 'trademark', 'scaron', 'guilsinglright', 'oe', 'bullet', 'zcaron', 'Ydieresis', 'space', 'exclamdown', 'cent', 'sterling', 'currency', 'yen', 'brokenbar', 'section', 'dieresis', 'copyright', 'ordfeminine', 'guillemotleft', 'logicalnot', 'hyphen', 'registered', 'macron', 'degree', 'plusminus', 'twosuperior', 'threesuperior', 'acute', 'mu', 'paragraph', 'periodcentered', 'cedilla', 'onesuperior', 'ordmasculine', 'guillemotright', 'onequarter', 'onehalf', 'threequarters', 'questiondown', 'Agrave', 'Aacute', 'Acircumflex', 'Atilde', 'Adieresis', 'Aring', 'AE', 'Ccedilla', 'Egrave', 'Eacute', 'Ecircumflex', 'Edieresis', 'Igrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Eth', 'Ntilde', 'Ograve', 'Oacute', 'Ocircumflex', 'Otilde', 'Odieresis', 'multiply', 'Oslash', 'Ugrave', 'Uacute', 'Ucircumflex', 'Udieresis', 'Yacute', 'Thorn', 'germandbls', 'agrave', 'aacute', 'acircumflex', 'atilde', 'adieresis', 'aring', 'ae', 'ccedilla', 'egrave', 'eacute', 'ecircumflex', 'edieresis', 'igrave', 'iacute', 'icircumflex', 'idieresis', 'eth', 'ntilde', 'ograve', 'oacute', 'ocircumflex', 'otilde', 'odieresis', 'divide', 'oslash', 'ugrave', 'uacute', 'ucircumflex', 'udieresis', 'yacute', 'thorn', 'ydieresis'];
var SymbolSetEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'universal', 'numbersign', 'existential', 'percent', 'ampersand', 'suchthat', 'parenleft', 'parenright', 'asteriskmath', 'plus', 'comma', 'minus', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'congruent', 'Alpha', 'Beta', 'Chi', 'Delta', 'Epsilon', 'Phi', 'Gamma', 'Eta', 'Iota', 'theta1', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Omicron', 'Pi', 'Theta', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'sigma1', 'Omega', 'Xi', 'Psi', 'Zeta', 'bracketleft', 'therefore', 'bracketright', 'perpendicular', 'underscore', 'radicalex', 'alpha', 'beta', 'chi', 'delta', 'epsilon', 'phi', 'gamma', 'eta', 'iota', 'phi1', 'kappa', 'lambda', 'mu', 'nu', 'omicron', 'pi', 'theta', 'rho', 'sigma', 'tau', 'upsilon', 'omega1', 'omega', 'xi', 'psi', 'zeta', 'braceleft', 'bar', 'braceright', 'similar', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'Euro', 'Upsilon1', 'minute', 'lessequal', 'fraction', 'infinity', 'florin', 'club', 'diamond', 'heart', 'spade', 'arrowboth', 'arrowleft', 'arrowup', 'arrowright', 'arrowdown', 'degree', 'plusminus', 'second', 'greaterequal', 'multiply', 'proportional', 'partialdiff', 'bullet', 'divide', 'notequal', 'equivalence', 'approxequal', 'ellipsis', 'arrowvertex', 'arrowhorizex', 'carriagereturn', 'aleph', 'Ifraktur', 'Rfraktur', 'weierstrass', 'circlemultiply', 'circleplus', 'emptyset', 'intersection', 'union', 'propersuperset', 'reflexsuperset', 'notsubset', 'propersubset', 'reflexsubset', 'element', 'notelement', 'angle', 'gradient', 'registerserif', 'copyrightserif', 'trademarkserif', 'product', 'radical', 'dotmath', 'logicalnot', 'logicaland', 'logicalor', 'arrowdblboth', 'arrowdblleft', 'arrowdblup', 'arrowdblright', 'arrowdbldown', 'lozenge', 'angleleft', 'registersans', 'copyrightsans', 'trademarksans', 'summation', 'parenlefttp', 'parenleftex', 'parenleftbt', 'bracketlefttp', 'bracketleftex', 'bracketleftbt', 'bracelefttp', 'braceleftmid', 'braceleftbt', 'braceex', '', 'angleright', 'integral', 'integraltp', 'integralex', 'integralbt', 'parenrighttp', 'parenrightex', 'parenrightbt', 'bracketrighttp', 'bracketrightex', 'bracketrightbt', 'bracerighttp', 'bracerightmid', 'bracerightbt'];
var ZapfDingbatsEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'a1', 'a2', 'a202', 'a3', 'a4', 'a5', 'a119', 'a118', 'a117', 'a11', 'a12', 'a13', 'a14', 'a15', 'a16', 'a105', 'a17', 'a18', 'a19', 'a20', 'a21', 'a22', 'a23', 'a24', 'a25', 'a26', 'a27', 'a28', 'a6', 'a7', 'a8', 'a9', 'a10', 'a29', 'a30', 'a31', 'a32', 'a33', 'a34', 'a35', 'a36', 'a37', 'a38', 'a39', 'a40', 'a41', 'a42', 'a43', 'a44', 'a45', 'a46', 'a47', 'a48', 'a49', 'a50', 'a51', 'a52', 'a53', 'a54', 'a55', 'a56', 'a57', 'a58', 'a59', 'a60', 'a61', 'a62', 'a63', 'a64', 'a65', 'a66', 'a67', 'a68', 'a69', 'a70', 'a71', 'a72', 'a73', 'a74', 'a203', 'a75', 'a204', 'a76', 'a77', 'a78', 'a79', 'a81', 'a82', 'a83', 'a84', 'a97', 'a98', 'a99', 'a100', '', 'a89', 'a90', 'a93', 'a94', 'a91', 'a92', 'a205', 'a85', 'a206', 'a86', 'a87', 'a88', 'a95', 'a96', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'a101', 'a102', 'a103', 'a104', 'a106', 'a107', 'a108', 'a112', 'a111', 'a110', 'a109', 'a120', 'a121', 'a122', 'a123', 'a124', 'a125', 'a126', 'a127', 'a128', 'a129', 'a130', 'a131', 'a132', 'a133', 'a134', 'a135', 'a136', 'a137', 'a138', 'a139', 'a140', 'a141', 'a142', 'a143', 'a144', 'a145', 'a146', 'a147', 'a148', 'a149', 'a150', 'a151', 'a152', 'a153', 'a154', 'a155', 'a156', 'a157', 'a158', 'a159', 'a160', 'a161', 'a163', 'a164', 'a196', 'a165', 'a192', 'a166', 'a167', 'a168', 'a169', 'a170', 'a171', 'a172', 'a173', 'a162', 'a174', 'a175', 'a176', 'a177', 'a178', 'a179', 'a193', 'a180', 'a199', 'a181', 'a200', 'a182', '', 'a201', 'a183', 'a184', 'a197', 'a185', 'a194', 'a198', 'a186', 'a195', 'a187', 'a188', 'a189', 'a190', 'a191'];
function getEncoding(encodingName) {
  switch (encodingName) {
    case 'WinAnsiEncoding':
      return WinAnsiEncoding;
    case 'StandardEncoding':
      return StandardEncoding;
    case 'MacRomanEncoding':
      return MacRomanEncoding;
    case 'SymbolSetEncoding':
      return SymbolSetEncoding;
    case 'ZapfDingbatsEncoding':
      return ZapfDingbatsEncoding;
    case 'ExpertEncoding':
      return ExpertEncoding;
    case 'MacExpertEncoding':
      return MacExpertEncoding;
    default:
      return null;
  }
}
exports.WinAnsiEncoding = WinAnsiEncoding;
exports.StandardEncoding = StandardEncoding;
exports.MacRomanEncoding = MacRomanEncoding;
exports.SymbolSetEncoding = SymbolSetEncoding;
exports.ZapfDingbatsEncoding = ZapfDingbatsEncoding;
exports.ExpertEncoding = ExpertEncoding;
exports.getEncoding = getEncoding;

/***/ }),
/* 29 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var IObject = __w_pdfjs_require__(37);
var defined = __w_pdfjs_require__(38);
module.exports = function (it) {
  return IObject(defined(it));
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var toInteger = __w_pdfjs_require__(18);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var cof = __w_pdfjs_require__(25);
var TAG = __w_pdfjs_require__(4)('toStringTag');
var ARG = cof(function () {
  return arguments;
}()) == 'Arguments';
var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (e) {}
};
module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var ctx = __w_pdfjs_require__(13);
var call = __w_pdfjs_require__(107);
var isArrayIter = __w_pdfjs_require__(56);
var anObject = __w_pdfjs_require__(9);
var toLength = __w_pdfjs_require__(14);
var getIterFn = __w_pdfjs_require__(60);
var BREAK = {};
var RETURN = {};
var _exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () {
    return iterable;
  } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
_exports.BREAK = BREAK;
_exports.RETURN = RETURN;

/***/ }),
/* 34 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Parser = exports.Linearization = exports.Lexer = undefined;

var _stream = __w_pdfjs_require__(5);

var _util = __w_pdfjs_require__(0);

var _primitives = __w_pdfjs_require__(2);

var _ccitt_stream = __w_pdfjs_require__(130);

var _jbig2_stream = __w_pdfjs_require__(132);

var MAX_LENGTH_TO_CACHE = 1000;
var Parser = function ParserClosure() {
  function Parser(lexer, allowStreams, xref, recoveryMode) {
    this.lexer = lexer;
    this.allowStreams = allowStreams;
    this.xref = xref;
    this.recoveryMode = recoveryMode || false;
    this.imageCache = Object.create(null);
    this.refill();
  }
  Parser.prototype = {
    refill: function Parser_refill() {
      this.buf1 = this.lexer.getObj();
      this.buf2 = this.lexer.getObj();
    },
    shift: function Parser_shift() {
      if ((0, _primitives.isCmd)(this.buf2, 'ID')) {
        this.buf1 = this.buf2;
        this.buf2 = null;
      } else {
        this.buf1 = this.buf2;
        this.buf2 = this.lexer.getObj();
      }
    },
    tryShift: function Parser_tryShift() {
      try {
        this.shift();
        return true;
      } catch (e) {
        if (e instanceof _util.MissingDataException) {
          throw e;
        }
        return false;
      }
    },
    getObj: function Parser_getObj(cipherTransform) {
      var buf1 = this.buf1;
      this.shift();
      if (buf1 instanceof _primitives.Cmd) {
        switch (buf1.cmd) {
          case 'BI':
            return this.makeInlineImage(cipherTransform);
          case '[':
            var array = [];
            while (!(0, _primitives.isCmd)(this.buf1, ']') && !(0, _primitives.isEOF)(this.buf1)) {
              array.push(this.getObj(cipherTransform));
            }
            if ((0, _primitives.isEOF)(this.buf1)) {
              if (!this.recoveryMode) {
                throw new _util.FormatError('End of file inside array');
              }
              return array;
            }
            this.shift();
            return array;
          case '<<':
            var dict = new _primitives.Dict(this.xref);
            while (!(0, _primitives.isCmd)(this.buf1, '>>') && !(0, _primitives.isEOF)(this.buf1)) {
              if (!(0, _primitives.isName)(this.buf1)) {
                (0, _util.info)('Malformed dictionary: key must be a name object');
                this.shift();
                continue;
              }
              var key = this.buf1.name;
              this.shift();
              if ((0, _primitives.isEOF)(this.buf1)) {
                break;
              }
              dict.set(key, this.getObj(cipherTransform));
            }
            if ((0, _primitives.isEOF)(this.buf1)) {
              if (!this.recoveryMode) {
                throw new _util.FormatError('End of file inside dictionary');
              }
              return dict;
            }
            if ((0, _primitives.isCmd)(this.buf2, 'stream')) {
              return this.allowStreams ? this.makeStream(dict, cipherTransform) : dict;
            }
            this.shift();
            return dict;
          default:
            return buf1;
        }
      }
      if (Number.isInteger(buf1)) {
        var num = buf1;
        if (Number.isInteger(this.buf1) && (0, _primitives.isCmd)(this.buf2, 'R')) {
          var ref = new _primitives.Ref(num, this.buf1);
          this.shift();
          this.shift();
          return ref;
        }
        return num;
      }
      if ((0, _util.isString)(buf1)) {
        var str = buf1;
        if (cipherTransform) {
          str = cipherTransform.decryptString(str);
        }
        return str;
      }
      return buf1;
    },
    findDefaultInlineStreamEnd: function findDefaultInlineStreamEnd(stream) {
      var E = 0x45,
          I = 0x49,
          SPACE = 0x20,
          LF = 0xA,
          CR = 0xD;
      var n = 10,
          NUL = 0x0;
      var startPos = stream.pos,
          state = 0,
          ch = void 0,
          maybeEIPos = void 0;
      while ((ch = stream.getByte()) !== -1) {
        if (state === 0) {
          state = ch === E ? 1 : 0;
        } else if (state === 1) {
          state = ch === I ? 2 : 0;
        } else {
          (0, _util.assert)(state === 2);
          if (ch === SPACE || ch === LF || ch === CR) {
            maybeEIPos = stream.pos;
            var followingBytes = stream.peekBytes(n);
            for (var i = 0, ii = followingBytes.length; i < ii; i++) {
              ch = followingBytes[i];
              if (ch === NUL && followingBytes[i + 1] !== NUL) {
                continue;
              }
              if (ch !== LF && ch !== CR && (ch < SPACE || ch > 0x7F)) {
                state = 0;
                break;
              }
            }
            if (state === 2) {
              break;
            }
          } else {
            state = 0;
          }
        }
      }
      if (ch === -1) {
        (0, _util.warn)('findDefaultInlineStreamEnd: ' + 'Reached the end of the stream without finding a valid EI marker');
        if (maybeEIPos) {
          (0, _util.warn)('... trying to recover by using the last "EI" occurrence.');
          stream.skip(-(stream.pos - maybeEIPos));
        }
      }
      return stream.pos - 4 - startPos;
    },

    findDCTDecodeInlineStreamEnd: function Parser_findDCTDecodeInlineStreamEnd(stream) {
      var startPos = stream.pos,
          foundEOI = false,
          b,
          markerLength,
          length;
      while ((b = stream.getByte()) !== -1) {
        if (b !== 0xFF) {
          continue;
        }
        switch (stream.getByte()) {
          case 0x00:
            break;
          case 0xFF:
            stream.skip(-1);
            break;
          case 0xD9:
            foundEOI = true;
            break;
          case 0xC0:
          case 0xC1:
          case 0xC2:
          case 0xC3:
          case 0xC5:
          case 0xC6:
          case 0xC7:
          case 0xC9:
          case 0xCA:
          case 0xCB:
          case 0xCD:
          case 0xCE:
          case 0xCF:
          case 0xC4:
          case 0xCC:
          case 0xDA:
          case 0xDB:
          case 0xDC:
          case 0xDD:
          case 0xDE:
          case 0xDF:
          case 0xE0:
          case 0xE1:
          case 0xE2:
          case 0xE3:
          case 0xE4:
          case 0xE5:
          case 0xE6:
          case 0xE7:
          case 0xE8:
          case 0xE9:
          case 0xEA:
          case 0xEB:
          case 0xEC:
          case 0xED:
          case 0xEE:
          case 0xEF:
          case 0xFE:
            markerLength = stream.getUint16();
            if (markerLength > 2) {
              stream.skip(markerLength - 2);
            } else {
              stream.skip(-2);
            }
            break;
        }
        if (foundEOI) {
          break;
        }
      }
      length = stream.pos - startPos;
      if (b === -1) {
        (0, _util.warn)('Inline DCTDecode image stream: ' + 'EOI marker not found, searching for /EI/ instead.');
        stream.skip(-length);
        return this.findDefaultInlineStreamEnd(stream);
      }
      this.inlineStreamSkipEI(stream);
      return length;
    },
    findASCII85DecodeInlineStreamEnd: function Parser_findASCII85DecodeInlineStreamEnd(stream) {
      var TILDE = 0x7E,
          GT = 0x3E;
      var startPos = stream.pos,
          ch,
          length;
      while ((ch = stream.getByte()) !== -1) {
        if (ch === TILDE && stream.peekByte() === GT) {
          stream.skip();
          break;
        }
      }
      length = stream.pos - startPos;
      if (ch === -1) {
        (0, _util.warn)('Inline ASCII85Decode image stream: ' + 'EOD marker not found, searching for /EI/ instead.');
        stream.skip(-length);
        return this.findDefaultInlineStreamEnd(stream);
      }
      this.inlineStreamSkipEI(stream);
      return length;
    },
    findASCIIHexDecodeInlineStreamEnd: function Parser_findASCIIHexDecodeInlineStreamEnd(stream) {
      var GT = 0x3E;
      var startPos = stream.pos,
          ch,
          length;
      while ((ch = stream.getByte()) !== -1) {
        if (ch === GT) {
          break;
        }
      }
      length = stream.pos - startPos;
      if (ch === -1) {
        (0, _util.warn)('Inline ASCIIHexDecode image stream: ' + 'EOD marker not found, searching for /EI/ instead.');
        stream.skip(-length);
        return this.findDefaultInlineStreamEnd(stream);
      }
      this.inlineStreamSkipEI(stream);
      return length;
    },
    inlineStreamSkipEI: function Parser_inlineStreamSkipEI(stream) {
      var E = 0x45,
          I = 0x49;
      var state = 0,
          ch;
      while ((ch = stream.getByte()) !== -1) {
        if (state === 0) {
          state = ch === E ? 1 : 0;
        } else if (state === 1) {
          state = ch === I ? 2 : 0;
        } else if (state === 2) {
          break;
        }
      }
    },
    makeInlineImage: function Parser_makeInlineImage(cipherTransform) {
      var lexer = this.lexer;
      var stream = lexer.stream;
      var dict = new _primitives.Dict(this.xref);
      while (!(0, _primitives.isCmd)(this.buf1, 'ID') && !(0, _primitives.isEOF)(this.buf1)) {
        if (!(0, _primitives.isName)(this.buf1)) {
          throw new _util.FormatError('Dictionary key must be a name object');
        }
        var key = this.buf1.name;
        this.shift();
        if ((0, _primitives.isEOF)(this.buf1)) {
          break;
        }
        dict.set(key, this.getObj(cipherTransform));
      }
      var filter = dict.get('Filter', 'F'),
          filterName;
      if ((0, _primitives.isName)(filter)) {
        filterName = filter.name;
      } else if (Array.isArray(filter)) {
        var filterZero = this.xref.fetchIfRef(filter[0]);
        if ((0, _primitives.isName)(filterZero)) {
          filterName = filterZero.name;
        }
      }
      var startPos = stream.pos,
          length,
          i,
          ii;
      if (filterName === 'DCTDecode' || filterName === 'DCT') {
        length = this.findDCTDecodeInlineStreamEnd(stream);
      } else if (filterName === 'ASCII85Decode' || filterName === 'A85') {
        length = this.findASCII85DecodeInlineStreamEnd(stream);
      } else if (filterName === 'ASCIIHexDecode' || filterName === 'AHx') {
        length = this.findASCIIHexDecodeInlineStreamEnd(stream);
      } else {
        length = this.findDefaultInlineStreamEnd(stream);
      }
      var imageStream = stream.makeSubStream(startPos, length, dict);
      var adler32;
      if (length < MAX_LENGTH_TO_CACHE) {
        var imageBytes = imageStream.getBytes();
        imageStream.reset();
        var a = 1;
        var b = 0;
        for (i = 0, ii = imageBytes.length; i < ii; ++i) {
          a += imageBytes[i] & 0xff;
          b += a;
        }
        adler32 = b % 65521 << 16 | a % 65521;
        var cacheEntry = this.imageCache[adler32];
        if (cacheEntry !== undefined) {
          this.buf2 = _primitives.Cmd.get('EI');
          this.shift();
          cacheEntry.reset();
          return cacheEntry;
        }
      }
      if (cipherTransform) {
        imageStream = cipherTransform.createStream(imageStream, length);
      }
      imageStream = this.filter(imageStream, dict, length);
      imageStream.dict = dict;
      if (adler32 !== undefined) {
        imageStream.cacheKey = 'inline_' + length + '_' + adler32;
        this.imageCache[adler32] = imageStream;
      }
      this.buf2 = _primitives.Cmd.get('EI');
      this.shift();
      return imageStream;
    },
    makeStream: function Parser_makeStream(dict, cipherTransform) {
      var lexer = this.lexer;
      var stream = lexer.stream;
      lexer.skipToNextLine();
      var pos = stream.pos - 1;
      var length = dict.get('Length');
      if (!Number.isInteger(length)) {
        (0, _util.info)('Bad ' + length + ' attribute in stream');
        length = 0;
      }
      stream.pos = pos + length;
      lexer.nextChar();
      if (this.tryShift() && (0, _primitives.isCmd)(this.buf2, 'endstream')) {
        this.shift();
      } else {
        stream.pos = pos;
        var SCAN_BLOCK_SIZE = 2048;
        var ENDSTREAM_SIGNATURE_LENGTH = 9;
        var ENDSTREAM_SIGNATURE = [0x65, 0x6E, 0x64, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D];
        var skipped = 0,
            found = false,
            i,
            j;
        while (stream.pos < stream.end) {
          var scanBytes = stream.peekBytes(SCAN_BLOCK_SIZE);
          var scanLength = scanBytes.length - ENDSTREAM_SIGNATURE_LENGTH;
          if (scanLength <= 0) {
            break;
          }
          found = false;
          i = 0;
          while (i < scanLength) {
            j = 0;
            while (j < ENDSTREAM_SIGNATURE_LENGTH && scanBytes[i + j] === ENDSTREAM_SIGNATURE[j]) {
              j++;
            }
            if (j >= ENDSTREAM_SIGNATURE_LENGTH) {
              found = true;
              break;
            }
            i++;
          }
          if (found) {
            skipped += i;
            stream.pos += i;
            break;
          }
          skipped += scanLength;
          stream.pos += scanLength;
        }
        if (!found) {
          throw new _util.FormatError('Missing endstream');
        }
        length = skipped;
        lexer.nextChar();
        this.shift();
        this.shift();
      }
      this.shift();
      stream = stream.makeSubStream(pos, length, dict);
      if (cipherTransform) {
        stream = cipherTransform.createStream(stream, length);
      }
      stream = this.filter(stream, dict, length);
      stream.dict = dict;
      return stream;
    },
    filter: function Parser_filter(stream, dict, length) {
      var filter = dict.get('Filter', 'F');
      var params = dict.get('DecodeParms', 'DP');
      if ((0, _primitives.isName)(filter)) {
        if (Array.isArray(params)) {
          (0, _util.warn)('/DecodeParms should not contain an Array, ' + 'when /Filter contains a Name.');
        }
        return this.makeFilter(stream, filter.name, length, params);
      }
      var maybeLength = length;
      if (Array.isArray(filter)) {
        var filterArray = filter;
        var paramsArray = params;
        for (var i = 0, ii = filterArray.length; i < ii; ++i) {
          filter = this.xref.fetchIfRef(filterArray[i]);
          if (!(0, _primitives.isName)(filter)) {
            throw new _util.FormatError('Bad filter name: ' + filter);
          }
          params = null;
          if (Array.isArray(paramsArray) && i in paramsArray) {
            params = this.xref.fetchIfRef(paramsArray[i]);
          }
          stream = this.makeFilter(stream, filter.name, maybeLength, params);
          maybeLength = null;
        }
      }
      return stream;
    },
    makeFilter: function Parser_makeFilter(stream, name, maybeLength, params) {
      if (maybeLength === 0) {
        (0, _util.warn)('Empty "' + name + '" stream.');
        return new _stream.NullStream(stream);
      }
      try {
        var xrefStreamStats = this.xref.stats.streamTypes;
        if (name === 'FlateDecode' || name === 'Fl') {
          xrefStreamStats[_util.StreamType.FLATE] = true;
          if (params) {
            return new _stream.PredictorStream(new _stream.FlateStream(stream, maybeLength), maybeLength, params);
          }
          return new _stream.FlateStream(stream, maybeLength);
        }
        if (name === 'LZWDecode' || name === 'LZW') {
          xrefStreamStats[_util.StreamType.LZW] = true;
          var earlyChange = 1;
          if (params) {
            if (params.has('EarlyChange')) {
              earlyChange = params.get('EarlyChange');
            }
            return new _stream.PredictorStream(new _stream.LZWStream(stream, maybeLength, earlyChange), maybeLength, params);
          }
          return new _stream.LZWStream(stream, maybeLength, earlyChange);
        }
        if (name === 'DCTDecode' || name === 'DCT') {
          xrefStreamStats[_util.StreamType.DCT] = true;
          return new _stream.JpegStream(stream, maybeLength, stream.dict, params);
        }
        if (name === 'JPXDecode' || name === 'JPX') {
          xrefStreamStats[_util.StreamType.JPX] = true;
          return new _stream.JpxStream(stream, maybeLength, stream.dict, params);
        }
        if (name === 'ASCII85Decode' || name === 'A85') {
          xrefStreamStats[_util.StreamType.A85] = true;
          return new _stream.Ascii85Stream(stream, maybeLength);
        }
        if (name === 'ASCIIHexDecode' || name === 'AHx') {
          xrefStreamStats[_util.StreamType.AHX] = true;
          return new _stream.AsciiHexStream(stream, maybeLength);
        }
        if (name === 'CCITTFaxDecode' || name === 'CCF') {
          xrefStreamStats[_util.StreamType.CCF] = true;
          return new _ccitt_stream.CCITTFaxStream(stream, maybeLength, params);
        }
        if (name === 'RunLengthDecode' || name === 'RL') {
          xrefStreamStats[_util.StreamType.RL] = true;
          return new _stream.RunLengthStream(stream, maybeLength);
        }
        if (name === 'JBIG2Decode') {
          xrefStreamStats[_util.StreamType.JBIG] = true;
          return new _jbig2_stream.Jbig2Stream(stream, maybeLength, stream.dict, params);
        }
        (0, _util.warn)('filter "' + name + '" not supported yet');
        return stream;
      } catch (ex) {
        if (ex instanceof _util.MissingDataException) {
          throw ex;
        }
        (0, _util.warn)('Invalid stream: \"' + ex + '\"');
        return new _stream.NullStream(stream);
      }
    }
  };
  return Parser;
}();
var Lexer = function LexerClosure() {
  function Lexer(stream, knownCommands) {
    this.stream = stream;
    this.nextChar();
    this.strBuf = [];
    this.knownCommands = knownCommands;
  }
  var specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  function toHexDigit(ch) {
    if (ch >= 0x30 && ch <= 0x39) {
      return ch & 0x0F;
    }
    if (ch >= 0x41 && ch <= 0x46 || ch >= 0x61 && ch <= 0x66) {
      return (ch & 0x0F) + 9;
    }
    return -1;
  }
  Lexer.prototype = {
    nextChar: function Lexer_nextChar() {
      return this.currentChar = this.stream.getByte();
    },
    peekChar: function Lexer_peekChar() {
      return this.stream.peekByte();
    },
    getNumber: function Lexer_getNumber() {
      var ch = this.currentChar;
      var eNotation = false;
      var divideBy = 0;
      var sign = 1;
      if (ch === 0x2D) {
        sign = -1;
        ch = this.nextChar();
        if (ch === 0x2D) {
          ch = this.nextChar();
        }
      } else if (ch === 0x2B) {
        ch = this.nextChar();
      }
      if (ch === 0x2E) {
        divideBy = 10;
        ch = this.nextChar();
      }
      if (ch === 0x0A || ch === 0x0D) {
        do {
          ch = this.nextChar();
        } while (ch === 0x0A || ch === 0x0D);
      }
      if (ch < 0x30 || ch > 0x39) {
        throw new _util.FormatError('Invalid number: ' + String.fromCharCode(ch) + ' (charCode ' + ch + ')');
      }
      var baseValue = ch - 0x30;
      var powerValue = 0;
      var powerValueSign = 1;
      while ((ch = this.nextChar()) >= 0) {
        if (0x30 <= ch && ch <= 0x39) {
          var currentDigit = ch - 0x30;
          if (eNotation) {
            powerValue = powerValue * 10 + currentDigit;
          } else {
            if (divideBy !== 0) {
              divideBy *= 10;
            }
            baseValue = baseValue * 10 + currentDigit;
          }
        } else if (ch === 0x2E) {
          if (divideBy === 0) {
            divideBy = 1;
          } else {
            break;
          }
        } else if (ch === 0x2D) {
          (0, _util.warn)('Badly formatted number');
        } else if (ch === 0x45 || ch === 0x65) {
          ch = this.peekChar();
          if (ch === 0x2B || ch === 0x2D) {
            powerValueSign = ch === 0x2D ? -1 : 1;
            this.nextChar();
          } else if (ch < 0x30 || ch > 0x39) {
            break;
          }
          eNotation = true;
        } else {
          break;
        }
      }
      if (divideBy !== 0) {
        baseValue /= divideBy;
      }
      if (eNotation) {
        baseValue *= Math.pow(10, powerValueSign * powerValue);
      }
      return sign * baseValue;
    },
    getString: function Lexer_getString() {
      var numParen = 1;
      var done = false;
      var strBuf = this.strBuf;
      strBuf.length = 0;
      var ch = this.nextChar();
      while (true) {
        var charBuffered = false;
        switch (ch | 0) {
          case -1:
            (0, _util.warn)('Unterminated string');
            done = true;
            break;
          case 0x28:
            ++numParen;
            strBuf.push('(');
            break;
          case 0x29:
            if (--numParen === 0) {
              this.nextChar();
              done = true;
            } else {
              strBuf.push(')');
            }
            break;
          case 0x5C:
            ch = this.nextChar();
            switch (ch) {
              case -1:
                (0, _util.warn)('Unterminated string');
                done = true;
                break;
              case 0x6E:
                strBuf.push('\n');
                break;
              case 0x72:
                strBuf.push('\r');
                break;
              case 0x74:
                strBuf.push('\t');
                break;
              case 0x62:
                strBuf.push('\b');
                break;
              case 0x66:
                strBuf.push('\f');
                break;
              case 0x5C:
              case 0x28:
              case 0x29:
                strBuf.push(String.fromCharCode(ch));
                break;
              case 0x30:
              case 0x31:
              case 0x32:
              case 0x33:
              case 0x34:
              case 0x35:
              case 0x36:
              case 0x37:
                var x = ch & 0x0F;
                ch = this.nextChar();
                charBuffered = true;
                if (ch >= 0x30 && ch <= 0x37) {
                  x = (x << 3) + (ch & 0x0F);
                  ch = this.nextChar();
                  if (ch >= 0x30 && ch <= 0x37) {
                    charBuffered = false;
                    x = (x << 3) + (ch & 0x0F);
                  }
                }
                strBuf.push(String.fromCharCode(x));
                break;
              case 0x0D:
                if (this.peekChar() === 0x0A) {
                  this.nextChar();
                }
                break;
              case 0x0A:
                break;
              default:
                strBuf.push(String.fromCharCode(ch));
                break;
            }
            break;
          default:
            strBuf.push(String.fromCharCode(ch));
            break;
        }
        if (done) {
          break;
        }
        if (!charBuffered) {
          ch = this.nextChar();
        }
      }
      return strBuf.join('');
    },
    getName: function Lexer_getName() {
      var ch, previousCh;
      var strBuf = this.strBuf;
      strBuf.length = 0;
      while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
        if (ch === 0x23) {
          ch = this.nextChar();
          if (specialChars[ch]) {
            (0, _util.warn)('Lexer_getName: ' + 'NUMBER SIGN (#) should be followed by a hexadecimal number.');
            strBuf.push('#');
            break;
          }
          var x = toHexDigit(ch);
          if (x !== -1) {
            previousCh = ch;
            ch = this.nextChar();
            var x2 = toHexDigit(ch);
            if (x2 === -1) {
              (0, _util.warn)('Lexer_getName: Illegal digit (' + String.fromCharCode(ch) + ') in hexadecimal number.');
              strBuf.push('#', String.fromCharCode(previousCh));
              if (specialChars[ch]) {
                break;
              }
              strBuf.push(String.fromCharCode(ch));
              continue;
            }
            strBuf.push(String.fromCharCode(x << 4 | x2));
          } else {
            strBuf.push('#', String.fromCharCode(ch));
          }
        } else {
          strBuf.push(String.fromCharCode(ch));
        }
      }
      if (strBuf.length > 127) {
        (0, _util.warn)('name token is longer than allowed by the spec: ' + strBuf.length);
      }
      return _primitives.Name.get(strBuf.join(''));
    },
    getHexString: function Lexer_getHexString() {
      var strBuf = this.strBuf;
      strBuf.length = 0;
      var ch = this.currentChar;
      var isFirstHex = true;
      var firstDigit;
      var secondDigit;
      while (true) {
        if (ch < 0) {
          (0, _util.warn)('Unterminated hex string');
          break;
        } else if (ch === 0x3E) {
          this.nextChar();
          break;
        } else if (specialChars[ch] === 1) {
          ch = this.nextChar();
          continue;
        } else {
          if (isFirstHex) {
            firstDigit = toHexDigit(ch);
            if (firstDigit === -1) {
              (0, _util.warn)('Ignoring invalid character "' + ch + '" in hex string');
              ch = this.nextChar();
              continue;
            }
          } else {
            secondDigit = toHexDigit(ch);
            if (secondDigit === -1) {
              (0, _util.warn)('Ignoring invalid character "' + ch + '" in hex string');
              ch = this.nextChar();
              continue;
            }
            strBuf.push(String.fromCharCode(firstDigit << 4 | secondDigit));
          }
          isFirstHex = !isFirstHex;
          ch = this.nextChar();
        }
      }
      return strBuf.join('');
    },
    getObj: function Lexer_getObj() {
      var comment = false;
      var ch = this.currentChar;
      while (true) {
        if (ch < 0) {
          return _primitives.EOF;
        }
        if (comment) {
          if (ch === 0x0A || ch === 0x0D) {
            comment = false;
          }
        } else if (ch === 0x25) {
          comment = true;
        } else if (specialChars[ch] !== 1) {
          break;
        }
        ch = this.nextChar();
      }
      switch (ch | 0) {
        case 0x30:
        case 0x31:
        case 0x32:
        case 0x33:
        case 0x34:
        case 0x35:
        case 0x36:
        case 0x37:
        case 0x38:
        case 0x39:
        case 0x2B:
        case 0x2D:
        case 0x2E:
          return this.getNumber();
        case 0x28:
          return this.getString();
        case 0x2F:
          return this.getName();
        case 0x5B:
          this.nextChar();
          return _primitives.Cmd.get('[');
        case 0x5D:
          this.nextChar();
          return _primitives.Cmd.get(']');
        case 0x3C:
          ch = this.nextChar();
          if (ch === 0x3C) {
            this.nextChar();
            return _primitives.Cmd.get('<<');
          }
          return this.getHexString();
        case 0x3E:
          ch = this.nextChar();
          if (ch === 0x3E) {
            this.nextChar();
            return _primitives.Cmd.get('>>');
          }
          return _primitives.Cmd.get('>');
        case 0x7B:
          this.nextChar();
          return _primitives.Cmd.get('{');
        case 0x7D:
          this.nextChar();
          return _primitives.Cmd.get('}');
        case 0x29:
          this.nextChar();
          throw new _util.FormatError('Illegal character: ' + ch);
      }
      var str = String.fromCharCode(ch);
      var knownCommands = this.knownCommands;
      var knownCommandFound = knownCommands && knownCommands[str] !== undefined;
      while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
        var possibleCommand = str + String.fromCharCode(ch);
        if (knownCommandFound && knownCommands[possibleCommand] === undefined) {
          break;
        }
        if (str.length === 128) {
          throw new _util.FormatError('Command token too long: ' + str.length);
        }
        str = possibleCommand;
        knownCommandFound = knownCommands && knownCommands[str] !== undefined;
      }
      if (str === 'true') {
        return true;
      }
      if (str === 'false') {
        return false;
      }
      if (str === 'null') {
        return null;
      }
      return _primitives.Cmd.get(str);
    },
    skipToNextLine: function Lexer_skipToNextLine() {
      var ch = this.currentChar;
      while (ch >= 0) {
        if (ch === 0x0D) {
          ch = this.nextChar();
          if (ch === 0x0A) {
            this.nextChar();
          }
          break;
        } else if (ch === 0x0A) {
          this.nextChar();
          break;
        }
        ch = this.nextChar();
      }
    }
  };
  return Lexer;
}();
var Linearization = {
  create: function LinearizationCreate(stream) {
    function getInt(name, allowZeroValue) {
      var obj = linDict.get(name);
      if (Number.isInteger(obj) && (allowZeroValue ? obj >= 0 : obj > 0)) {
        return obj;
      }
      throw new Error('The "' + name + '" parameter in the linearization ' + 'dictionary is invalid.');
    }
    function getHints() {
      var hints = linDict.get('H'),
          hintsLength,
          item;
      if (Array.isArray(hints) && ((hintsLength = hints.length) === 2 || hintsLength === 4)) {
        for (var index = 0; index < hintsLength; index++) {
          if (!(Number.isInteger(item = hints[index]) && item > 0)) {
            throw new Error('Hint (' + index + ') in the linearization dictionary is invalid.');
          }
        }
        return hints;
      }
      throw new Error('Hint array in the linearization dictionary is invalid.');
    }
    var parser = new Parser(new Lexer(stream), false, null);
    var obj1 = parser.getObj();
    var obj2 = parser.getObj();
    var obj3 = parser.getObj();
    var linDict = parser.getObj();
    var obj, length;
    if (!(Number.isInteger(obj1) && Number.isInteger(obj2) && (0, _primitives.isCmd)(obj3, 'obj') && (0, _primitives.isDict)(linDict) && (0, _util.isNum)(obj = linDict.get('Linearized')) && obj > 0)) {
      return null;
    } else if ((length = getInt('L')) !== stream.length) {
      throw new Error('The "L" parameter in the linearization dictionary ' + 'does not equal the stream length.');
    }
    return {
      length: length,
      hints: getHints(),
      objectNumberFirst: getInt('O'),
      endFirst: getInt('E'),
      numPages: getInt('N'),
      mainXRefEntriesOffset: getInt('T'),
      pageFirst: linDict.has('P') ? getInt('P', true) : 0
    };
  }
};
exports.Lexer = Lexer;
exports.Linearization = Linearization;
exports.Parser = Parser;

/***/ }),
/* 35 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var isObject = __w_pdfjs_require__(3);
var document = __w_pdfjs_require__(1).document;
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var isObject = __w_pdfjs_require__(3);
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var cof = __w_pdfjs_require__(25);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var shared = __w_pdfjs_require__(54)('keys');
var uid = __w_pdfjs_require__(17);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

/***/ }),
/* 41 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var $keys = __w_pdfjs_require__(52);
var enumBugKeys = __w_pdfjs_require__(40);
module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var ctx = __w_pdfjs_require__(13);
var IObject = __w_pdfjs_require__(37);
var toObject = __w_pdfjs_require__(19);
var toLength = __w_pdfjs_require__(14);
var asc = __w_pdfjs_require__(91);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (; length > index; index++) {
      if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);
        if (TYPE) {
          if (IS_MAP) result[index] = res;else if (res) switch (TYPE) {
            case 3:
              return true;
            case 5:
              return val;
            case 6:
              return index;
            case 2:
              result.push(val);
          } else if (IS_EVERY) return false;
        }
      }
    }return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var anObject = __w_pdfjs_require__(9);
var aFunction = __w_pdfjs_require__(22);
var SPECIES = __w_pdfjs_require__(4)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var ITERATOR = __w_pdfjs_require__(4)('iterator');
var SAFE_CLOSING = false;
try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () {
    SAFE_CLOSING = true;
  };
  Array.from(riter, function () {
    throw 2;
  });
} catch (e) {}
module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () {
      return { done: safe = true };
    };
    arr[ITERATOR] = function () {
      return iter;
    };
    exec(arr);
  } catch (e) {}
  return safe;
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var aFunction = __w_pdfjs_require__(22);
function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}
module.exports.f = function (C) {
  return new PromiseCapability(C);
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __w_pdfjs_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var META = __w_pdfjs_require__(17)('meta');
var isObject = __w_pdfjs_require__(3);
var has = __w_pdfjs_require__(12);
var setDesc = __w_pdfjs_require__(15).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__w_pdfjs_require__(11)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function setMeta(it) {
  setDesc(it, META, {
    value: {
      i: 'O' + ++id,
      w: {}
    }
  });
};
var fastKey = function fastKey(it, create) {
  if (!isObject(it)) return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    if (!isExtensible(it)) return 'F';
    if (!create) return 'E';
    setMeta(it);
  }
  return it[META].i;
};
var getWeak = function getWeak(it, create) {
  if (!has(it, META)) {
    if (!isExtensible(it)) return true;
    if (!create) return false;
    setMeta(it);
  }
  return it[META].w;
};
var onFreeze = function onFreeze(it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __w_pdfjs_require__) {

var getLookupTableFactory = __w_pdfjs_require__(0).getLookupTableFactory;
var getGlyphsUnicode = getLookupTableFactory(function (t) {
 t['A'] = 0x0041;
 t['AE'] = 0x00C6;
 t['AEacute'] = 0x01FC;
 t['AEmacron'] = 0x01E2;
 t['AEsmall'] = 0xF7E6;
 t['Aacute'] = 0x00C1;
 t['Aacutesmall'] = 0xF7E1;
 t['Abreve'] = 0x0102;
 t['Abreveacute'] = 0x1EAE;
 t['Abrevecyrillic'] = 0x04D0;
 t['Abrevedotbelow'] = 0x1EB6;
 t['Abrevegrave'] = 0x1EB0;
 t['Abrevehookabove'] = 0x1EB2;
 t['Abrevetilde'] = 0x1EB4;
 t['Acaron'] = 0x01CD;
 t['Acircle'] = 0x24B6;
 t['Acircumflex'] = 0x00C2;
 t['Acircumflexacute'] = 0x1EA4;
 t['Acircumflexdotbelow'] = 0x1EAC;
 t['Acircumflexgrave'] = 0x1EA6;
 t['Acircumflexhookabove'] = 0x1EA8;
 t['Acircumflexsmall'] = 0xF7E2;
 t['Acircumflextilde'] = 0x1EAA;
 t['Acute'] = 0xF6C9;
 t['Acutesmall'] = 0xF7B4;
 t['Acyrillic'] = 0x0410;
 t['Adblgrave'] = 0x0200;
 t['Adieresis'] = 0x00C4;
 t['Adieresiscyrillic'] = 0x04D2;
 t['Adieresismacron'] = 0x01DE;
 t['Adieresissmall'] = 0xF7E4;
 t['Adotbelow'] = 0x1EA0;
 t['Adotmacron'] = 0x01E0;
 t['Agrave'] = 0x00C0;
 t['Agravesmall'] = 0xF7E0;
 t['Ahookabove'] = 0x1EA2;
 t['Aiecyrillic'] = 0x04D4;
 t['Ainvertedbreve'] = 0x0202;
 t['Alpha'] = 0x0391;
 t['Alphatonos'] = 0x0386;
 t['Amacron'] = 0x0100;
 t['Amonospace'] = 0xFF21;
 t['Aogonek'] = 0x0104;
 t['Aring'] = 0x00C5;
 t['Aringacute'] = 0x01FA;
 t['Aringbelow'] = 0x1E00;
 t['Aringsmall'] = 0xF7E5;
 t['Asmall'] = 0xF761;
 t['Atilde'] = 0x00C3;
 t['Atildesmall'] = 0xF7E3;
 t['Aybarmenian'] = 0x0531;
 t['B'] = 0x0042;
 t['Bcircle'] = 0x24B7;
 t['Bdotaccent'] = 0x1E02;
 t['Bdotbelow'] = 0x1E04;
 t['Becyrillic'] = 0x0411;
 t['Benarmenian'] = 0x0532;
 t['Beta'] = 0x0392;
 t['Bhook'] = 0x0181;
 t['Blinebelow'] = 0x1E06;
 t['Bmonospace'] = 0xFF22;
 t['Brevesmall'] = 0xF6F4;
 t['Bsmall'] = 0xF762;
 t['Btopbar'] = 0x0182;
 t['C'] = 0x0043;
 t['Caarmenian'] = 0x053E;
 t['Cacute'] = 0x0106;
 t['Caron'] = 0xF6CA;
 t['Caronsmall'] = 0xF6F5;
 t['Ccaron'] = 0x010C;
 t['Ccedilla'] = 0x00C7;
 t['Ccedillaacute'] = 0x1E08;
 t['Ccedillasmall'] = 0xF7E7;
 t['Ccircle'] = 0x24B8;
 t['Ccircumflex'] = 0x0108;
 t['Cdot'] = 0x010A;
 t['Cdotaccent'] = 0x010A;
 t['Cedillasmall'] = 0xF7B8;
 t['Chaarmenian'] = 0x0549;
 t['Cheabkhasiancyrillic'] = 0x04BC;
 t['Checyrillic'] = 0x0427;
 t['Chedescenderabkhasiancyrillic'] = 0x04BE;
 t['Chedescendercyrillic'] = 0x04B6;
 t['Chedieresiscyrillic'] = 0x04F4;
 t['Cheharmenian'] = 0x0543;
 t['Chekhakassiancyrillic'] = 0x04CB;
 t['Cheverticalstrokecyrillic'] = 0x04B8;
 t['Chi'] = 0x03A7;
 t['Chook'] = 0x0187;
 t['Circumflexsmall'] = 0xF6F6;
 t['Cmonospace'] = 0xFF23;
 t['Coarmenian'] = 0x0551;
 t['Csmall'] = 0xF763;
 t['D'] = 0x0044;
 t['DZ'] = 0x01F1;
 t['DZcaron'] = 0x01C4;
 t['Daarmenian'] = 0x0534;
 t['Dafrican'] = 0x0189;
 t['Dcaron'] = 0x010E;
 t['Dcedilla'] = 0x1E10;
 t['Dcircle'] = 0x24B9;
 t['Dcircumflexbelow'] = 0x1E12;
 t['Dcroat'] = 0x0110;
 t['Ddotaccent'] = 0x1E0A;
 t['Ddotbelow'] = 0x1E0C;
 t['Decyrillic'] = 0x0414;
 t['Deicoptic'] = 0x03EE;
 t['Delta'] = 0x2206;
 t['Deltagreek'] = 0x0394;
 t['Dhook'] = 0x018A;
 t['Dieresis'] = 0xF6CB;
 t['DieresisAcute'] = 0xF6CC;
 t['DieresisGrave'] = 0xF6CD;
 t['Dieresissmall'] = 0xF7A8;
 t['Digammagreek'] = 0x03DC;
 t['Djecyrillic'] = 0x0402;
 t['Dlinebelow'] = 0x1E0E;
 t['Dmonospace'] = 0xFF24;
 t['Dotaccentsmall'] = 0xF6F7;
 t['Dslash'] = 0x0110;
 t['Dsmall'] = 0xF764;
 t['Dtopbar'] = 0x018B;
 t['Dz'] = 0x01F2;
 t['Dzcaron'] = 0x01C5;
 t['Dzeabkhasiancyrillic'] = 0x04E0;
 t['Dzecyrillic'] = 0x0405;
 t['Dzhecyrillic'] = 0x040F;
 t['E'] = 0x0045;
 t['Eacute'] = 0x00C9;
 t['Eacutesmall'] = 0xF7E9;
 t['Ebreve'] = 0x0114;
 t['Ecaron'] = 0x011A;
 t['Ecedillabreve'] = 0x1E1C;
 t['Echarmenian'] = 0x0535;
 t['Ecircle'] = 0x24BA;
 t['Ecircumflex'] = 0x00CA;
 t['Ecircumflexacute'] = 0x1EBE;
 t['Ecircumflexbelow'] = 0x1E18;
 t['Ecircumflexdotbelow'] = 0x1EC6;
 t['Ecircumflexgrave'] = 0x1EC0;
 t['Ecircumflexhookabove'] = 0x1EC2;
 t['Ecircumflexsmall'] = 0xF7EA;
 t['Ecircumflextilde'] = 0x1EC4;
 t['Ecyrillic'] = 0x0404;
 t['Edblgrave'] = 0x0204;
 t['Edieresis'] = 0x00CB;
 t['Edieresissmall'] = 0xF7EB;
 t['Edot'] = 0x0116;
 t['Edotaccent'] = 0x0116;
 t['Edotbelow'] = 0x1EB8;
 t['Efcyrillic'] = 0x0424;
 t['Egrave'] = 0x00C8;
 t['Egravesmall'] = 0xF7E8;
 t['Eharmenian'] = 0x0537;
 t['Ehookabove'] = 0x1EBA;
 t['Eightroman'] = 0x2167;
 t['Einvertedbreve'] = 0x0206;
 t['Eiotifiedcyrillic'] = 0x0464;
 t['Elcyrillic'] = 0x041B;
 t['Elevenroman'] = 0x216A;
 t['Emacron'] = 0x0112;
 t['Emacronacute'] = 0x1E16;
 t['Emacrongrave'] = 0x1E14;
 t['Emcyrillic'] = 0x041C;
 t['Emonospace'] = 0xFF25;
 t['Encyrillic'] = 0x041D;
 t['Endescendercyrillic'] = 0x04A2;
 t['Eng'] = 0x014A;
 t['Enghecyrillic'] = 0x04A4;
 t['Enhookcyrillic'] = 0x04C7;
 t['Eogonek'] = 0x0118;
 t['Eopen'] = 0x0190;
 t['Epsilon'] = 0x0395;
 t['Epsilontonos'] = 0x0388;
 t['Ercyrillic'] = 0x0420;
 t['Ereversed'] = 0x018E;
 t['Ereversedcyrillic'] = 0x042D;
 t['Escyrillic'] = 0x0421;
 t['Esdescendercyrillic'] = 0x04AA;
 t['Esh'] = 0x01A9;
 t['Esmall'] = 0xF765;
 t['Eta'] = 0x0397;
 t['Etarmenian'] = 0x0538;
 t['Etatonos'] = 0x0389;
 t['Eth'] = 0x00D0;
 t['Ethsmall'] = 0xF7F0;
 t['Etilde'] = 0x1EBC;
 t['Etildebelow'] = 0x1E1A;
 t['Euro'] = 0x20AC;
 t['Ezh'] = 0x01B7;
 t['Ezhcaron'] = 0x01EE;
 t['Ezhreversed'] = 0x01B8;
 t['F'] = 0x0046;
 t['Fcircle'] = 0x24BB;
 t['Fdotaccent'] = 0x1E1E;
 t['Feharmenian'] = 0x0556;
 t['Feicoptic'] = 0x03E4;
 t['Fhook'] = 0x0191;
 t['Fitacyrillic'] = 0x0472;
 t['Fiveroman'] = 0x2164;
 t['Fmonospace'] = 0xFF26;
 t['Fourroman'] = 0x2163;
 t['Fsmall'] = 0xF766;
 t['G'] = 0x0047;
 t['GBsquare'] = 0x3387;
 t['Gacute'] = 0x01F4;
 t['Gamma'] = 0x0393;
 t['Gammaafrican'] = 0x0194;
 t['Gangiacoptic'] = 0x03EA;
 t['Gbreve'] = 0x011E;
 t['Gcaron'] = 0x01E6;
 t['Gcedilla'] = 0x0122;
 t['Gcircle'] = 0x24BC;
 t['Gcircumflex'] = 0x011C;
 t['Gcommaaccent'] = 0x0122;
 t['Gdot'] = 0x0120;
 t['Gdotaccent'] = 0x0120;
 t['Gecyrillic'] = 0x0413;
 t['Ghadarmenian'] = 0x0542;
 t['Ghemiddlehookcyrillic'] = 0x0494;
 t['Ghestrokecyrillic'] = 0x0492;
 t['Gheupturncyrillic'] = 0x0490;
 t['Ghook'] = 0x0193;
 t['Gimarmenian'] = 0x0533;
 t['Gjecyrillic'] = 0x0403;
 t['Gmacron'] = 0x1E20;
 t['Gmonospace'] = 0xFF27;
 t['Grave'] = 0xF6CE;
 t['Gravesmall'] = 0xF760;
 t['Gsmall'] = 0xF767;
 t['Gsmallhook'] = 0x029B;
 t['Gstroke'] = 0x01E4;
 t['H'] = 0x0048;
 t['H18533'] = 0x25CF;
 t['H18543'] = 0x25AA;
 t['H18551'] = 0x25AB;
 t['H22073'] = 0x25A1;
 t['HPsquare'] = 0x33CB;
 t['Haabkhasiancyrillic'] = 0x04A8;
 t['Hadescendercyrillic'] = 0x04B2;
 t['Hardsigncyrillic'] = 0x042A;
 t['Hbar'] = 0x0126;
 t['Hbrevebelow'] = 0x1E2A;
 t['Hcedilla'] = 0x1E28;
 t['Hcircle'] = 0x24BD;
 t['Hcircumflex'] = 0x0124;
 t['Hdieresis'] = 0x1E26;
 t['Hdotaccent'] = 0x1E22;
 t['Hdotbelow'] = 0x1E24;
 t['Hmonospace'] = 0xFF28;
 t['Hoarmenian'] = 0x0540;
 t['Horicoptic'] = 0x03E8;
 t['Hsmall'] = 0xF768;
 t['Hungarumlaut'] = 0xF6CF;
 t['Hungarumlautsmall'] = 0xF6F8;
 t['Hzsquare'] = 0x3390;
 t['I'] = 0x0049;
 t['IAcyrillic'] = 0x042F;
 t['IJ'] = 0x0132;
 t['IUcyrillic'] = 0x042E;
 t['Iacute'] = 0x00CD;
 t['Iacutesmall'] = 0xF7ED;
 t['Ibreve'] = 0x012C;
 t['Icaron'] = 0x01CF;
 t['Icircle'] = 0x24BE;
 t['Icircumflex'] = 0x00CE;
 t['Icircumflexsmall'] = 0xF7EE;
 t['Icyrillic'] = 0x0406;
 t['Idblgrave'] = 0x0208;
 t['Idieresis'] = 0x00CF;
 t['Idieresisacute'] = 0x1E2E;
 t['Idieresiscyrillic'] = 0x04E4;
 t['Idieresissmall'] = 0xF7EF;
 t['Idot'] = 0x0130;
 t['Idotaccent'] = 0x0130;
 t['Idotbelow'] = 0x1ECA;
 t['Iebrevecyrillic'] = 0x04D6;
 t['Iecyrillic'] = 0x0415;
 t['Ifraktur'] = 0x2111;
 t['Igrave'] = 0x00CC;
 t['Igravesmall'] = 0xF7EC;
 t['Ihookabove'] = 0x1EC8;
 t['Iicyrillic'] = 0x0418;
 t['Iinvertedbreve'] = 0x020A;
 t['Iishortcyrillic'] = 0x0419;
 t['Imacron'] = 0x012A;
 t['Imacroncyrillic'] = 0x04E2;
 t['Imonospace'] = 0xFF29;
 t['Iniarmenian'] = 0x053B;
 t['Iocyrillic'] = 0x0401;
 t['Iogonek'] = 0x012E;
 t['Iota'] = 0x0399;
 t['Iotaafrican'] = 0x0196;
 t['Iotadieresis'] = 0x03AA;
 t['Iotatonos'] = 0x038A;
 t['Ismall'] = 0xF769;
 t['Istroke'] = 0x0197;
 t['Itilde'] = 0x0128;
 t['Itildebelow'] = 0x1E2C;
 t['Izhitsacyrillic'] = 0x0474;
 t['Izhitsadblgravecyrillic'] = 0x0476;
 t['J'] = 0x004A;
 t['Jaarmenian'] = 0x0541;
 t['Jcircle'] = 0x24BF;
 t['Jcircumflex'] = 0x0134;
 t['Jecyrillic'] = 0x0408;
 t['Jheharmenian'] = 0x054B;
 t['Jmonospace'] = 0xFF2A;
 t['Jsmall'] = 0xF76A;
 t['K'] = 0x004B;
 t['KBsquare'] = 0x3385;
 t['KKsquare'] = 0x33CD;
 t['Kabashkircyrillic'] = 0x04A0;
 t['Kacute'] = 0x1E30;
 t['Kacyrillic'] = 0x041A;
 t['Kadescendercyrillic'] = 0x049A;
 t['Kahookcyrillic'] = 0x04C3;
 t['Kappa'] = 0x039A;
 t['Kastrokecyrillic'] = 0x049E;
 t['Kaverticalstrokecyrillic'] = 0x049C;
 t['Kcaron'] = 0x01E8;
 t['Kcedilla'] = 0x0136;
 t['Kcircle'] = 0x24C0;
 t['Kcommaaccent'] = 0x0136;
 t['Kdotbelow'] = 0x1E32;
 t['Keharmenian'] = 0x0554;
 t['Kenarmenian'] = 0x053F;
 t['Khacyrillic'] = 0x0425;
 t['Kheicoptic'] = 0x03E6;
 t['Khook'] = 0x0198;
 t['Kjecyrillic'] = 0x040C;
 t['Klinebelow'] = 0x1E34;
 t['Kmonospace'] = 0xFF2B;
 t['Koppacyrillic'] = 0x0480;
 t['Koppagreek'] = 0x03DE;
 t['Ksicyrillic'] = 0x046E;
 t['Ksmall'] = 0xF76B;
 t['L'] = 0x004C;
 t['LJ'] = 0x01C7;
 t['LL'] = 0xF6BF;
 t['Lacute'] = 0x0139;
 t['Lambda'] = 0x039B;
 t['Lcaron'] = 0x013D;
 t['Lcedilla'] = 0x013B;
 t['Lcircle'] = 0x24C1;
 t['Lcircumflexbelow'] = 0x1E3C;
 t['Lcommaaccent'] = 0x013B;
 t['Ldot'] = 0x013F;
 t['Ldotaccent'] = 0x013F;
 t['Ldotbelow'] = 0x1E36;
 t['Ldotbelowmacron'] = 0x1E38;
 t['Liwnarmenian'] = 0x053C;
 t['Lj'] = 0x01C8;
 t['Ljecyrillic'] = 0x0409;
 t['Llinebelow'] = 0x1E3A;
 t['Lmonospace'] = 0xFF2C;
 t['Lslash'] = 0x0141;
 t['Lslashsmall'] = 0xF6F9;
 t['Lsmall'] = 0xF76C;
 t['M'] = 0x004D;
 t['MBsquare'] = 0x3386;
 t['Macron'] = 0xF6D0;
 t['Macronsmall'] = 0xF7AF;
 t['Macute'] = 0x1E3E;
 t['Mcircle'] = 0x24C2;
 t['Mdotaccent'] = 0x1E40;
 t['Mdotbelow'] = 0x1E42;
 t['Menarmenian'] = 0x0544;
 t['Mmonospace'] = 0xFF2D;
 t['Msmall'] = 0xF76D;
 t['Mturned'] = 0x019C;
 t['Mu'] = 0x039C;
 t['N'] = 0x004E;
 t['NJ'] = 0x01CA;
 t['Nacute'] = 0x0143;
 t['Ncaron'] = 0x0147;
 t['Ncedilla'] = 0x0145;
 t['Ncircle'] = 0x24C3;
 t['Ncircumflexbelow'] = 0x1E4A;
 t['Ncommaaccent'] = 0x0145;
 t['Ndotaccent'] = 0x1E44;
 t['Ndotbelow'] = 0x1E46;
 t['Nhookleft'] = 0x019D;
 t['Nineroman'] = 0x2168;
 t['Nj'] = 0x01CB;
 t['Njecyrillic'] = 0x040A;
 t['Nlinebelow'] = 0x1E48;
 t['Nmonospace'] = 0xFF2E;
 t['Nowarmenian'] = 0x0546;
 t['Nsmall'] = 0xF76E;
 t['Ntilde'] = 0x00D1;
 t['Ntildesmall'] = 0xF7F1;
 t['Nu'] = 0x039D;
 t['O'] = 0x004F;
 t['OE'] = 0x0152;
 t['OEsmall'] = 0xF6FA;
 t['Oacute'] = 0x00D3;
 t['Oacutesmall'] = 0xF7F3;
 t['Obarredcyrillic'] = 0x04E8;
 t['Obarreddieresiscyrillic'] = 0x04EA;
 t['Obreve'] = 0x014E;
 t['Ocaron'] = 0x01D1;
 t['Ocenteredtilde'] = 0x019F;
 t['Ocircle'] = 0x24C4;
 t['Ocircumflex'] = 0x00D4;
 t['Ocircumflexacute'] = 0x1ED0;
 t['Ocircumflexdotbelow'] = 0x1ED8;
 t['Ocircumflexgrave'] = 0x1ED2;
 t['Ocircumflexhookabove'] = 0x1ED4;
 t['Ocircumflexsmall'] = 0xF7F4;
 t['Ocircumflextilde'] = 0x1ED6;
 t['Ocyrillic'] = 0x041E;
 t['Odblacute'] = 0x0150;
 t['Odblgrave'] = 0x020C;
 t['Odieresis'] = 0x00D6;
 t['Odieresiscyrillic'] = 0x04E6;
 t['Odieresissmall'] = 0xF7F6;
 t['Odotbelow'] = 0x1ECC;
 t['Ogoneksmall'] = 0xF6FB;
 t['Ograve'] = 0x00D2;
 t['Ogravesmall'] = 0xF7F2;
 t['Oharmenian'] = 0x0555;
 t['Ohm'] = 0x2126;
 t['Ohookabove'] = 0x1ECE;
 t['Ohorn'] = 0x01A0;
 t['Ohornacute'] = 0x1EDA;
 t['Ohorndotbelow'] = 0x1EE2;
 t['Ohorngrave'] = 0x1EDC;
 t['Ohornhookabove'] = 0x1EDE;
 t['Ohorntilde'] = 0x1EE0;
 t['Ohungarumlaut'] = 0x0150;
 t['Oi'] = 0x01A2;
 t['Oinvertedbreve'] = 0x020E;
 t['Omacron'] = 0x014C;
 t['Omacronacute'] = 0x1E52;
 t['Omacrongrave'] = 0x1E50;
 t['Omega'] = 0x2126;
 t['Omegacyrillic'] = 0x0460;
 t['Omegagreek'] = 0x03A9;
 t['Omegaroundcyrillic'] = 0x047A;
 t['Omegatitlocyrillic'] = 0x047C;
 t['Omegatonos'] = 0x038F;
 t['Omicron'] = 0x039F;
 t['Omicrontonos'] = 0x038C;
 t['Omonospace'] = 0xFF2F;
 t['Oneroman'] = 0x2160;
 t['Oogonek'] = 0x01EA;
 t['Oogonekmacron'] = 0x01EC;
 t['Oopen'] = 0x0186;
 t['Oslash'] = 0x00D8;
 t['Oslashacute'] = 0x01FE;
 t['Oslashsmall'] = 0xF7F8;
 t['Osmall'] = 0xF76F;
 t['Ostrokeacute'] = 0x01FE;
 t['Otcyrillic'] = 0x047E;
 t['Otilde'] = 0x00D5;
 t['Otildeacute'] = 0x1E4C;
 t['Otildedieresis'] = 0x1E4E;
 t['Otildesmall'] = 0xF7F5;
 t['P'] = 0x0050;
 t['Pacute'] = 0x1E54;
 t['Pcircle'] = 0x24C5;
 t['Pdotaccent'] = 0x1E56;
 t['Pecyrillic'] = 0x041F;
 t['Peharmenian'] = 0x054A;
 t['Pemiddlehookcyrillic'] = 0x04A6;
 t['Phi'] = 0x03A6;
 t['Phook'] = 0x01A4;
 t['Pi'] = 0x03A0;
 t['Piwrarmenian'] = 0x0553;
 t['Pmonospace'] = 0xFF30;
 t['Psi'] = 0x03A8;
 t['Psicyrillic'] = 0x0470;
 t['Psmall'] = 0xF770;
 t['Q'] = 0x0051;
 t['Qcircle'] = 0x24C6;
 t['Qmonospace'] = 0xFF31;
 t['Qsmall'] = 0xF771;
 t['R'] = 0x0052;
 t['Raarmenian'] = 0x054C;
 t['Racute'] = 0x0154;
 t['Rcaron'] = 0x0158;
 t['Rcedilla'] = 0x0156;
 t['Rcircle'] = 0x24C7;
 t['Rcommaaccent'] = 0x0156;
 t['Rdblgrave'] = 0x0210;
 t['Rdotaccent'] = 0x1E58;
 t['Rdotbelow'] = 0x1E5A;
 t['Rdotbelowmacron'] = 0x1E5C;
 t['Reharmenian'] = 0x0550;
 t['Rfraktur'] = 0x211C;
 t['Rho'] = 0x03A1;
 t['Ringsmall'] = 0xF6FC;
 t['Rinvertedbreve'] = 0x0212;
 t['Rlinebelow'] = 0x1E5E;
 t['Rmonospace'] = 0xFF32;
 t['Rsmall'] = 0xF772;
 t['Rsmallinverted'] = 0x0281;
 t['Rsmallinvertedsuperior'] = 0x02B6;
 t['S'] = 0x0053;
 t['SF010000'] = 0x250C;
 t['SF020000'] = 0x2514;
 t['SF030000'] = 0x2510;
 t['SF040000'] = 0x2518;
 t['SF050000'] = 0x253C;
 t['SF060000'] = 0x252C;
 t['SF070000'] = 0x2534;
 t['SF080000'] = 0x251C;
 t['SF090000'] = 0x2524;
 t['SF100000'] = 0x2500;
 t['SF110000'] = 0x2502;
 t['SF190000'] = 0x2561;
 t['SF200000'] = 0x2562;
 t['SF210000'] = 0x2556;
 t['SF220000'] = 0x2555;
 t['SF230000'] = 0x2563;
 t['SF240000'] = 0x2551;
 t['SF250000'] = 0x2557;
 t['SF260000'] = 0x255D;
 t['SF270000'] = 0x255C;
 t['SF280000'] = 0x255B;
 t['SF360000'] = 0x255E;
 t['SF370000'] = 0x255F;
 t['SF380000'] = 0x255A;
 t['SF390000'] = 0x2554;
 t['SF400000'] = 0x2569;
 t['SF410000'] = 0x2566;
 t['SF420000'] = 0x2560;
 t['SF430000'] = 0x2550;
 t['SF440000'] = 0x256C;
 t['SF450000'] = 0x2567;
 t['SF460000'] = 0x2568;
 t['SF470000'] = 0x2564;
 t['SF480000'] = 0x2565;
 t['SF490000'] = 0x2559;
 t['SF500000'] = 0x2558;
 t['SF510000'] = 0x2552;
 t['SF520000'] = 0x2553;
 t['SF530000'] = 0x256B;
 t['SF540000'] = 0x256A;
 t['Sacute'] = 0x015A;
 t['Sacutedotaccent'] = 0x1E64;
 t['Sampigreek'] = 0x03E0;
 t['Scaron'] = 0x0160;
 t['Scarondotaccent'] = 0x1E66;
 t['Scaronsmall'] = 0xF6FD;
 t['Scedilla'] = 0x015E;
 t['Schwa'] = 0x018F;
 t['Schwacyrillic'] = 0x04D8;
 t['Schwadieresiscyrillic'] = 0x04DA;
 t['Scircle'] = 0x24C8;
 t['Scircumflex'] = 0x015C;
 t['Scommaaccent'] = 0x0218;
 t['Sdotaccent'] = 0x1E60;
 t['Sdotbelow'] = 0x1E62;
 t['Sdotbelowdotaccent'] = 0x1E68;
 t['Seharmenian'] = 0x054D;
 t['Sevenroman'] = 0x2166;
 t['Shaarmenian'] = 0x0547;
 t['Shacyrillic'] = 0x0428;
 t['Shchacyrillic'] = 0x0429;
 t['Sheicoptic'] = 0x03E2;
 t['Shhacyrillic'] = 0x04BA;
 t['Shimacoptic'] = 0x03EC;
 t['Sigma'] = 0x03A3;
 t['Sixroman'] = 0x2165;
 t['Smonospace'] = 0xFF33;
 t['Softsigncyrillic'] = 0x042C;
 t['Ssmall'] = 0xF773;
 t['Stigmagreek'] = 0x03DA;
 t['T'] = 0x0054;
 t['Tau'] = 0x03A4;
 t['Tbar'] = 0x0166;
 t['Tcaron'] = 0x0164;
 t['Tcedilla'] = 0x0162;
 t['Tcircle'] = 0x24C9;
 t['Tcircumflexbelow'] = 0x1E70;
 t['Tcommaaccent'] = 0x0162;
 t['Tdotaccent'] = 0x1E6A;
 t['Tdotbelow'] = 0x1E6C;
 t['Tecyrillic'] = 0x0422;
 t['Tedescendercyrillic'] = 0x04AC;
 t['Tenroman'] = 0x2169;
 t['Tetsecyrillic'] = 0x04B4;
 t['Theta'] = 0x0398;
 t['Thook'] = 0x01AC;
 t['Thorn'] = 0x00DE;
 t['Thornsmall'] = 0xF7FE;
 t['Threeroman'] = 0x2162;
 t['Tildesmall'] = 0xF6FE;
 t['Tiwnarmenian'] = 0x054F;
 t['Tlinebelow'] = 0x1E6E;
 t['Tmonospace'] = 0xFF34;
 t['Toarmenian'] = 0x0539;
 t['Tonefive'] = 0x01BC;
 t['Tonesix'] = 0x0184;
 t['Tonetwo'] = 0x01A7;
 t['Tretroflexhook'] = 0x01AE;
 t['Tsecyrillic'] = 0x0426;
 t['Tshecyrillic'] = 0x040B;
 t['Tsmall'] = 0xF774;
 t['Twelveroman'] = 0x216B;
 t['Tworoman'] = 0x2161;
 t['U'] = 0x0055;
 t['Uacute'] = 0x00DA;
 t['Uacutesmall'] = 0xF7FA;
 t['Ubreve'] = 0x016C;
 t['Ucaron'] = 0x01D3;
 t['Ucircle'] = 0x24CA;
 t['Ucircumflex'] = 0x00DB;
 t['Ucircumflexbelow'] = 0x1E76;
 t['Ucircumflexsmall'] = 0xF7FB;
 t['Ucyrillic'] = 0x0423;
 t['Udblacute'] = 0x0170;
 t['Udblgrave'] = 0x0214;
 t['Udieresis'] = 0x00DC;
 t['Udieresisacute'] = 0x01D7;
 t['Udieresisbelow'] = 0x1E72;
 t['Udieresiscaron'] = 0x01D9;
 t['Udieresiscyrillic'] = 0x04F0;
 t['Udieresisgrave'] = 0x01DB;
 t['Udieresismacron'] = 0x01D5;
 t['Udieresissmall'] = 0xF7FC;
 t['Udotbelow'] = 0x1EE4;
 t['Ugrave'] = 0x00D9;
 t['Ugravesmall'] = 0xF7F9;
 t['Uhookabove'] = 0x1EE6;
 t['Uhorn'] = 0x01AF;
 t['Uhornacute'] = 0x1EE8;
 t['Uhorndotbelow'] = 0x1EF0;
 t['Uhorngrave'] = 0x1EEA;
 t['Uhornhookabove'] = 0x1EEC;
 t['Uhorntilde'] = 0x1EEE;
 t['Uhungarumlaut'] = 0x0170;
 t['Uhungarumlautcyrillic'] = 0x04F2;
 t['Uinvertedbreve'] = 0x0216;
 t['Ukcyrillic'] = 0x0478;
 t['Umacron'] = 0x016A;
 t['Umacroncyrillic'] = 0x04EE;
 t['Umacrondieresis'] = 0x1E7A;
 t['Umonospace'] = 0xFF35;
 t['Uogonek'] = 0x0172;
 t['Upsilon'] = 0x03A5;
 t['Upsilon1'] = 0x03D2;
 t['Upsilonacutehooksymbolgreek'] = 0x03D3;
 t['Upsilonafrican'] = 0x01B1;
 t['Upsilondieresis'] = 0x03AB;
 t['Upsilondieresishooksymbolgreek'] = 0x03D4;
 t['Upsilonhooksymbol'] = 0x03D2;
 t['Upsilontonos'] = 0x038E;
 t['Uring'] = 0x016E;
 t['Ushortcyrillic'] = 0x040E;
 t['Usmall'] = 0xF775;
 t['Ustraightcyrillic'] = 0x04AE;
 t['Ustraightstrokecyrillic'] = 0x04B0;
 t['Utilde'] = 0x0168;
 t['Utildeacute'] = 0x1E78;
 t['Utildebelow'] = 0x1E74;
 t['V'] = 0x0056;
 t['Vcircle'] = 0x24CB;
 t['Vdotbelow'] = 0x1E7E;
 t['Vecyrillic'] = 0x0412;
 t['Vewarmenian'] = 0x054E;
 t['Vhook'] = 0x01B2;
 t['Vmonospace'] = 0xFF36;
 t['Voarmenian'] = 0x0548;
 t['Vsmall'] = 0xF776;
 t['Vtilde'] = 0x1E7C;
 t['W'] = 0x0057;
 t['Wacute'] = 0x1E82;
 t['Wcircle'] = 0x24CC;
 t['Wcircumflex'] = 0x0174;
 t['Wdieresis'] = 0x1E84;
 t['Wdotaccent'] = 0x1E86;
 t['Wdotbelow'] = 0x1E88;
 t['Wgrave'] = 0x1E80;
 t['Wmonospace'] = 0xFF37;
 t['Wsmall'] = 0xF777;
 t['X'] = 0x0058;
 t['Xcircle'] = 0x24CD;
 t['Xdieresis'] = 0x1E8C;
 t['Xdotaccent'] = 0x1E8A;
 t['Xeharmenian'] = 0x053D;
 t['Xi'] = 0x039E;
 t['Xmonospace'] = 0xFF38;
 t['Xsmall'] = 0xF778;
 t['Y'] = 0x0059;
 t['Yacute'] = 0x00DD;
 t['Yacutesmall'] = 0xF7FD;
 t['Yatcyrillic'] = 0x0462;
 t['Ycircle'] = 0x24CE;
 t['Ycircumflex'] = 0x0176;
 t['Ydieresis'] = 0x0178;
 t['Ydieresissmall'] = 0xF7FF;
 t['Ydotaccent'] = 0x1E8E;
 t['Ydotbelow'] = 0x1EF4;
 t['Yericyrillic'] = 0x042B;
 t['Yerudieresiscyrillic'] = 0x04F8;
 t['Ygrave'] = 0x1EF2;
 t['Yhook'] = 0x01B3;
 t['Yhookabove'] = 0x1EF6;
 t['Yiarmenian'] = 0x0545;
 t['Yicyrillic'] = 0x0407;
 t['Yiwnarmenian'] = 0x0552;
 t['Ymonospace'] = 0xFF39;
 t['Ysmall'] = 0xF779;
 t['Ytilde'] = 0x1EF8;
 t['Yusbigcyrillic'] = 0x046A;
 t['Yusbigiotifiedcyrillic'] = 0x046C;
 t['Yuslittlecyrillic'] = 0x0466;
 t['Yuslittleiotifiedcyrillic'] = 0x0468;
 t['Z'] = 0x005A;
 t['Zaarmenian'] = 0x0536;
 t['Zacute'] = 0x0179;
 t['Zcaron'] = 0x017D;
 t['Zcaronsmall'] = 0xF6FF;
 t['Zcircle'] = 0x24CF;
 t['Zcircumflex'] = 0x1E90;
 t['Zdot'] = 0x017B;
 t['Zdotaccent'] = 0x017B;
 t['Zdotbelow'] = 0x1E92;
 t['Zecyrillic'] = 0x0417;
 t['Zedescendercyrillic'] = 0x0498;
 t['Zedieresiscyrillic'] = 0x04DE;
 t['Zeta'] = 0x0396;
 t['Zhearmenian'] = 0x053A;
 t['Zhebrevecyrillic'] = 0x04C1;
 t['Zhecyrillic'] = 0x0416;
 t['Zhedescendercyrillic'] = 0x0496;
 t['Zhedieresiscyrillic'] = 0x04DC;
 t['Zlinebelow'] = 0x1E94;
 t['Zmonospace'] = 0xFF3A;
 t['Zsmall'] = 0xF77A;
 t['Zstroke'] = 0x01B5;
 t['a'] = 0x0061;
 t['aabengali'] = 0x0986;
 t['aacute'] = 0x00E1;
 t['aadeva'] = 0x0906;
 t['aagujarati'] = 0x0A86;
 t['aagurmukhi'] = 0x0A06;
 t['aamatragurmukhi'] = 0x0A3E;
 t['aarusquare'] = 0x3303;
 t['aavowelsignbengali'] = 0x09BE;
 t['aavowelsigndeva'] = 0x093E;
 t['aavowelsigngujarati'] = 0x0ABE;
 t['abbreviationmarkarmenian'] = 0x055F;
 t['abbreviationsigndeva'] = 0x0970;
 t['abengali'] = 0x0985;
 t['abopomofo'] = 0x311A;
 t['abreve'] = 0x0103;
 t['abreveacute'] = 0x1EAF;
 t['abrevecyrillic'] = 0x04D1;
 t['abrevedotbelow'] = 0x1EB7;
 t['abrevegrave'] = 0x1EB1;
 t['abrevehookabove'] = 0x1EB3;
 t['abrevetilde'] = 0x1EB5;
 t['acaron'] = 0x01CE;
 t['acircle'] = 0x24D0;
 t['acircumflex'] = 0x00E2;
 t['acircumflexacute'] = 0x1EA5;
 t['acircumflexdotbelow'] = 0x1EAD;
 t['acircumflexgrave'] = 0x1EA7;
 t['acircumflexhookabove'] = 0x1EA9;
 t['acircumflextilde'] = 0x1EAB;
 t['acute'] = 0x00B4;
 t['acutebelowcmb'] = 0x0317;
 t['acutecmb'] = 0x0301;
 t['acutecomb'] = 0x0301;
 t['acutedeva'] = 0x0954;
 t['acutelowmod'] = 0x02CF;
 t['acutetonecmb'] = 0x0341;
 t['acyrillic'] = 0x0430;
 t['adblgrave'] = 0x0201;
 t['addakgurmukhi'] = 0x0A71;
 t['adeva'] = 0x0905;
 t['adieresis'] = 0x00E4;
 t['adieresiscyrillic'] = 0x04D3;
 t['adieresismacron'] = 0x01DF;
 t['adotbelow'] = 0x1EA1;
 t['adotmacron'] = 0x01E1;
 t['ae'] = 0x00E6;
 t['aeacute'] = 0x01FD;
 t['aekorean'] = 0x3150;
 t['aemacron'] = 0x01E3;
 t['afii00208'] = 0x2015;
 t['afii08941'] = 0x20A4;
 t['afii10017'] = 0x0410;
 t['afii10018'] = 0x0411;
 t['afii10019'] = 0x0412;
 t['afii10020'] = 0x0413;
 t['afii10021'] = 0x0414;
 t['afii10022'] = 0x0415;
 t['afii10023'] = 0x0401;
 t['afii10024'] = 0x0416;
 t['afii10025'] = 0x0417;
 t['afii10026'] = 0x0418;
 t['afii10027'] = 0x0419;
 t['afii10028'] = 0x041A;
 t['afii10029'] = 0x041B;
 t['afii10030'] = 0x041C;
 t['afii10031'] = 0x041D;
 t['afii10032'] = 0x041E;
 t['afii10033'] = 0x041F;
 t['afii10034'] = 0x0420;
 t['afii10035'] = 0x0421;
 t['afii10036'] = 0x0422;
 t['afii10037'] = 0x0423;
 t['afii10038'] = 0x0424;
 t['afii10039'] = 0x0425;
 t['afii10040'] = 0x0426;
 t['afii10041'] = 0x0427;
 t['afii10042'] = 0x0428;
 t['afii10043'] = 0x0429;
 t['afii10044'] = 0x042A;
 t['afii10045'] = 0x042B;
 t['afii10046'] = 0x042C;
 t['afii10047'] = 0x042D;
 t['afii10048'] = 0x042E;
 t['afii10049'] = 0x042F;
 t['afii10050'] = 0x0490;
 t['afii10051'] = 0x0402;
 t['afii10052'] = 0x0403;
 t['afii10053'] = 0x0404;
 t['afii10054'] = 0x0405;
 t['afii10055'] = 0x0406;
 t['afii10056'] = 0x0407;
 t['afii10057'] = 0x0408;
 t['afii10058'] = 0x0409;
 t['afii10059'] = 0x040A;
 t['afii10060'] = 0x040B;
 t['afii10061'] = 0x040C;
 t['afii10062'] = 0x040E;
 t['afii10063'] = 0xF6C4;
 t['afii10064'] = 0xF6C5;
 t['afii10065'] = 0x0430;
 t['afii10066'] = 0x0431;
 t['afii10067'] = 0x0432;
 t['afii10068'] = 0x0433;
 t['afii10069'] = 0x0434;
 t['afii10070'] = 0x0435;
 t['afii10071'] = 0x0451;
 t['afii10072'] = 0x0436;
 t['afii10073'] = 0x0437;
 t['afii10074'] = 0x0438;
 t['afii10075'] = 0x0439;
 t['afii10076'] = 0x043A;
 t['afii10077'] = 0x043B;
 t['afii10078'] = 0x043C;
 t['afii10079'] = 0x043D;
 t['afii10080'] = 0x043E;
 t['afii10081'] = 0x043F;
 t['afii10082'] = 0x0440;
 t['afii10083'] = 0x0441;
 t['afii10084'] = 0x0442;
 t['afii10085'] = 0x0443;
 t['afii10086'] = 0x0444;
 t['afii10087'] = 0x0445;
 t['afii10088'] = 0x0446;
 t['afii10089'] = 0x0447;
 t['afii10090'] = 0x0448;
 t['afii10091'] = 0x0449;
 t['afii10092'] = 0x044A;
 t['afii10093'] = 0x044B;
 t['afii10094'] = 0x044C;
 t['afii10095'] = 0x044D;
 t['afii10096'] = 0x044E;
 t['afii10097'] = 0x044F;
 t['afii10098'] = 0x0491;
 t['afii10099'] = 0x0452;
 t['afii10100'] = 0x0453;
 t['afii10101'] = 0x0454;
 t['afii10102'] = 0x0455;
 t['afii10103'] = 0x0456;
 t['afii10104'] = 0x0457;
 t['afii10105'] = 0x0458;
 t['afii10106'] = 0x0459;
 t['afii10107'] = 0x045A;
 t['afii10108'] = 0x045B;
 t['afii10109'] = 0x045C;
 t['afii10110'] = 0x045E;
 t['afii10145'] = 0x040F;
 t['afii10146'] = 0x0462;
 t['afii10147'] = 0x0472;
 t['afii10148'] = 0x0474;
 t['afii10192'] = 0xF6C6;
 t['afii10193'] = 0x045F;
 t['afii10194'] = 0x0463;
 t['afii10195'] = 0x0473;
 t['afii10196'] = 0x0475;
 t['afii10831'] = 0xF6C7;
 t['afii10832'] = 0xF6C8;
 t['afii10846'] = 0x04D9;
 t['afii299'] = 0x200E;
 t['afii300'] = 0x200F;
 t['afii301'] = 0x200D;
 t['afii57381'] = 0x066A;
 t['afii57388'] = 0x060C;
 t['afii57392'] = 0x0660;
 t['afii57393'] = 0x0661;
 t['afii57394'] = 0x0662;
 t['afii57395'] = 0x0663;
 t['afii57396'] = 0x0664;
 t['afii57397'] = 0x0665;
 t['afii57398'] = 0x0666;
 t['afii57399'] = 0x0667;
 t['afii57400'] = 0x0668;
 t['afii57401'] = 0x0669;
 t['afii57403'] = 0x061B;
 t['afii57407'] = 0x061F;
 t['afii57409'] = 0x0621;
 t['afii57410'] = 0x0622;
 t['afii57411'] = 0x0623;
 t['afii57412'] = 0x0624;
 t['afii57413'] = 0x0625;
 t['afii57414'] = 0x0626;
 t['afii57415'] = 0x0627;
 t['afii57416'] = 0x0628;
 t['afii57417'] = 0x0629;
 t['afii57418'] = 0x062A;
 t['afii57419'] = 0x062B;
 t['afii57420'] = 0x062C;
 t['afii57421'] = 0x062D;
 t['afii57422'] = 0x062E;
 t['afii57423'] = 0x062F;
 t['afii57424'] = 0x0630;
 t['afii57425'] = 0x0631;
 t['afii57426'] = 0x0632;
 t['afii57427'] = 0x0633;
 t['afii57428'] = 0x0634;
 t['afii57429'] = 0x0635;
 t['afii57430'] = 0x0636;
 t['afii57431'] = 0x0637;
 t['afii57432'] = 0x0638;
 t['afii57433'] = 0x0639;
 t['afii57434'] = 0x063A;
 t['afii57440'] = 0x0640;
 t['afii57441'] = 0x0641;
 t['afii57442'] = 0x0642;
 t['afii57443'] = 0x0643;
 t['afii57444'] = 0x0644;
 t['afii57445'] = 0x0645;
 t['afii57446'] = 0x0646;
 t['afii57448'] = 0x0648;
 t['afii57449'] = 0x0649;
 t['afii57450'] = 0x064A;
 t['afii57451'] = 0x064B;
 t['afii57452'] = 0x064C;
 t['afii57453'] = 0x064D;
 t['afii57454'] = 0x064E;
 t['afii57455'] = 0x064F;
 t['afii57456'] = 0x0650;
 t['afii57457'] = 0x0651;
 t['afii57458'] = 0x0652;
 t['afii57470'] = 0x0647;
 t['afii57505'] = 0x06A4;
 t['afii57506'] = 0x067E;
 t['afii57507'] = 0x0686;
 t['afii57508'] = 0x0698;
 t['afii57509'] = 0x06AF;
 t['afii57511'] = 0x0679;
 t['afii57512'] = 0x0688;
 t['afii57513'] = 0x0691;
 t['afii57514'] = 0x06BA;
 t['afii57519'] = 0x06D2;
 t['afii57534'] = 0x06D5;
 t['afii57636'] = 0x20AA;
 t['afii57645'] = 0x05BE;
 t['afii57658'] = 0x05C3;
 t['afii57664'] = 0x05D0;
 t['afii57665'] = 0x05D1;
 t['afii57666'] = 0x05D2;
 t['afii57667'] = 0x05D3;
 t['afii57668'] = 0x05D4;
 t['afii57669'] = 0x05D5;
 t['afii57670'] = 0x05D6;
 t['afii57671'] = 0x05D7;
 t['afii57672'] = 0x05D8;
 t['afii57673'] = 0x05D9;
 t['afii57674'] = 0x05DA;
 t['afii57675'] = 0x05DB;
 t['afii57676'] = 0x05DC;
 t['afii57677'] = 0x05DD;
 t['afii57678'] = 0x05DE;
 t['afii57679'] = 0x05DF;
 t['afii57680'] = 0x05E0;
 t['afii57681'] = 0x05E1;
 t['afii57682'] = 0x05E2;
 t['afii57683'] = 0x05E3;
 t['afii57684'] = 0x05E4;
 t['afii57685'] = 0x05E5;
 t['afii57686'] = 0x05E6;
 t['afii57687'] = 0x05E7;
 t['afii57688'] = 0x05E8;
 t['afii57689'] = 0x05E9;
 t['afii57690'] = 0x05EA;
 t['afii57694'] = 0xFB2A;
 t['afii57695'] = 0xFB2B;
 t['afii57700'] = 0xFB4B;
 t['afii57705'] = 0xFB1F;
 t['afii57716'] = 0x05F0;
 t['afii57717'] = 0x05F1;
 t['afii57718'] = 0x05F2;
 t['afii57723'] = 0xFB35;
 t['afii57793'] = 0x05B4;
 t['afii57794'] = 0x05B5;
 t['afii57795'] = 0x05B6;
 t['afii57796'] = 0x05BB;
 t['afii57797'] = 0x05B8;
 t['afii57798'] = 0x05B7;
 t['afii57799'] = 0x05B0;
 t['afii57800'] = 0x05B2;
 t['afii57801'] = 0x05B1;
 t['afii57802'] = 0x05B3;
 t['afii57803'] = 0x05C2;
 t['afii57804'] = 0x05C1;
 t['afii57806'] = 0x05B9;
 t['afii57807'] = 0x05BC;
 t['afii57839'] = 0x05BD;
 t['afii57841'] = 0x05BF;
 t['afii57842'] = 0x05C0;
 t['afii57929'] = 0x02BC;
 t['afii61248'] = 0x2105;
 t['afii61289'] = 0x2113;
 t['afii61352'] = 0x2116;
 t['afii61573'] = 0x202C;
 t['afii61574'] = 0x202D;
 t['afii61575'] = 0x202E;
 t['afii61664'] = 0x200C;
 t['afii63167'] = 0x066D;
 t['afii64937'] = 0x02BD;
 t['agrave'] = 0x00E0;
 t['agujarati'] = 0x0A85;
 t['agurmukhi'] = 0x0A05;
 t['ahiragana'] = 0x3042;
 t['ahookabove'] = 0x1EA3;
 t['aibengali'] = 0x0990;
 t['aibopomofo'] = 0x311E;
 t['aideva'] = 0x0910;
 t['aiecyrillic'] = 0x04D5;
 t['aigujarati'] = 0x0A90;
 t['aigurmukhi'] = 0x0A10;
 t['aimatragurmukhi'] = 0x0A48;
 t['ainarabic'] = 0x0639;
 t['ainfinalarabic'] = 0xFECA;
 t['aininitialarabic'] = 0xFECB;
 t['ainmedialarabic'] = 0xFECC;
 t['ainvertedbreve'] = 0x0203;
 t['aivowelsignbengali'] = 0x09C8;
 t['aivowelsigndeva'] = 0x0948;
 t['aivowelsigngujarati'] = 0x0AC8;
 t['akatakana'] = 0x30A2;
 t['akatakanahalfwidth'] = 0xFF71;
 t['akorean'] = 0x314F;
 t['alef'] = 0x05D0;
 t['alefarabic'] = 0x0627;
 t['alefdageshhebrew'] = 0xFB30;
 t['aleffinalarabic'] = 0xFE8E;
 t['alefhamzaabovearabic'] = 0x0623;
 t['alefhamzaabovefinalarabic'] = 0xFE84;
 t['alefhamzabelowarabic'] = 0x0625;
 t['alefhamzabelowfinalarabic'] = 0xFE88;
 t['alefhebrew'] = 0x05D0;
 t['aleflamedhebrew'] = 0xFB4F;
 t['alefmaddaabovearabic'] = 0x0622;
 t['alefmaddaabovefinalarabic'] = 0xFE82;
 t['alefmaksuraarabic'] = 0x0649;
 t['alefmaksurafinalarabic'] = 0xFEF0;
 t['alefmaksurainitialarabic'] = 0xFEF3;
 t['alefmaksuramedialarabic'] = 0xFEF4;
 t['alefpatahhebrew'] = 0xFB2E;
 t['alefqamatshebrew'] = 0xFB2F;
 t['aleph'] = 0x2135;
 t['allequal'] = 0x224C;
 t['alpha'] = 0x03B1;
 t['alphatonos'] = 0x03AC;
 t['amacron'] = 0x0101;
 t['amonospace'] = 0xFF41;
 t['ampersand'] = 0x0026;
 t['ampersandmonospace'] = 0xFF06;
 t['ampersandsmall'] = 0xF726;
 t['amsquare'] = 0x33C2;
 t['anbopomofo'] = 0x3122;
 t['angbopomofo'] = 0x3124;
 t['angbracketleft'] = 0x3008;
 t['angbracketright'] = 0x3009;
 t['angkhankhuthai'] = 0x0E5A;
 t['angle'] = 0x2220;
 t['anglebracketleft'] = 0x3008;
 t['anglebracketleftvertical'] = 0xFE3F;
 t['anglebracketright'] = 0x3009;
 t['anglebracketrightvertical'] = 0xFE40;
 t['angleleft'] = 0x2329;
 t['angleright'] = 0x232A;
 t['angstrom'] = 0x212B;
 t['anoteleia'] = 0x0387;
 t['anudattadeva'] = 0x0952;
 t['anusvarabengali'] = 0x0982;
 t['anusvaradeva'] = 0x0902;
 t['anusvaragujarati'] = 0x0A82;
 t['aogonek'] = 0x0105;
 t['apaatosquare'] = 0x3300;
 t['aparen'] = 0x249C;
 t['apostrophearmenian'] = 0x055A;
 t['apostrophemod'] = 0x02BC;
 t['apple'] = 0xF8FF;
 t['approaches'] = 0x2250;
 t['approxequal'] = 0x2248;
 t['approxequalorimage'] = 0x2252;
 t['approximatelyequal'] = 0x2245;
 t['araeaekorean'] = 0x318E;
 t['araeakorean'] = 0x318D;
 t['arc'] = 0x2312;
 t['arighthalfring'] = 0x1E9A;
 t['aring'] = 0x00E5;
 t['aringacute'] = 0x01FB;
 t['aringbelow'] = 0x1E01;
 t['arrowboth'] = 0x2194;
 t['arrowdashdown'] = 0x21E3;
 t['arrowdashleft'] = 0x21E0;
 t['arrowdashright'] = 0x21E2;
 t['arrowdashup'] = 0x21E1;
 t['arrowdblboth'] = 0x21D4;
 t['arrowdbldown'] = 0x21D3;
 t['arrowdblleft'] = 0x21D0;
 t['arrowdblright'] = 0x21D2;
 t['arrowdblup'] = 0x21D1;
 t['arrowdown'] = 0x2193;
 t['arrowdownleft'] = 0x2199;
 t['arrowdownright'] = 0x2198;
 t['arrowdownwhite'] = 0x21E9;
 t['arrowheaddownmod'] = 0x02C5;
 t['arrowheadleftmod'] = 0x02C2;
 t['arrowheadrightmod'] = 0x02C3;
 t['arrowheadupmod'] = 0x02C4;
 t['arrowhorizex'] = 0xF8E7;
 t['arrowleft'] = 0x2190;
 t['arrowleftdbl'] = 0x21D0;
 t['arrowleftdblstroke'] = 0x21CD;
 t['arrowleftoverright'] = 0x21C6;
 t['arrowleftwhite'] = 0x21E6;
 t['arrowright'] = 0x2192;
 t['arrowrightdblstroke'] = 0x21CF;
 t['arrowrightheavy'] = 0x279E;
 t['arrowrightoverleft'] = 0x21C4;
 t['arrowrightwhite'] = 0x21E8;
 t['arrowtableft'] = 0x21E4;
 t['arrowtabright'] = 0x21E5;
 t['arrowup'] = 0x2191;
 t['arrowupdn'] = 0x2195;
 t['arrowupdnbse'] = 0x21A8;
 t['arrowupdownbase'] = 0x21A8;
 t['arrowupleft'] = 0x2196;
 t['arrowupleftofdown'] = 0x21C5;
 t['arrowupright'] = 0x2197;
 t['arrowupwhite'] = 0x21E7;
 t['arrowvertex'] = 0xF8E6;
 t['asciicircum'] = 0x005E;
 t['asciicircummonospace'] = 0xFF3E;
 t['asciitilde'] = 0x007E;
 t['asciitildemonospace'] = 0xFF5E;
 t['ascript'] = 0x0251;
 t['ascriptturned'] = 0x0252;
 t['asmallhiragana'] = 0x3041;
 t['asmallkatakana'] = 0x30A1;
 t['asmallkatakanahalfwidth'] = 0xFF67;
 t['asterisk'] = 0x002A;
 t['asteriskaltonearabic'] = 0x066D;
 t['asteriskarabic'] = 0x066D;
 t['asteriskmath'] = 0x2217;
 t['asteriskmonospace'] = 0xFF0A;
 t['asterisksmall'] = 0xFE61;
 t['asterism'] = 0x2042;
 t['asuperior'] = 0xF6E9;
 t['asymptoticallyequal'] = 0x2243;
 t['at'] = 0x0040;
 t['atilde'] = 0x00E3;
 t['atmonospace'] = 0xFF20;
 t['atsmall'] = 0xFE6B;
 t['aturned'] = 0x0250;
 t['aubengali'] = 0x0994;
 t['aubopomofo'] = 0x3120;
 t['audeva'] = 0x0914;
 t['augujarati'] = 0x0A94;
 t['augurmukhi'] = 0x0A14;
 t['aulengthmarkbengali'] = 0x09D7;
 t['aumatragurmukhi'] = 0x0A4C;
 t['auvowelsignbengali'] = 0x09CC;
 t['auvowelsigndeva'] = 0x094C;
 t['auvowelsigngujarati'] = 0x0ACC;
 t['avagrahadeva'] = 0x093D;
 t['aybarmenian'] = 0x0561;
 t['ayin'] = 0x05E2;
 t['ayinaltonehebrew'] = 0xFB20;
 t['ayinhebrew'] = 0x05E2;
 t['b'] = 0x0062;
 t['babengali'] = 0x09AC;
 t['backslash'] = 0x005C;
 t['backslashmonospace'] = 0xFF3C;
 t['badeva'] = 0x092C;
 t['bagujarati'] = 0x0AAC;
 t['bagurmukhi'] = 0x0A2C;
 t['bahiragana'] = 0x3070;
 t['bahtthai'] = 0x0E3F;
 t['bakatakana'] = 0x30D0;
 t['bar'] = 0x007C;
 t['barmonospace'] = 0xFF5C;
 t['bbopomofo'] = 0x3105;
 t['bcircle'] = 0x24D1;
 t['bdotaccent'] = 0x1E03;
 t['bdotbelow'] = 0x1E05;
 t['beamedsixteenthnotes'] = 0x266C;
 t['because'] = 0x2235;
 t['becyrillic'] = 0x0431;
 t['beharabic'] = 0x0628;
 t['behfinalarabic'] = 0xFE90;
 t['behinitialarabic'] = 0xFE91;
 t['behiragana'] = 0x3079;
 t['behmedialarabic'] = 0xFE92;
 t['behmeeminitialarabic'] = 0xFC9F;
 t['behmeemisolatedarabic'] = 0xFC08;
 t['behnoonfinalarabic'] = 0xFC6D;
 t['bekatakana'] = 0x30D9;
 t['benarmenian'] = 0x0562;
 t['bet'] = 0x05D1;
 t['beta'] = 0x03B2;
 t['betasymbolgreek'] = 0x03D0;
 t['betdagesh'] = 0xFB31;
 t['betdageshhebrew'] = 0xFB31;
 t['bethebrew'] = 0x05D1;
 t['betrafehebrew'] = 0xFB4C;
 t['bhabengali'] = 0x09AD;
 t['bhadeva'] = 0x092D;
 t['bhagujarati'] = 0x0AAD;
 t['bhagurmukhi'] = 0x0A2D;
 t['bhook'] = 0x0253;
 t['bihiragana'] = 0x3073;
 t['bikatakana'] = 0x30D3;
 t['bilabialclick'] = 0x0298;
 t['bindigurmukhi'] = 0x0A02;
 t['birusquare'] = 0x3331;
 t['blackcircle'] = 0x25CF;
 t['blackdiamond'] = 0x25C6;
 t['blackdownpointingtriangle'] = 0x25BC;
 t['blackleftpointingpointer'] = 0x25C4;
 t['blackleftpointingtriangle'] = 0x25C0;
 t['blacklenticularbracketleft'] = 0x3010;
 t['blacklenticularbracketleftvertical'] = 0xFE3B;
 t['blacklenticularbracketright'] = 0x3011;
 t['blacklenticularbracketrightvertical'] = 0xFE3C;
 t['blacklowerlefttriangle'] = 0x25E3;
 t['blacklowerrighttriangle'] = 0x25E2;
 t['blackrectangle'] = 0x25AC;
 t['blackrightpointingpointer'] = 0x25BA;
 t['blackrightpointingtriangle'] = 0x25B6;
 t['blacksmallsquare'] = 0x25AA;
 t['blacksmilingface'] = 0x263B;
 t['blacksquare'] = 0x25A0;
 t['blackstar'] = 0x2605;
 t['blackupperlefttriangle'] = 0x25E4;
 t['blackupperrighttriangle'] = 0x25E5;
 t['blackuppointingsmalltriangle'] = 0x25B4;
 t['blackuppointingtriangle'] = 0x25B2;
 t['blank'] = 0x2423;
 t['blinebelow'] = 0x1E07;
 t['block'] = 0x2588;
 t['bmonospace'] = 0xFF42;
 t['bobaimaithai'] = 0x0E1A;
 t['bohiragana'] = 0x307C;
 t['bokatakana'] = 0x30DC;
 t['bparen'] = 0x249D;
 t['bqsquare'] = 0x33C3;
 t['braceex'] = 0xF8F4;
 t['braceleft'] = 0x007B;
 t['braceleftbt'] = 0xF8F3;
 t['braceleftmid'] = 0xF8F2;
 t['braceleftmonospace'] = 0xFF5B;
 t['braceleftsmall'] = 0xFE5B;
 t['bracelefttp'] = 0xF8F1;
 t['braceleftvertical'] = 0xFE37;
 t['braceright'] = 0x007D;
 t['bracerightbt'] = 0xF8FE;
 t['bracerightmid'] = 0xF8FD;
 t['bracerightmonospace'] = 0xFF5D;
 t['bracerightsmall'] = 0xFE5C;
 t['bracerighttp'] = 0xF8FC;
 t['bracerightvertical'] = 0xFE38;
 t['bracketleft'] = 0x005B;
 t['bracketleftbt'] = 0xF8F0;
 t['bracketleftex'] = 0xF8EF;
 t['bracketleftmonospace'] = 0xFF3B;
 t['bracketlefttp'] = 0xF8EE;
 t['bracketright'] = 0x005D;
 t['bracketrightbt'] = 0xF8FB;
 t['bracketrightex'] = 0xF8FA;
 t['bracketrightmonospace'] = 0xFF3D;
 t['bracketrighttp'] = 0xF8F9;
 t['breve'] = 0x02D8;
 t['brevebelowcmb'] = 0x032E;
 t['brevecmb'] = 0x0306;
 t['breveinvertedbelowcmb'] = 0x032F;
 t['breveinvertedcmb'] = 0x0311;
 t['breveinverteddoublecmb'] = 0x0361;
 t['bridgebelowcmb'] = 0x032A;
 t['bridgeinvertedbelowcmb'] = 0x033A;
 t['brokenbar'] = 0x00A6;
 t['bstroke'] = 0x0180;
 t['bsuperior'] = 0xF6EA;
 t['btopbar'] = 0x0183;
 t['buhiragana'] = 0x3076;
 t['bukatakana'] = 0x30D6;
 t['bullet'] = 0x2022;
 t['bulletinverse'] = 0x25D8;
 t['bulletoperator'] = 0x2219;
 t['bullseye'] = 0x25CE;
 t['c'] = 0x0063;
 t['caarmenian'] = 0x056E;
 t['cabengali'] = 0x099A;
 t['cacute'] = 0x0107;
 t['cadeva'] = 0x091A;
 t['cagujarati'] = 0x0A9A;
 t['cagurmukhi'] = 0x0A1A;
 t['calsquare'] = 0x3388;
 t['candrabindubengali'] = 0x0981;
 t['candrabinducmb'] = 0x0310;
 t['candrabindudeva'] = 0x0901;
 t['candrabindugujarati'] = 0x0A81;
 t['capslock'] = 0x21EA;
 t['careof'] = 0x2105;
 t['caron'] = 0x02C7;
 t['caronbelowcmb'] = 0x032C;
 t['caroncmb'] = 0x030C;
 t['carriagereturn'] = 0x21B5;
 t['cbopomofo'] = 0x3118;
 t['ccaron'] = 0x010D;
 t['ccedilla'] = 0x00E7;
 t['ccedillaacute'] = 0x1E09;
 t['ccircle'] = 0x24D2;
 t['ccircumflex'] = 0x0109;
 t['ccurl'] = 0x0255;
 t['cdot'] = 0x010B;
 t['cdotaccent'] = 0x010B;
 t['cdsquare'] = 0x33C5;
 t['cedilla'] = 0x00B8;
 t['cedillacmb'] = 0x0327;
 t['cent'] = 0x00A2;
 t['centigrade'] = 0x2103;
 t['centinferior'] = 0xF6DF;
 t['centmonospace'] = 0xFFE0;
 t['centoldstyle'] = 0xF7A2;
 t['centsuperior'] = 0xF6E0;
 t['chaarmenian'] = 0x0579;
 t['chabengali'] = 0x099B;
 t['chadeva'] = 0x091B;
 t['chagujarati'] = 0x0A9B;
 t['chagurmukhi'] = 0x0A1B;
 t['chbopomofo'] = 0x3114;
 t['cheabkhasiancyrillic'] = 0x04BD;
 t['checkmark'] = 0x2713;
 t['checyrillic'] = 0x0447;
 t['chedescenderabkhasiancyrillic'] = 0x04BF;
 t['chedescendercyrillic'] = 0x04B7;
 t['chedieresiscyrillic'] = 0x04F5;
 t['cheharmenian'] = 0x0573;
 t['chekhakassiancyrillic'] = 0x04CC;
 t['cheverticalstrokecyrillic'] = 0x04B9;
 t['chi'] = 0x03C7;
 t['chieuchacirclekorean'] = 0x3277;
 t['chieuchaparenkorean'] = 0x3217;
 t['chieuchcirclekorean'] = 0x3269;
 t['chieuchkorean'] = 0x314A;
 t['chieuchparenkorean'] = 0x3209;
 t['chochangthai'] = 0x0E0A;
 t['chochanthai'] = 0x0E08;
 t['chochingthai'] = 0x0E09;
 t['chochoethai'] = 0x0E0C;
 t['chook'] = 0x0188;
 t['cieucacirclekorean'] = 0x3276;
 t['cieucaparenkorean'] = 0x3216;
 t['cieuccirclekorean'] = 0x3268;
 t['cieuckorean'] = 0x3148;
 t['cieucparenkorean'] = 0x3208;
 t['cieucuparenkorean'] = 0x321C;
 t['circle'] = 0x25CB;
 t['circlecopyrt'] = 0x00A9;
 t['circlemultiply'] = 0x2297;
 t['circleot'] = 0x2299;
 t['circleplus'] = 0x2295;
 t['circlepostalmark'] = 0x3036;
 t['circlewithlefthalfblack'] = 0x25D0;
 t['circlewithrighthalfblack'] = 0x25D1;
 t['circumflex'] = 0x02C6;
 t['circumflexbelowcmb'] = 0x032D;
 t['circumflexcmb'] = 0x0302;
 t['clear'] = 0x2327;
 t['clickalveolar'] = 0x01C2;
 t['clickdental'] = 0x01C0;
 t['clicklateral'] = 0x01C1;
 t['clickretroflex'] = 0x01C3;
 t['club'] = 0x2663;
 t['clubsuitblack'] = 0x2663;
 t['clubsuitwhite'] = 0x2667;
 t['cmcubedsquare'] = 0x33A4;
 t['cmonospace'] = 0xFF43;
 t['cmsquaredsquare'] = 0x33A0;
 t['coarmenian'] = 0x0581;
 t['colon'] = 0x003A;
 t['colonmonetary'] = 0x20A1;
 t['colonmonospace'] = 0xFF1A;
 t['colonsign'] = 0x20A1;
 t['colonsmall'] = 0xFE55;
 t['colontriangularhalfmod'] = 0x02D1;
 t['colontriangularmod'] = 0x02D0;
 t['comma'] = 0x002C;
 t['commaabovecmb'] = 0x0313;
 t['commaaboverightcmb'] = 0x0315;
 t['commaaccent'] = 0xF6C3;
 t['commaarabic'] = 0x060C;
 t['commaarmenian'] = 0x055D;
 t['commainferior'] = 0xF6E1;
 t['commamonospace'] = 0xFF0C;
 t['commareversedabovecmb'] = 0x0314;
 t['commareversedmod'] = 0x02BD;
 t['commasmall'] = 0xFE50;
 t['commasuperior'] = 0xF6E2;
 t['commaturnedabovecmb'] = 0x0312;
 t['commaturnedmod'] = 0x02BB;
 t['compass'] = 0x263C;
 t['congruent'] = 0x2245;
 t['contourintegral'] = 0x222E;
 t['control'] = 0x2303;
 t['controlACK'] = 0x0006;
 t['controlBEL'] = 0x0007;
 t['controlBS'] = 0x0008;
 t['controlCAN'] = 0x0018;
 t['controlCR'] = 0x000D;
 t['controlDC1'] = 0x0011;
 t['controlDC2'] = 0x0012;
 t['controlDC3'] = 0x0013;
 t['controlDC4'] = 0x0014;
 t['controlDEL'] = 0x007F;
 t['controlDLE'] = 0x0010;
 t['controlEM'] = 0x0019;
 t['controlENQ'] = 0x0005;
 t['controlEOT'] = 0x0004;
 t['controlESC'] = 0x001B;
 t['controlETB'] = 0x0017;
 t['controlETX'] = 0x0003;
 t['controlFF'] = 0x000C;
 t['controlFS'] = 0x001C;
 t['controlGS'] = 0x001D;
 t['controlHT'] = 0x0009;
 t['controlLF'] = 0x000A;
 t['controlNAK'] = 0x0015;
 t['controlNULL'] = 0x0000;
 t['controlRS'] = 0x001E;
 t['controlSI'] = 0x000F;
 t['controlSO'] = 0x000E;
 t['controlSOT'] = 0x0002;
 t['controlSTX'] = 0x0001;
 t['controlSUB'] = 0x001A;
 t['controlSYN'] = 0x0016;
 t['controlUS'] = 0x001F;
 t['controlVT'] = 0x000B;
 t['copyright'] = 0x00A9;
 t['copyrightsans'] = 0xF8E9;
 t['copyrightserif'] = 0xF6D9;
 t['cornerbracketleft'] = 0x300C;
 t['cornerbracketlefthalfwidth'] = 0xFF62;
 t['cornerbracketleftvertical'] = 0xFE41;
 t['cornerbracketright'] = 0x300D;
 t['cornerbracketrighthalfwidth'] = 0xFF63;
 t['cornerbracketrightvertical'] = 0xFE42;
 t['corporationsquare'] = 0x337F;
 t['cosquare'] = 0x33C7;
 t['coverkgsquare'] = 0x33C6;
 t['cparen'] = 0x249E;
 t['cruzeiro'] = 0x20A2;
 t['cstretched'] = 0x0297;
 t['curlyand'] = 0x22CF;
 t['curlyor'] = 0x22CE;
 t['currency'] = 0x00A4;
 t['cyrBreve'] = 0xF6D1;
 t['cyrFlex'] = 0xF6D2;
 t['cyrbreve'] = 0xF6D4;
 t['cyrflex'] = 0xF6D5;
 t['d'] = 0x0064;
 t['daarmenian'] = 0x0564;
 t['dabengali'] = 0x09A6;
 t['dadarabic'] = 0x0636;
 t['dadeva'] = 0x0926;
 t['dadfinalarabic'] = 0xFEBE;
 t['dadinitialarabic'] = 0xFEBF;
 t['dadmedialarabic'] = 0xFEC0;
 t['dagesh'] = 0x05BC;
 t['dageshhebrew'] = 0x05BC;
 t['dagger'] = 0x2020;
 t['daggerdbl'] = 0x2021;
 t['dagujarati'] = 0x0AA6;
 t['dagurmukhi'] = 0x0A26;
 t['dahiragana'] = 0x3060;
 t['dakatakana'] = 0x30C0;
 t['dalarabic'] = 0x062F;
 t['dalet'] = 0x05D3;
 t['daletdagesh'] = 0xFB33;
 t['daletdageshhebrew'] = 0xFB33;
 t['dalethebrew'] = 0x05D3;
 t['dalfinalarabic'] = 0xFEAA;
 t['dammaarabic'] = 0x064F;
 t['dammalowarabic'] = 0x064F;
 t['dammatanaltonearabic'] = 0x064C;
 t['dammatanarabic'] = 0x064C;
 t['danda'] = 0x0964;
 t['dargahebrew'] = 0x05A7;
 t['dargalefthebrew'] = 0x05A7;
 t['dasiapneumatacyrilliccmb'] = 0x0485;
 t['dblGrave'] = 0xF6D3;
 t['dblanglebracketleft'] = 0x300A;
 t['dblanglebracketleftvertical'] = 0xFE3D;
 t['dblanglebracketright'] = 0x300B;
 t['dblanglebracketrightvertical'] = 0xFE3E;
 t['dblarchinvertedbelowcmb'] = 0x032B;
 t['dblarrowleft'] = 0x21D4;
 t['dblarrowright'] = 0x21D2;
 t['dbldanda'] = 0x0965;
 t['dblgrave'] = 0xF6D6;
 t['dblgravecmb'] = 0x030F;
 t['dblintegral'] = 0x222C;
 t['dbllowline'] = 0x2017;
 t['dbllowlinecmb'] = 0x0333;
 t['dbloverlinecmb'] = 0x033F;
 t['dblprimemod'] = 0x02BA;
 t['dblverticalbar'] = 0x2016;
 t['dblverticallineabovecmb'] = 0x030E;
 t['dbopomofo'] = 0x3109;
 t['dbsquare'] = 0x33C8;
 t['dcaron'] = 0x010F;
 t['dcedilla'] = 0x1E11;
 t['dcircle'] = 0x24D3;
 t['dcircumflexbelow'] = 0x1E13;
 t['dcroat'] = 0x0111;
 t['ddabengali'] = 0x09A1;
 t['ddadeva'] = 0x0921;
 t['ddagujarati'] = 0x0AA1;
 t['ddagurmukhi'] = 0x0A21;
 t['ddalarabic'] = 0x0688;
 t['ddalfinalarabic'] = 0xFB89;
 t['dddhadeva'] = 0x095C;
 t['ddhabengali'] = 0x09A2;
 t['ddhadeva'] = 0x0922;
 t['ddhagujarati'] = 0x0AA2;
 t['ddhagurmukhi'] = 0x0A22;
 t['ddotaccent'] = 0x1E0B;
 t['ddotbelow'] = 0x1E0D;
 t['decimalseparatorarabic'] = 0x066B;
 t['decimalseparatorpersian'] = 0x066B;
 t['decyrillic'] = 0x0434;
 t['degree'] = 0x00B0;
 t['dehihebrew'] = 0x05AD;
 t['dehiragana'] = 0x3067;
 t['deicoptic'] = 0x03EF;
 t['dekatakana'] = 0x30C7;
 t['deleteleft'] = 0x232B;
 t['deleteright'] = 0x2326;
 t['delta'] = 0x03B4;
 t['deltaturned'] = 0x018D;
 t['denominatorminusonenumeratorbengali'] = 0x09F8;
 t['dezh'] = 0x02A4;
 t['dhabengali'] = 0x09A7;
 t['dhadeva'] = 0x0927;
 t['dhagujarati'] = 0x0AA7;
 t['dhagurmukhi'] = 0x0A27;
 t['dhook'] = 0x0257;
 t['dialytikatonos'] = 0x0385;
 t['dialytikatonoscmb'] = 0x0344;
 t['diamond'] = 0x2666;
 t['diamondsuitwhite'] = 0x2662;
 t['dieresis'] = 0x00A8;
 t['dieresisacute'] = 0xF6D7;
 t['dieresisbelowcmb'] = 0x0324;
 t['dieresiscmb'] = 0x0308;
 t['dieresisgrave'] = 0xF6D8;
 t['dieresistonos'] = 0x0385;
 t['dihiragana'] = 0x3062;
 t['dikatakana'] = 0x30C2;
 t['dittomark'] = 0x3003;
 t['divide'] = 0x00F7;
 t['divides'] = 0x2223;
 t['divisionslash'] = 0x2215;
 t['djecyrillic'] = 0x0452;
 t['dkshade'] = 0x2593;
 t['dlinebelow'] = 0x1E0F;
 t['dlsquare'] = 0x3397;
 t['dmacron'] = 0x0111;
 t['dmonospace'] = 0xFF44;
 t['dnblock'] = 0x2584;
 t['dochadathai'] = 0x0E0E;
 t['dodekthai'] = 0x0E14;
 t['dohiragana'] = 0x3069;
 t['dokatakana'] = 0x30C9;
 t['dollar'] = 0x0024;
 t['dollarinferior'] = 0xF6E3;
 t['dollarmonospace'] = 0xFF04;
 t['dollaroldstyle'] = 0xF724;
 t['dollarsmall'] = 0xFE69;
 t['dollarsuperior'] = 0xF6E4;
 t['dong'] = 0x20AB;
 t['dorusquare'] = 0x3326;
 t['dotaccent'] = 0x02D9;
 t['dotaccentcmb'] = 0x0307;
 t['dotbelowcmb'] = 0x0323;
 t['dotbelowcomb'] = 0x0323;
 t['dotkatakana'] = 0x30FB;
 t['dotlessi'] = 0x0131;
 t['dotlessj'] = 0xF6BE;
 t['dotlessjstrokehook'] = 0x0284;
 t['dotmath'] = 0x22C5;
 t['dottedcircle'] = 0x25CC;
 t['doubleyodpatah'] = 0xFB1F;
 t['doubleyodpatahhebrew'] = 0xFB1F;
 t['downtackbelowcmb'] = 0x031E;
 t['downtackmod'] = 0x02D5;
 t['dparen'] = 0x249F;
 t['dsuperior'] = 0xF6EB;
 t['dtail'] = 0x0256;
 t['dtopbar'] = 0x018C;
 t['duhiragana'] = 0x3065;
 t['dukatakana'] = 0x30C5;
 t['dz'] = 0x01F3;
 t['dzaltone'] = 0x02A3;
 t['dzcaron'] = 0x01C6;
 t['dzcurl'] = 0x02A5;
 t['dzeabkhasiancyrillic'] = 0x04E1;
 t['dzecyrillic'] = 0x0455;
 t['dzhecyrillic'] = 0x045F;
 t['e'] = 0x0065;
 t['eacute'] = 0x00E9;
 t['earth'] = 0x2641;
 t['ebengali'] = 0x098F;
 t['ebopomofo'] = 0x311C;
 t['ebreve'] = 0x0115;
 t['ecandradeva'] = 0x090D;
 t['ecandragujarati'] = 0x0A8D;
 t['ecandravowelsigndeva'] = 0x0945;
 t['ecandravowelsigngujarati'] = 0x0AC5;
 t['ecaron'] = 0x011B;
 t['ecedillabreve'] = 0x1E1D;
 t['echarmenian'] = 0x0565;
 t['echyiwnarmenian'] = 0x0587;
 t['ecircle'] = 0x24D4;
 t['ecircumflex'] = 0x00EA;
 t['ecircumflexacute'] = 0x1EBF;
 t['ecircumflexbelow'] = 0x1E19;
 t['ecircumflexdotbelow'] = 0x1EC7;
 t['ecircumflexgrave'] = 0x1EC1;
 t['ecircumflexhookabove'] = 0x1EC3;
 t['ecircumflextilde'] = 0x1EC5;
 t['ecyrillic'] = 0x0454;
 t['edblgrave'] = 0x0205;
 t['edeva'] = 0x090F;
 t['edieresis'] = 0x00EB;
 t['edot'] = 0x0117;
 t['edotaccent'] = 0x0117;
 t['edotbelow'] = 0x1EB9;
 t['eegurmukhi'] = 0x0A0F;
 t['eematragurmukhi'] = 0x0A47;
 t['efcyrillic'] = 0x0444;
 t['egrave'] = 0x00E8;
 t['egujarati'] = 0x0A8F;
 t['eharmenian'] = 0x0567;
 t['ehbopomofo'] = 0x311D;
 t['ehiragana'] = 0x3048;
 t['ehookabove'] = 0x1EBB;
 t['eibopomofo'] = 0x311F;
 t['eight'] = 0x0038;
 t['eightarabic'] = 0x0668;
 t['eightbengali'] = 0x09EE;
 t['eightcircle'] = 0x2467;
 t['eightcircleinversesansserif'] = 0x2791;
 t['eightdeva'] = 0x096E;
 t['eighteencircle'] = 0x2471;
 t['eighteenparen'] = 0x2485;
 t['eighteenperiod'] = 0x2499;
 t['eightgujarati'] = 0x0AEE;
 t['eightgurmukhi'] = 0x0A6E;
 t['eighthackarabic'] = 0x0668;
 t['eighthangzhou'] = 0x3028;
 t['eighthnotebeamed'] = 0x266B;
 t['eightideographicparen'] = 0x3227;
 t['eightinferior'] = 0x2088;
 t['eightmonospace'] = 0xFF18;
 t['eightoldstyle'] = 0xF738;
 t['eightparen'] = 0x247B;
 t['eightperiod'] = 0x248F;
 t['eightpersian'] = 0x06F8;
 t['eightroman'] = 0x2177;
 t['eightsuperior'] = 0x2078;
 t['eightthai'] = 0x0E58;
 t['einvertedbreve'] = 0x0207;
 t['eiotifiedcyrillic'] = 0x0465;
 t['ekatakana'] = 0x30A8;
 t['ekatakanahalfwidth'] = 0xFF74;
 t['ekonkargurmukhi'] = 0x0A74;
 t['ekorean'] = 0x3154;
 t['elcyrillic'] = 0x043B;
 t['element'] = 0x2208;
 t['elevencircle'] = 0x246A;
 t['elevenparen'] = 0x247E;
 t['elevenperiod'] = 0x2492;
 t['elevenroman'] = 0x217A;
 t['ellipsis'] = 0x2026;
 t['ellipsisvertical'] = 0x22EE;
 t['emacron'] = 0x0113;
 t['emacronacute'] = 0x1E17;
 t['emacrongrave'] = 0x1E15;
 t['emcyrillic'] = 0x043C;
 t['emdash'] = 0x2014;
 t['emdashvertical'] = 0xFE31;
 t['emonospace'] = 0xFF45;
 t['emphasismarkarmenian'] = 0x055B;
 t['emptyset'] = 0x2205;
 t['enbopomofo'] = 0x3123;
 t['encyrillic'] = 0x043D;
 t['endash'] = 0x2013;
 t['endashvertical'] = 0xFE32;
 t['endescendercyrillic'] = 0x04A3;
 t['eng'] = 0x014B;
 t['engbopomofo'] = 0x3125;
 t['enghecyrillic'] = 0x04A5;
 t['enhookcyrillic'] = 0x04C8;
 t['enspace'] = 0x2002;
 t['eogonek'] = 0x0119;
 t['eokorean'] = 0x3153;
 t['eopen'] = 0x025B;
 t['eopenclosed'] = 0x029A;
 t['eopenreversed'] = 0x025C;
 t['eopenreversedclosed'] = 0x025E;
 t['eopenreversedhook'] = 0x025D;
 t['eparen'] = 0x24A0;
 t['epsilon'] = 0x03B5;
 t['epsilontonos'] = 0x03AD;
 t['equal'] = 0x003D;
 t['equalmonospace'] = 0xFF1D;
 t['equalsmall'] = 0xFE66;
 t['equalsuperior'] = 0x207C;
 t['equivalence'] = 0x2261;
 t['erbopomofo'] = 0x3126;
 t['ercyrillic'] = 0x0440;
 t['ereversed'] = 0x0258;
 t['ereversedcyrillic'] = 0x044D;
 t['escyrillic'] = 0x0441;
 t['esdescendercyrillic'] = 0x04AB;
 t['esh'] = 0x0283;
 t['eshcurl'] = 0x0286;
 t['eshortdeva'] = 0x090E;
 t['eshortvowelsigndeva'] = 0x0946;
 t['eshreversedloop'] = 0x01AA;
 t['eshsquatreversed'] = 0x0285;
 t['esmallhiragana'] = 0x3047;
 t['esmallkatakana'] = 0x30A7;
 t['esmallkatakanahalfwidth'] = 0xFF6A;
 t['estimated'] = 0x212E;
 t['esuperior'] = 0xF6EC;
 t['eta'] = 0x03B7;
 t['etarmenian'] = 0x0568;
 t['etatonos'] = 0x03AE;
 t['eth'] = 0x00F0;
 t['etilde'] = 0x1EBD;
 t['etildebelow'] = 0x1E1B;
 t['etnahtafoukhhebrew'] = 0x0591;
 t['etnahtafoukhlefthebrew'] = 0x0591;
 t['etnahtahebrew'] = 0x0591;
 t['etnahtalefthebrew'] = 0x0591;
 t['eturned'] = 0x01DD;
 t['eukorean'] = 0x3161;
 t['euro'] = 0x20AC;
 t['evowelsignbengali'] = 0x09C7;
 t['evowelsigndeva'] = 0x0947;
 t['evowelsigngujarati'] = 0x0AC7;
 t['exclam'] = 0x0021;
 t['exclamarmenian'] = 0x055C;
 t['exclamdbl'] = 0x203C;
 t['exclamdown'] = 0x00A1;
 t['exclamdownsmall'] = 0xF7A1;
 t['exclammonospace'] = 0xFF01;
 t['exclamsmall'] = 0xF721;
 t['existential'] = 0x2203;
 t['ezh'] = 0x0292;
 t['ezhcaron'] = 0x01EF;
 t['ezhcurl'] = 0x0293;
 t['ezhreversed'] = 0x01B9;
 t['ezhtail'] = 0x01BA;
 t['f'] = 0x0066;
 t['fadeva'] = 0x095E;
 t['fagurmukhi'] = 0x0A5E;
 t['fahrenheit'] = 0x2109;
 t['fathaarabic'] = 0x064E;
 t['fathalowarabic'] = 0x064E;
 t['fathatanarabic'] = 0x064B;
 t['fbopomofo'] = 0x3108;
 t['fcircle'] = 0x24D5;
 t['fdotaccent'] = 0x1E1F;
 t['feharabic'] = 0x0641;
 t['feharmenian'] = 0x0586;
 t['fehfinalarabic'] = 0xFED2;
 t['fehinitialarabic'] = 0xFED3;
 t['fehmedialarabic'] = 0xFED4;
 t['feicoptic'] = 0x03E5;
 t['female'] = 0x2640;
 t['ff'] = 0xFB00;
 t['ffi'] = 0xFB03;
 t['ffl'] = 0xFB04;
 t['fi'] = 0xFB01;
 t['fifteencircle'] = 0x246E;
 t['fifteenparen'] = 0x2482;
 t['fifteenperiod'] = 0x2496;
 t['figuredash'] = 0x2012;
 t['filledbox'] = 0x25A0;
 t['filledrect'] = 0x25AC;
 t['finalkaf'] = 0x05DA;
 t['finalkafdagesh'] = 0xFB3A;
 t['finalkafdageshhebrew'] = 0xFB3A;
 t['finalkafhebrew'] = 0x05DA;
 t['finalmem'] = 0x05DD;
 t['finalmemhebrew'] = 0x05DD;
 t['finalnun'] = 0x05DF;
 t['finalnunhebrew'] = 0x05DF;
 t['finalpe'] = 0x05E3;
 t['finalpehebrew'] = 0x05E3;
 t['finaltsadi'] = 0x05E5;
 t['finaltsadihebrew'] = 0x05E5;
 t['firsttonechinese'] = 0x02C9;
 t['fisheye'] = 0x25C9;
 t['fitacyrillic'] = 0x0473;
 t['five'] = 0x0035;
 t['fivearabic'] = 0x0665;
 t['fivebengali'] = 0x09EB;
 t['fivecircle'] = 0x2464;
 t['fivecircleinversesansserif'] = 0x278E;
 t['fivedeva'] = 0x096B;
 t['fiveeighths'] = 0x215D;
 t['fivegujarati'] = 0x0AEB;
 t['fivegurmukhi'] = 0x0A6B;
 t['fivehackarabic'] = 0x0665;
 t['fivehangzhou'] = 0x3025;
 t['fiveideographicparen'] = 0x3224;
 t['fiveinferior'] = 0x2085;
 t['fivemonospace'] = 0xFF15;
 t['fiveoldstyle'] = 0xF735;
 t['fiveparen'] = 0x2478;
 t['fiveperiod'] = 0x248C;
 t['fivepersian'] = 0x06F5;
 t['fiveroman'] = 0x2174;
 t['fivesuperior'] = 0x2075;
 t['fivethai'] = 0x0E55;
 t['fl'] = 0xFB02;
 t['florin'] = 0x0192;
 t['fmonospace'] = 0xFF46;
 t['fmsquare'] = 0x3399;
 t['fofanthai'] = 0x0E1F;
 t['fofathai'] = 0x0E1D;
 t['fongmanthai'] = 0x0E4F;
 t['forall'] = 0x2200;
 t['four'] = 0x0034;
 t['fourarabic'] = 0x0664;
 t['fourbengali'] = 0x09EA;
 t['fourcircle'] = 0x2463;
 t['fourcircleinversesansserif'] = 0x278D;
 t['fourdeva'] = 0x096A;
 t['fourgujarati'] = 0x0AEA;
 t['fourgurmukhi'] = 0x0A6A;
 t['fourhackarabic'] = 0x0664;
 t['fourhangzhou'] = 0x3024;
 t['fourideographicparen'] = 0x3223;
 t['fourinferior'] = 0x2084;
 t['fourmonospace'] = 0xFF14;
 t['fournumeratorbengali'] = 0x09F7;
 t['fouroldstyle'] = 0xF734;
 t['fourparen'] = 0x2477;
 t['fourperiod'] = 0x248B;
 t['fourpersian'] = 0x06F4;
 t['fourroman'] = 0x2173;
 t['foursuperior'] = 0x2074;
 t['fourteencircle'] = 0x246D;
 t['fourteenparen'] = 0x2481;
 t['fourteenperiod'] = 0x2495;
 t['fourthai'] = 0x0E54;
 t['fourthtonechinese'] = 0x02CB;
 t['fparen'] = 0x24A1;
 t['fraction'] = 0x2044;
 t['franc'] = 0x20A3;
 t['g'] = 0x0067;
 t['gabengali'] = 0x0997;
 t['gacute'] = 0x01F5;
 t['gadeva'] = 0x0917;
 t['gafarabic'] = 0x06AF;
 t['gaffinalarabic'] = 0xFB93;
 t['gafinitialarabic'] = 0xFB94;
 t['gafmedialarabic'] = 0xFB95;
 t['gagujarati'] = 0x0A97;
 t['gagurmukhi'] = 0x0A17;
 t['gahiragana'] = 0x304C;
 t['gakatakana'] = 0x30AC;
 t['gamma'] = 0x03B3;
 t['gammalatinsmall'] = 0x0263;
 t['gammasuperior'] = 0x02E0;
 t['gangiacoptic'] = 0x03EB;
 t['gbopomofo'] = 0x310D;
 t['gbreve'] = 0x011F;
 t['gcaron'] = 0x01E7;
 t['gcedilla'] = 0x0123;
 t['gcircle'] = 0x24D6;
 t['gcircumflex'] = 0x011D;
 t['gcommaaccent'] = 0x0123;
 t['gdot'] = 0x0121;
 t['gdotaccent'] = 0x0121;
 t['gecyrillic'] = 0x0433;
 t['gehiragana'] = 0x3052;
 t['gekatakana'] = 0x30B2;
 t['geometricallyequal'] = 0x2251;
 t['gereshaccenthebrew'] = 0x059C;
 t['gereshhebrew'] = 0x05F3;
 t['gereshmuqdamhebrew'] = 0x059D;
 t['germandbls'] = 0x00DF;
 t['gershayimaccenthebrew'] = 0x059E;
 t['gershayimhebrew'] = 0x05F4;
 t['getamark'] = 0x3013;
 t['ghabengali'] = 0x0998;
 t['ghadarmenian'] = 0x0572;
 t['ghadeva'] = 0x0918;
 t['ghagujarati'] = 0x0A98;
 t['ghagurmukhi'] = 0x0A18;
 t['ghainarabic'] = 0x063A;
 t['ghainfinalarabic'] = 0xFECE;
 t['ghaininitialarabic'] = 0xFECF;
 t['ghainmedialarabic'] = 0xFED0;
 t['ghemiddlehookcyrillic'] = 0x0495;
 t['ghestrokecyrillic'] = 0x0493;
 t['gheupturncyrillic'] = 0x0491;
 t['ghhadeva'] = 0x095A;
 t['ghhagurmukhi'] = 0x0A5A;
 t['ghook'] = 0x0260;
 t['ghzsquare'] = 0x3393;
 t['gihiragana'] = 0x304E;
 t['gikatakana'] = 0x30AE;
 t['gimarmenian'] = 0x0563;
 t['gimel'] = 0x05D2;
 t['gimeldagesh'] = 0xFB32;
 t['gimeldageshhebrew'] = 0xFB32;
 t['gimelhebrew'] = 0x05D2;
 t['gjecyrillic'] = 0x0453;
 t['glottalinvertedstroke'] = 0x01BE;
 t['glottalstop'] = 0x0294;
 t['glottalstopinverted'] = 0x0296;
 t['glottalstopmod'] = 0x02C0;
 t['glottalstopreversed'] = 0x0295;
 t['glottalstopreversedmod'] = 0x02C1;
 t['glottalstopreversedsuperior'] = 0x02E4;
 t['glottalstopstroke'] = 0x02A1;
 t['glottalstopstrokereversed'] = 0x02A2;
 t['gmacron'] = 0x1E21;
 t['gmonospace'] = 0xFF47;
 t['gohiragana'] = 0x3054;
 t['gokatakana'] = 0x30B4;
 t['gparen'] = 0x24A2;
 t['gpasquare'] = 0x33AC;
 t['gradient'] = 0x2207;
 t['grave'] = 0x0060;
 t['gravebelowcmb'] = 0x0316;
 t['gravecmb'] = 0x0300;
 t['gravecomb'] = 0x0300;
 t['gravedeva'] = 0x0953;
 t['gravelowmod'] = 0x02CE;
 t['gravemonospace'] = 0xFF40;
 t['gravetonecmb'] = 0x0340;
 t['greater'] = 0x003E;
 t['greaterequal'] = 0x2265;
 t['greaterequalorless'] = 0x22DB;
 t['greatermonospace'] = 0xFF1E;
 t['greaterorequivalent'] = 0x2273;
 t['greaterorless'] = 0x2277;
 t['greateroverequal'] = 0x2267;
 t['greatersmall'] = 0xFE65;
 t['gscript'] = 0x0261;
 t['gstroke'] = 0x01E5;
 t['guhiragana'] = 0x3050;
 t['guillemotleft'] = 0x00AB;
 t['guillemotright'] = 0x00BB;
 t['guilsinglleft'] = 0x2039;
 t['guilsinglright'] = 0x203A;
 t['gukatakana'] = 0x30B0;
 t['guramusquare'] = 0x3318;
 t['gysquare'] = 0x33C9;
 t['h'] = 0x0068;
 t['haabkhasiancyrillic'] = 0x04A9;
 t['haaltonearabic'] = 0x06C1;
 t['habengali'] = 0x09B9;
 t['hadescendercyrillic'] = 0x04B3;
 t['hadeva'] = 0x0939;
 t['hagujarati'] = 0x0AB9;
 t['hagurmukhi'] = 0x0A39;
 t['haharabic'] = 0x062D;
 t['hahfinalarabic'] = 0xFEA2;
 t['hahinitialarabic'] = 0xFEA3;
 t['hahiragana'] = 0x306F;
 t['hahmedialarabic'] = 0xFEA4;
 t['haitusquare'] = 0x332A;
 t['hakatakana'] = 0x30CF;
 t['hakatakanahalfwidth'] = 0xFF8A;
 t['halantgurmukhi'] = 0x0A4D;
 t['hamzaarabic'] = 0x0621;
 t['hamzalowarabic'] = 0x0621;
 t['hangulfiller'] = 0x3164;
 t['hardsigncyrillic'] = 0x044A;
 t['harpoonleftbarbup'] = 0x21BC;
 t['harpoonrightbarbup'] = 0x21C0;
 t['hasquare'] = 0x33CA;
 t['hatafpatah'] = 0x05B2;
 t['hatafpatah16'] = 0x05B2;
 t['hatafpatah23'] = 0x05B2;
 t['hatafpatah2f'] = 0x05B2;
 t['hatafpatahhebrew'] = 0x05B2;
 t['hatafpatahnarrowhebrew'] = 0x05B2;
 t['hatafpatahquarterhebrew'] = 0x05B2;
 t['hatafpatahwidehebrew'] = 0x05B2;
 t['hatafqamats'] = 0x05B3;
 t['hatafqamats1b'] = 0x05B3;
 t['hatafqamats28'] = 0x05B3;
 t['hatafqamats34'] = 0x05B3;
 t['hatafqamatshebrew'] = 0x05B3;
 t['hatafqamatsnarrowhebrew'] = 0x05B3;
 t['hatafqamatsquarterhebrew'] = 0x05B3;
 t['hatafqamatswidehebrew'] = 0x05B3;
 t['hatafsegol'] = 0x05B1;
 t['hatafsegol17'] = 0x05B1;
 t['hatafsegol24'] = 0x05B1;
 t['hatafsegol30'] = 0x05B1;
 t['hatafsegolhebrew'] = 0x05B1;
 t['hatafsegolnarrowhebrew'] = 0x05B1;
 t['hatafsegolquarterhebrew'] = 0x05B1;
 t['hatafsegolwidehebrew'] = 0x05B1;
 t['hbar'] = 0x0127;
 t['hbopomofo'] = 0x310F;
 t['hbrevebelow'] = 0x1E2B;
 t['hcedilla'] = 0x1E29;
 t['hcircle'] = 0x24D7;
 t['hcircumflex'] = 0x0125;
 t['hdieresis'] = 0x1E27;
 t['hdotaccent'] = 0x1E23;
 t['hdotbelow'] = 0x1E25;
 t['he'] = 0x05D4;
 t['heart'] = 0x2665;
 t['heartsuitblack'] = 0x2665;
 t['heartsuitwhite'] = 0x2661;
 t['hedagesh'] = 0xFB34;
 t['hedageshhebrew'] = 0xFB34;
 t['hehaltonearabic'] = 0x06C1;
 t['heharabic'] = 0x0647;
 t['hehebrew'] = 0x05D4;
 t['hehfinalaltonearabic'] = 0xFBA7;
 t['hehfinalalttwoarabic'] = 0xFEEA;
 t['hehfinalarabic'] = 0xFEEA;
 t['hehhamzaabovefinalarabic'] = 0xFBA5;
 t['hehhamzaaboveisolatedarabic'] = 0xFBA4;
 t['hehinitialaltonearabic'] = 0xFBA8;
 t['hehinitialarabic'] = 0xFEEB;
 t['hehiragana'] = 0x3078;
 t['hehmedialaltonearabic'] = 0xFBA9;
 t['hehmedialarabic'] = 0xFEEC;
 t['heiseierasquare'] = 0x337B;
 t['hekatakana'] = 0x30D8;
 t['hekatakanahalfwidth'] = 0xFF8D;
 t['hekutaarusquare'] = 0x3336;
 t['henghook'] = 0x0267;
 t['herutusquare'] = 0x3339;
 t['het'] = 0x05D7;
 t['hethebrew'] = 0x05D7;
 t['hhook'] = 0x0266;
 t['hhooksuperior'] = 0x02B1;
 t['hieuhacirclekorean'] = 0x327B;
 t['hieuhaparenkorean'] = 0x321B;
 t['hieuhcirclekorean'] = 0x326D;
 t['hieuhkorean'] = 0x314E;
 t['hieuhparenkorean'] = 0x320D;
 t['hihiragana'] = 0x3072;
 t['hikatakana'] = 0x30D2;
 t['hikatakanahalfwidth'] = 0xFF8B;
 t['hiriq'] = 0x05B4;
 t['hiriq14'] = 0x05B4;
 t['hiriq21'] = 0x05B4;
 t['hiriq2d'] = 0x05B4;
 t['hiriqhebrew'] = 0x05B4;
 t['hiriqnarrowhebrew'] = 0x05B4;
 t['hiriqquarterhebrew'] = 0x05B4;
 t['hiriqwidehebrew'] = 0x05B4;
 t['hlinebelow'] = 0x1E96;
 t['hmonospace'] = 0xFF48;
 t['hoarmenian'] = 0x0570;
 t['hohipthai'] = 0x0E2B;
 t['hohiragana'] = 0x307B;
 t['hokatakana'] = 0x30DB;
 t['hokatakanahalfwidth'] = 0xFF8E;
 t['holam'] = 0x05B9;
 t['holam19'] = 0x05B9;
 t['holam26'] = 0x05B9;
 t['holam32'] = 0x05B9;
 t['holamhebrew'] = 0x05B9;
 t['holamnarrowhebrew'] = 0x05B9;
 t['holamquarterhebrew'] = 0x05B9;
 t['holamwidehebrew'] = 0x05B9;
 t['honokhukthai'] = 0x0E2E;
 t['hookabovecomb'] = 0x0309;
 t['hookcmb'] = 0x0309;
 t['hookpalatalizedbelowcmb'] = 0x0321;
 t['hookretroflexbelowcmb'] = 0x0322;
 t['hoonsquare'] = 0x3342;
 t['horicoptic'] = 0x03E9;
 t['horizontalbar'] = 0x2015;
 t['horncmb'] = 0x031B;
 t['hotsprings'] = 0x2668;
 t['house'] = 0x2302;
 t['hparen'] = 0x24A3;
 t['hsuperior'] = 0x02B0;
 t['hturned'] = 0x0265;
 t['huhiragana'] = 0x3075;
 t['huiitosquare'] = 0x3333;
 t['hukatakana'] = 0x30D5;
 t['hukatakanahalfwidth'] = 0xFF8C;
 t['hungarumlaut'] = 0x02DD;
 t['hungarumlautcmb'] = 0x030B;
 t['hv'] = 0x0195;
 t['hyphen'] = 0x002D;
 t['hypheninferior'] = 0xF6E5;
 t['hyphenmonospace'] = 0xFF0D;
 t['hyphensmall'] = 0xFE63;
 t['hyphensuperior'] = 0xF6E6;
 t['hyphentwo'] = 0x2010;
 t['i'] = 0x0069;
 t['iacute'] = 0x00ED;
 t['iacyrillic'] = 0x044F;
 t['ibengali'] = 0x0987;
 t['ibopomofo'] = 0x3127;
 t['ibreve'] = 0x012D;
 t['icaron'] = 0x01D0;
 t['icircle'] = 0x24D8;
 t['icircumflex'] = 0x00EE;
 t['icyrillic'] = 0x0456;
 t['idblgrave'] = 0x0209;
 t['ideographearthcircle'] = 0x328F;
 t['ideographfirecircle'] = 0x328B;
 t['ideographicallianceparen'] = 0x323F;
 t['ideographiccallparen'] = 0x323A;
 t['ideographiccentrecircle'] = 0x32A5;
 t['ideographicclose'] = 0x3006;
 t['ideographiccomma'] = 0x3001;
 t['ideographiccommaleft'] = 0xFF64;
 t['ideographiccongratulationparen'] = 0x3237;
 t['ideographiccorrectcircle'] = 0x32A3;
 t['ideographicearthparen'] = 0x322F;
 t['ideographicenterpriseparen'] = 0x323D;
 t['ideographicexcellentcircle'] = 0x329D;
 t['ideographicfestivalparen'] = 0x3240;
 t['ideographicfinancialcircle'] = 0x3296;
 t['ideographicfinancialparen'] = 0x3236;
 t['ideographicfireparen'] = 0x322B;
 t['ideographichaveparen'] = 0x3232;
 t['ideographichighcircle'] = 0x32A4;
 t['ideographiciterationmark'] = 0x3005;
 t['ideographiclaborcircle'] = 0x3298;
 t['ideographiclaborparen'] = 0x3238;
 t['ideographicleftcircle'] = 0x32A7;
 t['ideographiclowcircle'] = 0x32A6;
 t['ideographicmedicinecircle'] = 0x32A9;
 t['ideographicmetalparen'] = 0x322E;
 t['ideographicmoonparen'] = 0x322A;
 t['ideographicnameparen'] = 0x3234;
 t['ideographicperiod'] = 0x3002;
 t['ideographicprintcircle'] = 0x329E;
 t['ideographicreachparen'] = 0x3243;
 t['ideographicrepresentparen'] = 0x3239;
 t['ideographicresourceparen'] = 0x323E;
 t['ideographicrightcircle'] = 0x32A8;
 t['ideographicsecretcircle'] = 0x3299;
 t['ideographicselfparen'] = 0x3242;
 t['ideographicsocietyparen'] = 0x3233;
 t['ideographicspace'] = 0x3000;
 t['ideographicspecialparen'] = 0x3235;
 t['ideographicstockparen'] = 0x3231;
 t['ideographicstudyparen'] = 0x323B;
 t['ideographicsunparen'] = 0x3230;
 t['ideographicsuperviseparen'] = 0x323C;
 t['ideographicwaterparen'] = 0x322C;
 t['ideographicwoodparen'] = 0x322D;
 t['ideographiczero'] = 0x3007;
 t['ideographmetalcircle'] = 0x328E;
 t['ideographmooncircle'] = 0x328A;
 t['ideographnamecircle'] = 0x3294;
 t['ideographsuncircle'] = 0x3290;
 t['ideographwatercircle'] = 0x328C;
 t['ideographwoodcircle'] = 0x328D;
 t['ideva'] = 0x0907;
 t['idieresis'] = 0x00EF;
 t['idieresisacute'] = 0x1E2F;
 t['idieresiscyrillic'] = 0x04E5;
 t['idotbelow'] = 0x1ECB;
 t['iebrevecyrillic'] = 0x04D7;
 t['iecyrillic'] = 0x0435;
 t['ieungacirclekorean'] = 0x3275;
 t['ieungaparenkorean'] = 0x3215;
 t['ieungcirclekorean'] = 0x3267;
 t['ieungkorean'] = 0x3147;
 t['ieungparenkorean'] = 0x3207;
 t['igrave'] = 0x00EC;
 t['igujarati'] = 0x0A87;
 t['igurmukhi'] = 0x0A07;
 t['ihiragana'] = 0x3044;
 t['ihookabove'] = 0x1EC9;
 t['iibengali'] = 0x0988;
 t['iicyrillic'] = 0x0438;
 t['iideva'] = 0x0908;
 t['iigujarati'] = 0x0A88;
 t['iigurmukhi'] = 0x0A08;
 t['iimatragurmukhi'] = 0x0A40;
 t['iinvertedbreve'] = 0x020B;
 t['iishortcyrillic'] = 0x0439;
 t['iivowelsignbengali'] = 0x09C0;
 t['iivowelsigndeva'] = 0x0940;
 t['iivowelsigngujarati'] = 0x0AC0;
 t['ij'] = 0x0133;
 t['ikatakana'] = 0x30A4;
 t['ikatakanahalfwidth'] = 0xFF72;
 t['ikorean'] = 0x3163;
 t['ilde'] = 0x02DC;
 t['iluyhebrew'] = 0x05AC;
 t['imacron'] = 0x012B;
 t['imacroncyrillic'] = 0x04E3;
 t['imageorapproximatelyequal'] = 0x2253;
 t['imatragurmukhi'] = 0x0A3F;
 t['imonospace'] = 0xFF49;
 t['increment'] = 0x2206;
 t['infinity'] = 0x221E;
 t['iniarmenian'] = 0x056B;
 t['integral'] = 0x222B;
 t['integralbottom'] = 0x2321;
 t['integralbt'] = 0x2321;
 t['integralex'] = 0xF8F5;
 t['integraltop'] = 0x2320;
 t['integraltp'] = 0x2320;
 t['in