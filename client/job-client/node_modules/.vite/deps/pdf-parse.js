import {
  __commonJS,
  __esm,
  __glob,
  __require
} from "./chunk-PWCYJDAR.js";

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/node-ensure/browser.js
var require_browser = __commonJS({
  "node_modules/node-ensure/browser.js"(exports, module) {
    module.exports = function() {
      __require.ensure.apply(this, arguments);
    };
  }
});

// node_modules/pdf-parse/lib/pdf.js/v1.10.100/build/pdf.worker.js
var require_pdf_worker = __commonJS({
  "node_modules/pdf-parse/lib/pdf.js/v1.10.100/build/pdf.worker.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("pdfjs-dist/build/pdf.worker", [], factory);
      else if (typeof exports === "object")
        exports["pdfjs-dist/build/pdf.worker"] = factory();
      else
        root["pdfjs-dist/build/pdf.worker"] = root.pdfjsDistBuildPdfWorker = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __w_pdfjs_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __w_pdfjs_require__);
            module2.l = true;
            return module2.exports;
          }
          __w_pdfjs_require__.m = modules;
          __w_pdfjs_require__.c = installedModules;
          __w_pdfjs_require__.d = function(exports2, name, getter) {
            if (!__w_pdfjs_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __w_pdfjs_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __w_pdfjs_require__.d(getter, "a", getter);
            return getter;
          };
          __w_pdfjs_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __w_pdfjs_require__.p = "";
          return __w_pdfjs_require__(__w_pdfjs_require__.s = 82);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.unreachable = exports2.warn = exports2.utf8StringToString = exports2.stringToUTF8String = exports2.stringToPDFString = exports2.stringToBytes = exports2.string32 = exports2.shadow = exports2.setVerbosityLevel = exports2.ReadableStream = exports2.removeNullCharacters = exports2.readUint32 = exports2.readUint16 = exports2.readInt8 = exports2.log2 = exports2.loadJpegStream = exports2.isEvalSupported = exports2.isLittleEndian = exports2.createValidAbsoluteUrl = exports2.isSameOrigin = exports2.isNodeJS = exports2.isSpace = exports2.isString = exports2.isNum = exports2.isEmptyObj = exports2.isBool = exports2.isArrayBuffer = exports2.info = exports2.getVerbosityLevel = exports2.getLookupTableFactory = exports2.deprecated = exports2.createObjectURL = exports2.createPromiseCapability = exports2.createBlob = exports2.bytesToString = exports2.assert = exports2.arraysToBytes = exports2.arrayByteLength = exports2.FormatError = exports2.XRefParseException = exports2.Util = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.TextRenderingMode = exports2.StreamType = exports2.StatTimer = exports2.PasswordResponses = exports2.PasswordException = exports2.PageViewport = exports2.NotImplementedException = exports2.NativeImageDecoding = exports2.MissingPDFException = exports2.MissingDataException = exports2.MessageHandler = exports2.InvalidPDFException = exports2.AbortException = exports2.CMapCompressionType = exports2.ImageKind = exports2.FontType = exports2.AnnotationType = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationBorderStyleType = exports2.UNSUPPORTED_FEATURES = exports2.VERBOSITY_LEVELS = exports2.OPS = exports2.IDENTITY_MATRIX = exports2.FONT_IDENTITY_MATRIX = void 0;
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            __w_pdfjs_require__(84);
            var _streams_polyfill = __w_pdfjs_require__(125);
            var FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
            var NativeImageDecoding = {
              NONE: "none",
              DECODE: "decode",
              DISPLAY: "display"
            };
            var TextRenderingMode = {
              FILL: 0,
              STROKE: 1,
              FILL_STROKE: 2,
              INVISIBLE: 3,
              FILL_ADD_TO_PATH: 4,
              STROKE_ADD_TO_PATH: 5,
              FILL_STROKE_ADD_TO_PATH: 6,
              ADD_TO_PATH: 7,
              FILL_STROKE_MASK: 3,
              ADD_TO_PATH_FLAG: 4
            };
            var ImageKind = {
              GRAYSCALE_1BPP: 1,
              RGB_24BPP: 2,
              RGBA_32BPP: 3
            };
            var AnnotationType = {
              TEXT: 1,
              LINK: 2,
              FREETEXT: 3,
              LINE: 4,
              SQUARE: 5,
              CIRCLE: 6,
              POLYGON: 7,
              POLYLINE: 8,
              HIGHLIGHT: 9,
              UNDERLINE: 10,
              SQUIGGLY: 11,
              STRIKEOUT: 12,
              STAMP: 13,
              CARET: 14,
              INK: 15,
              POPUP: 16,
              FILEATTACHMENT: 17,
              SOUND: 18,
              MOVIE: 19,
              WIDGET: 20,
              SCREEN: 21,
              PRINTERMARK: 22,
              TRAPNET: 23,
              WATERMARK: 24,
              THREED: 25,
              REDACT: 26
            };
            var AnnotationFlag = {
              INVISIBLE: 1,
              HIDDEN: 2,
              PRINT: 4,
              NOZOOM: 8,
              NOROTATE: 16,
              NOVIEW: 32,
              READONLY: 64,
              LOCKED: 128,
              TOGGLENOVIEW: 256,
              LOCKEDCONTENTS: 512
            };
            var AnnotationFieldFlag = {
              READONLY: 1,
              REQUIRED: 2,
              NOEXPORT: 4,
              MULTILINE: 4096,
              PASSWORD: 8192,
              NOTOGGLETOOFF: 16384,
              RADIO: 32768,
              PUSHBUTTON: 65536,
              COMBO: 131072,
              EDIT: 262144,
              SORT: 524288,
              FILESELECT: 1048576,
              MULTISELECT: 2097152,
              DONOTSPELLCHECK: 4194304,
              DONOTSCROLL: 8388608,
              COMB: 16777216,
              RICHTEXT: 33554432,
              RADIOSINUNISON: 33554432,
              COMMITONSELCHANGE: 67108864
            };
            var AnnotationBorderStyleType = {
              SOLID: 1,
              DASHED: 2,
              BEVELED: 3,
              INSET: 4,
              UNDERLINE: 5
            };
            var StreamType = {
              UNKNOWN: 0,
              FLATE: 1,
              LZW: 2,
              DCT: 3,
              JPX: 4,
              JBIG: 5,
              A85: 6,
              AHX: 7,
              CCF: 8,
              RL: 9
            };
            var FontType = {
              UNKNOWN: 0,
              TYPE1: 1,
              TYPE1C: 2,
              CIDFONTTYPE0: 3,
              CIDFONTTYPE0C: 4,
              TRUETYPE: 5,
              CIDFONTTYPE2: 6,
              TYPE3: 7,
              OPENTYPE: 8,
              TYPE0: 9,
              MMTYPE1: 10
            };
            var VERBOSITY_LEVELS = {
              errors: 0,
              warnings: 1,
              infos: 5
            };
            var CMapCompressionType = {
              NONE: 0,
              BINARY: 1,
              STREAM: 2
            };
            var OPS = {
              dependency: 1,
              setLineWidth: 2,
              setLineCap: 3,
              setLineJoin: 4,
              setMiterLimit: 5,
              setDash: 6,
              setRenderingIntent: 7,
              setFlatness: 8,
              setGState: 9,
              save: 10,
              restore: 11,
              transform: 12,
              moveTo: 13,
              lineTo: 14,
              curveTo: 15,
              curveTo2: 16,
              curveTo3: 17,
              closePath: 18,
              rectangle: 19,
              stroke: 20,
              closeStroke: 21,
              fill: 22,
              eoFill: 23,
              fillStroke: 24,
              eoFillStroke: 25,
              closeFillStroke: 26,
              closeEOFillStroke: 27,
              endPath: 28,
              clip: 29,
              eoClip: 30,
              beginText: 31,
              endText: 32,
              setCharSpacing: 33,
              setWordSpacing: 34,
              setHScale: 35,
              setLeading: 36,
              setFont: 37,
              setTextRenderingMode: 38,
              setTextRise: 39,
              moveText: 40,
              setLeadingMoveText: 41,
              setTextMatrix: 42,
              nextLine: 43,
              showText: 44,
              showSpacedText: 45,
              nextLineShowText: 46,
              nextLineSetSpacingShowText: 47,
              setCharWidth: 48,
              setCharWidthAndBounds: 49,
              setStrokeColorSpace: 50,
              setFillColorSpace: 51,
              setStrokeColor: 52,
              setStrokeColorN: 53,
              setFillColor: 54,
              setFillColorN: 55,
              setStrokeGray: 56,
              setFillGray: 57,
              setStrokeRGBColor: 58,
              setFillRGBColor: 59,
              setStrokeCMYKColor: 60,
              setFillCMYKColor: 61,
              shadingFill: 62,
              beginInlineImage: 63,
              beginImageData: 64,
              endInlineImage: 65,
              paintXObject: 66,
              markPoint: 67,
              markPointProps: 68,
              beginMarkedContent: 69,
              beginMarkedContentProps: 70,
              endMarkedContent: 71,
              beginCompat: 72,
              endCompat: 73,
              paintFormXObjectBegin: 74,
              paintFormXObjectEnd: 75,
              beginGroup: 76,
              endGroup: 77,
              beginAnnotations: 78,
              endAnnotations: 79,
              beginAnnotation: 80,
              endAnnotation: 81,
              paintJpegXObject: 82,
              paintImageMaskXObject: 83,
              paintImageMaskXObjectGroup: 84,
              paintImageXObject: 85,
              paintInlineImageXObject: 86,
              paintInlineImageXObjectGroup: 87,
              paintImageXObjectRepeat: 88,
              paintImageMaskXObjectRepeat: 89,
              paintSolidColorImageMask: 90,
              constructPath: 91
            };
            var verbosity = VERBOSITY_LEVELS.warnings;
            function setVerbosityLevel(level) {
              verbosity = level;
            }
            function getVerbosityLevel() {
              return verbosity;
            }
            function info(msg) {
              if (verbosity >= VERBOSITY_LEVELS.infos) {
                console.log("Info: " + msg);
              }
            }
            function warn(msg) {
              if (verbosity >= VERBOSITY_LEVELS.warnings) {
                console.log("Warning: " + msg);
              }
            }
            function deprecated(details) {
              console.log("Deprecated API usage: " + details);
            }
            function unreachable(msg) {
              throw new Error(msg);
            }
            function assert(cond, msg) {
              if (!cond) {
                unreachable(msg);
              }
            }
            var UNSUPPORTED_FEATURES = {
              unknown: "unknown",
              forms: "forms",
              javaScript: "javaScript",
              smask: "smask",
              shadingPattern: "shadingPattern",
              font: "font"
            };
            function isSameOrigin(baseUrl, otherUrl) {
              try {
                var base = new URL(baseUrl);
                if (!base.origin || base.origin === "null") {
                  return false;
                }
              } catch (e) {
                return false;
              }
              var other = new URL(otherUrl, base);
              return base.origin === other.origin;
            }
            function isValidProtocol(url) {
              if (!url) {
                return false;
              }
              switch (url.protocol) {
                case "http:":
                case "https:":
                case "ftp:":
                case "mailto:":
                case "tel:":
                  return true;
                default:
                  return false;
              }
            }
            function createValidAbsoluteUrl(url, baseUrl) {
              if (!url) {
                return null;
              }
              try {
                var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                if (isValidProtocol(absoluteUrl)) {
                  return absoluteUrl;
                }
              } catch (ex) {
              }
              return null;
            }
            function shadow(obj, prop, value) {
              Object.defineProperty(obj, prop, {
                value,
                enumerable: true,
                configurable: true,
                writable: false
              });
              return value;
            }
            function getLookupTableFactory(initializer) {
              var lookup;
              return function() {
                if (initializer) {
                  lookup = /* @__PURE__ */ Object.create(null);
                  initializer(lookup);
                  initializer = null;
                }
                return lookup;
              };
            }
            var PasswordResponses = {
              NEED_PASSWORD: 1,
              INCORRECT_PASSWORD: 2
            };
            var PasswordException = function PasswordExceptionClosure() {
              function PasswordException2(msg, code) {
                this.name = "PasswordException";
                this.message = msg;
                this.code = code;
              }
              PasswordException2.prototype = new Error();
              PasswordException2.constructor = PasswordException2;
              return PasswordException2;
            }();
            var UnknownErrorException = function UnknownErrorExceptionClosure() {
              function UnknownErrorException2(msg, details) {
                this.name = "UnknownErrorException";
                this.message = msg;
                this.details = details;
              }
              UnknownErrorException2.prototype = new Error();
              UnknownErrorException2.constructor = UnknownErrorException2;
              return UnknownErrorException2;
            }();
            var InvalidPDFException = function InvalidPDFExceptionClosure() {
              function InvalidPDFException2(msg) {
                this.name = "InvalidPDFException";
                this.message = msg;
              }
              InvalidPDFException2.prototype = new Error();
              InvalidPDFException2.constructor = InvalidPDFException2;
              return InvalidPDFException2;
            }();
            var MissingPDFException = function MissingPDFExceptionClosure() {
              function MissingPDFException2(msg) {
                this.name = "MissingPDFException";
                this.message = msg;
              }
              MissingPDFException2.prototype = new Error();
              MissingPDFException2.constructor = MissingPDFException2;
              return MissingPDFException2;
            }();
            var UnexpectedResponseException = function UnexpectedResponseExceptionClosure() {
              function UnexpectedResponseException2(msg, status) {
                this.name = "UnexpectedResponseException";
                this.message = msg;
                this.status = status;
              }
              UnexpectedResponseException2.prototype = new Error();
              UnexpectedResponseException2.constructor = UnexpectedResponseException2;
              return UnexpectedResponseException2;
            }();
            var NotImplementedException = function NotImplementedExceptionClosure() {
              function NotImplementedException2(msg) {
                this.message = msg;
              }
              NotImplementedException2.prototype = new Error();
              NotImplementedException2.prototype.name = "NotImplementedException";
              NotImplementedException2.constructor = NotImplementedException2;
              return NotImplementedException2;
            }();
            var MissingDataException = function MissingDataExceptionClosure() {
              function MissingDataException2(begin, end) {
                this.begin = begin;
                this.end = end;
                this.message = "Missing data [" + begin + ", " + end + ")";
              }
              MissingDataException2.prototype = new Error();
              MissingDataException2.prototype.name = "MissingDataException";
              MissingDataException2.constructor = MissingDataException2;
              return MissingDataException2;
            }();
            var XRefParseException = function XRefParseExceptionClosure() {
              function XRefParseException2(msg) {
                this.message = msg;
              }
              XRefParseException2.prototype = new Error();
              XRefParseException2.prototype.name = "XRefParseException";
              XRefParseException2.constructor = XRefParseException2;
              return XRefParseException2;
            }();
            var FormatError = function FormatErrorClosure() {
              function FormatError2(msg) {
                this.message = msg;
              }
              FormatError2.prototype = new Error();
              FormatError2.prototype.name = "FormatError";
              FormatError2.constructor = FormatError2;
              return FormatError2;
            }();
            var AbortException = function AbortExceptionClosure() {
              function AbortException2(msg) {
                this.name = "AbortException";
                this.message = msg;
              }
              AbortException2.prototype = new Error();
              AbortException2.constructor = AbortException2;
              return AbortException2;
            }();
            var NullCharactersRegExp = /\x00/g;
            function removeNullCharacters(str) {
              if (typeof str !== "string") {
                warn("The argument for removeNullCharacters must be a string.");
                return str;
              }
              return str.replace(NullCharactersRegExp, "");
            }
            function bytesToString(bytes) {
              assert(bytes !== null && (typeof bytes === "undefined" ? "undefined" : _typeof(bytes)) === "object" && bytes.length !== void 0, "Invalid argument for bytesToString");
              var length = bytes.length;
              var MAX_ARGUMENT_COUNT = 8192;
              if (length < MAX_ARGUMENT_COUNT) {
                return String.fromCharCode.apply(null, bytes);
              }
              var strBuf = [];
              for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
                var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
                var chunk = bytes.subarray(i, chunkEnd);
                strBuf.push(String.fromCharCode.apply(null, chunk));
              }
              return strBuf.join("");
            }
            function stringToBytes(str) {
              assert(typeof str === "string", "Invalid argument for stringToBytes");
              var length = str.length;
              var bytes = new Uint8Array(length);
              for (var i = 0; i < length; ++i) {
                bytes[i] = str.charCodeAt(i) & 255;
              }
              return bytes;
            }
            function arrayByteLength(arr) {
              if (arr.length !== void 0) {
                return arr.length;
              }
              assert(arr.byteLength !== void 0);
              return arr.byteLength;
            }
            function arraysToBytes(arr) {
              if (arr.length === 1 && arr[0] instanceof Uint8Array) {
                return arr[0];
              }
              var resultLength = 0;
              var i, ii = arr.length;
              var item, itemLength;
              for (i = 0; i < ii; i++) {
                item = arr[i];
                itemLength = arrayByteLength(item);
                resultLength += itemLength;
              }
              var pos = 0;
              var data = new Uint8Array(resultLength);
              for (i = 0; i < ii; i++) {
                item = arr[i];
                if (!(item instanceof Uint8Array)) {
                  if (typeof item === "string") {
                    item = stringToBytes(item);
                  } else {
                    item = new Uint8Array(item);
                  }
                }
                itemLength = item.byteLength;
                data.set(item, pos);
                pos += itemLength;
              }
              return data;
            }
            function string32(value) {
              return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
            }
            function log2(x) {
              var n = 1, i = 0;
              while (x > n) {
                n <<= 1;
                i++;
              }
              return i;
            }
            function readInt8(data, start) {
              return data[start] << 24 >> 24;
            }
            function readUint16(data, offset) {
              return data[offset] << 8 | data[offset + 1];
            }
            function readUint32(data, offset) {
              return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
            }
            function isLittleEndian() {
              var buffer8 = new Uint8Array(4);
              buffer8[0] = 1;
              var view32 = new Uint32Array(buffer8.buffer, 0, 1);
              return view32[0] === 1;
            }
            function isEvalSupported() {
              try {
                new Function("");
                return true;
              } catch (e) {
                return false;
              }
            }
            var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
            var Util = function UtilClosure() {
              function Util2() {
              }
              var rgbBuf = ["rgb(", 0, ",", 0, ",", 0, ")"];
              Util2.makeCssRgb = function Util_makeCssRgb(r, g, b) {
                rgbBuf[1] = r;
                rgbBuf[3] = g;
                rgbBuf[5] = b;
                return rgbBuf.join("");
              };
              Util2.transform = function Util_transform(m1, m2) {
                return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
              };
              Util2.applyTransform = function Util_applyTransform(p, m) {
                var xt = p[0] * m[0] + p[1] * m[2] + m[4];
                var yt = p[0] * m[1] + p[1] * m[3] + m[5];
                return [xt, yt];
              };
              Util2.applyInverseTransform = function Util_applyInverseTransform(p, m) {
                var d = m[0] * m[3] - m[1] * m[2];
                var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                return [xt, yt];
              };
              Util2.getAxialAlignedBoundingBox = function Util_getAxialAlignedBoundingBox(r, m) {
                var p1 = Util2.applyTransform(r, m);
                var p2 = Util2.applyTransform(r.slice(2, 4), m);
                var p3 = Util2.applyTransform([r[0], r[3]], m);
                var p4 = Util2.applyTransform([r[2], r[1]], m);
                return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
              };
              Util2.inverseTransform = function Util_inverseTransform(m) {
                var d = m[0] * m[3] - m[1] * m[2];
                return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
              };
              Util2.apply3dTransform = function Util_apply3dTransform(m, v) {
                return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
              };
              Util2.singularValueDecompose2dScale = function Util_singularValueDecompose2dScale(m) {
                var transpose = [m[0], m[2], m[1], m[3]];
                var a = m[0] * transpose[0] + m[1] * transpose[2];
                var b = m[0] * transpose[1] + m[1] * transpose[3];
                var c = m[2] * transpose[0] + m[3] * transpose[2];
                var d = m[2] * transpose[1] + m[3] * transpose[3];
                var first = (a + d) / 2;
                var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
                var sx = first + second || 1;
                var sy = first - second || 1;
                return [Math.sqrt(sx), Math.sqrt(sy)];
              };
              Util2.normalizeRect = function Util_normalizeRect(rect) {
                var r = rect.slice(0);
                if (rect[0] > rect[2]) {
                  r[0] = rect[2];
                  r[2] = rect[0];
                }
                if (rect[1] > rect[3]) {
                  r[1] = rect[3];
                  r[3] = rect[1];
                }
                return r;
              };
              Util2.intersect = function Util_intersect(rect1, rect2) {
                function compare(a, b) {
                  return a - b;
                }
                var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare), orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare), result = [];
                rect1 = Util2.normalizeRect(rect1);
                rect2 = Util2.normalizeRect(rect2);
                if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
                  result[0] = orderedX[1];
                  result[2] = orderedX[2];
                } else {
                  return false;
                }
                if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
                  result[1] = orderedY[1];
                  result[3] = orderedY[2];
                } else {
                  return false;
                }
                return result;
              };
              var ROMAN_NUMBER_MAP = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
              Util2.toRoman = function Util_toRoman(number, lowerCase) {
                assert(Number.isInteger(number) && number > 0, "The number should be a positive integer.");
                var pos, romanBuf = [];
                while (number >= 1e3) {
                  number -= 1e3;
                  romanBuf.push("M");
                }
                pos = number / 100 | 0;
                number %= 100;
                romanBuf.push(ROMAN_NUMBER_MAP[pos]);
                pos = number / 10 | 0;
                number %= 10;
                romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
                romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
                var romanStr = romanBuf.join("");
                return lowerCase ? romanStr.toLowerCase() : romanStr;
              };
              Util2.appendToArray = function Util_appendToArray(arr1, arr2) {
                Array.prototype.push.apply(arr1, arr2);
              };
              Util2.prependToArray = function Util_prependToArray(arr1, arr2) {
                Array.prototype.unshift.apply(arr1, arr2);
              };
              Util2.extendObj = function extendObj(obj1, obj2) {
                for (var key in obj2) {
                  obj1[key] = obj2[key];
                }
              };
              Util2.getInheritableProperty = function Util_getInheritableProperty(dict, name, getArray) {
                while (dict && !dict.has(name)) {
                  dict = dict.get("Parent");
                }
                if (!dict) {
                  return null;
                }
                return getArray ? dict.getArray(name) : dict.get(name);
              };
              Util2.inherit = function Util_inherit(sub, base, prototype) {
                sub.prototype = Object.create(base.prototype);
                sub.prototype.constructor = sub;
                for (var prop in prototype) {
                  sub.prototype[prop] = prototype[prop];
                }
              };
              Util2.loadScript = function Util_loadScript(src, callback) {
                var script = document.createElement("script");
                var loaded = false;
                script.setAttribute("src", src);
                if (callback) {
                  script.onload = function() {
                    if (!loaded) {
                      callback();
                    }
                    loaded = true;
                  };
                }
                document.getElementsByTagName("head")[0].appendChild(script);
              };
              return Util2;
            }();
            var PageViewport = function PageViewportClosure() {
              function PageViewport2(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {
                this.viewBox = viewBox;
                this.scale = scale;
                this.rotation = rotation;
                this.offsetX = offsetX;
                this.offsetY = offsetY;
                var centerX = (viewBox[2] + viewBox[0]) / 2;
                var centerY = (viewBox[3] + viewBox[1]) / 2;
                var rotateA, rotateB, rotateC, rotateD;
                rotation = rotation % 360;
                rotation = rotation < 0 ? rotation + 360 : rotation;
                switch (rotation) {
                  case 180:
                    rotateA = -1;
                    rotateB = 0;
                    rotateC = 0;
                    rotateD = 1;
                    break;
                  case 90:
                    rotateA = 0;
                    rotateB = 1;
                    rotateC = 1;
                    rotateD = 0;
                    break;
                  case 270:
                    rotateA = 0;
                    rotateB = -1;
                    rotateC = -1;
                    rotateD = 0;
                    break;
                  default:
                    rotateA = 1;
                    rotateB = 0;
                    rotateC = 0;
                    rotateD = -1;
                    break;
                }
                if (dontFlip) {
                  rotateC = -rotateC;
                  rotateD = -rotateD;
                }
                var offsetCanvasX, offsetCanvasY;
                var width, height;
                if (rotateA === 0) {
                  offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
                  offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
                  width = Math.abs(viewBox[3] - viewBox[1]) * scale;
                  height = Math.abs(viewBox[2] - viewBox[0]) * scale;
                } else {
                  offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
                  offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
                  width = Math.abs(viewBox[2] - viewBox[0]) * scale;
                  height = Math.abs(viewBox[3] - viewBox[1]) * scale;
                }
                this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
                this.width = width;
                this.height = height;
                this.fontScale = scale;
              }
              PageViewport2.prototype = {
                clone: function PageViewPort_clone(args) {
                  args = args || {};
                  var scale = "scale" in args ? args.scale : this.scale;
                  var rotation = "rotation" in args ? args.rotation : this.rotation;
                  return new PageViewport2(this.viewBox.slice(), scale, rotation, this.offsetX, this.offsetY, args.dontFlip);
                },
                convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
                  return Util.applyTransform([x, y], this.transform);
                },
                convertToViewportRectangle: function PageViewport_convertToViewportRectangle(rect) {
                  var tl = Util.applyTransform([rect[0], rect[1]], this.transform);
                  var br = Util.applyTransform([rect[2], rect[3]], this.transform);
                  return [tl[0], tl[1], br[0], br[1]];
                },
                convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
                  return Util.applyInverseTransform([x, y], this.transform);
                }
              };
              return PageViewport2;
            }();
            var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
            function stringToPDFString(str) {
              var i, n = str.length, strBuf = [];
              if (str[0] === "þ" && str[1] === "ÿ") {
                for (i = 2; i < n; i += 2) {
                  strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
                }
              } else {
                for (i = 0; i < n; ++i) {
                  var code = PDFStringTranslateTable[str.charCodeAt(i)];
                  strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
                }
              }
              return strBuf.join("");
            }
            function stringToUTF8String(str) {
              return decodeURIComponent(escape(str));
            }
            function utf8StringToString(str) {
              return unescape(encodeURIComponent(str));
            }
            function isEmptyObj(obj) {
              for (var key in obj) {
                return false;
              }
              return true;
            }
            function isBool(v) {
              return typeof v === "boolean";
            }
            function isNum(v) {
              return typeof v === "number";
            }
            function isString(v) {
              return typeof v === "string";
            }
            function isArrayBuffer(v) {
              return (typeof v === "undefined" ? "undefined" : _typeof(v)) === "object" && v !== null && v.byteLength !== void 0;
            }
            function isSpace(ch) {
              return ch === 32 || ch === 9 || ch === 13 || ch === 10;
            }
            function isNodeJS() {
              return (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process + "" === "[object process]";
            }
            function createPromiseCapability() {
              var capability = {};
              capability.promise = new Promise(function(resolve, reject) {
                capability.resolve = resolve;
                capability.reject = reject;
              });
              return capability;
            }
            var StatTimer = function StatTimerClosure() {
              function rpad(str, pad, length) {
                while (str.length < length) {
                  str += pad;
                }
                return str;
              }
              function StatTimer2() {
                this.started = /* @__PURE__ */ Object.create(null);
                this.times = [];
                this.enabled = true;
              }
              StatTimer2.prototype = {
                time: function StatTimer_time(name) {
                  if (!this.enabled) {
                    return;
                  }
                  if (name in this.started) {
                    warn("Timer is already running for " + name);
                  }
                  this.started[name] = Date.now();
                },
                timeEnd: function StatTimer_timeEnd(name) {
                  if (!this.enabled) {
                    return;
                  }
                  if (!(name in this.started)) {
                    warn("Timer has not been started for " + name);
                  }
                  this.times.push({
                    "name": name,
                    "start": this.started[name],
                    "end": Date.now()
                  });
                  delete this.started[name];
                },
                toString: function StatTimer_toString() {
                  var i, ii;
                  var times = this.times;
                  var out = "";
                  var longest = 0;
                  for (i = 0, ii = times.length; i < ii; ++i) {
                    var name = times[i]["name"];
                    if (name.length > longest) {
                      longest = name.length;
                    }
                  }
                  for (i = 0, ii = times.length; i < ii; ++i) {
                    var span = times[i];
                    var duration = span.end - span.start;
                    out += rpad(span["name"], " ", longest) + " " + duration + "ms\n";
                  }
                  return out;
                }
              };
              return StatTimer2;
            }();
            var createBlob = function createBlob2(data, contentType) {
              if (typeof Blob !== "undefined") {
                return new Blob([data], { type: contentType });
              }
              throw new Error('The "Blob" constructor is not supported.');
            };
            var createObjectURL = /* @__PURE__ */ function createObjectURLClosure() {
              var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              return function createObjectURL2(data, contentType) {
                var forceDataSchema = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                if (!forceDataSchema && URL.createObjectURL) {
                  var blob = createBlob(data, contentType);
                  return URL.createObjectURL(blob);
                }
                var buffer = "data:" + contentType + ";base64,";
                for (var i = 0, ii = data.length; i < ii; i += 3) {
                  var b1 = data[i] & 255;
                  var b2 = data[i + 1] & 255;
                  var b3 = data[i + 2] & 255;
                  var d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                  var d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                  var d4 = i + 2 < ii ? b3 & 63 : 64;
                  buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                }
                return buffer;
              };
            }();
            function resolveCall(fn, args) {
              var thisArg = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              if (!fn) {
                return Promise.resolve(void 0);
              }
              return new Promise(function(resolve, reject) {
                resolve(fn.apply(thisArg, args));
              });
            }
            function wrapReason(reason) {
              if ((typeof reason === "undefined" ? "undefined" : _typeof(reason)) !== "object") {
                return reason;
              }
              switch (reason.name) {
                case "AbortException":
                  return new AbortException(reason.message);
                case "MissingPDFException":
                  return new MissingPDFException(reason.message);
                case "UnexpectedResponseException":
                  return new UnexpectedResponseException(reason.message, reason.status);
                default:
                  return new UnknownErrorException(reason.message, reason.details);
              }
            }
            function makeReasonSerializable(reason) {
              if (!(reason instanceof Error) || reason instanceof AbortException || reason instanceof MissingPDFException || reason instanceof UnexpectedResponseException || reason instanceof UnknownErrorException) {
                return reason;
              }
              return new UnknownErrorException(reason.message, reason.toString());
            }
            function resolveOrReject(capability, success, reason) {
              if (success) {
                capability.resolve();
              } else {
                capability.reject(reason);
              }
            }
            function finalize(promise) {
              return Promise.resolve(promise).catch(function() {
              });
            }
            function MessageHandler(sourceName, targetName, comObj) {
              var _this = this;
              this.sourceName = sourceName;
              this.targetName = targetName;
              this.comObj = comObj;
              this.callbackId = 1;
              this.streamId = 1;
              this.postMessageTransfers = true;
              this.streamSinks = /* @__PURE__ */ Object.create(null);
              this.streamControllers = /* @__PURE__ */ Object.create(null);
              var callbacksCapabilities = this.callbacksCapabilities = /* @__PURE__ */ Object.create(null);
              var ah = this.actionHandler = /* @__PURE__ */ Object.create(null);
              this._onComObjOnMessage = function(event) {
                var data = event.data;
                if (data.targetName !== _this.sourceName) {
                  return;
                }
                if (data.stream) {
                  _this._processStreamMessage(data);
                } else if (data.isReply) {
                  var callbackId = data.callbackId;
                  if (data.callbackId in callbacksCapabilities) {
                    var callback = callbacksCapabilities[callbackId];
                    delete callbacksCapabilities[callbackId];
                    if ("error" in data) {
                      callback.reject(wrapReason(data.error));
                    } else {
                      callback.resolve(data.data);
                    }
                  } else {
                    throw new Error("Cannot resolve callback " + callbackId);
                  }
                } else if (data.action in ah) {
                  var action = ah[data.action];
                  if (data.callbackId) {
                    var _sourceName = _this.sourceName;
                    var _targetName = data.sourceName;
                    Promise.resolve().then(function() {
                      return action[0].call(action[1], data.data);
                    }).then(function(result) {
                      comObj.postMessage({
                        sourceName: _sourceName,
                        targetName: _targetName,
                        isReply: true,
                        callbackId: data.callbackId,
                        data: result
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName: _sourceName,
                        targetName: _targetName,
                        isReply: true,
                        callbackId: data.callbackId,
                        error: makeReasonSerializable(reason)
                      });
                    });
                  } else if (data.streamId) {
                    _this._createStreamSink(data);
                  } else {
                    action[0].call(action[1], data.data);
                  }
                } else {
                  throw new Error("Unknown action from worker: " + data.action);
                }
              };
              comObj.addEventListener("message", this._onComObjOnMessage);
            }
            MessageHandler.prototype = {
              on: function on(actionName, handler, scope) {
                var ah = this.actionHandler;
                if (ah[actionName]) {
                  throw new Error('There is already an actionName called "' + actionName + '"');
                }
                ah[actionName] = [handler, scope];
              },
              send: function send(actionName, data, transfers) {
                var message = {
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: actionName,
                  data
                };
                this.postMessage(message, transfers);
              },
              sendWithPromise: function sendWithPromise(actionName, data, transfers) {
                var callbackId = this.callbackId++;
                var message = {
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: actionName,
                  data,
                  callbackId
                };
                var capability = createPromiseCapability();
                this.callbacksCapabilities[callbackId] = capability;
                try {
                  this.postMessage(message, transfers);
                } catch (e) {
                  capability.reject(e);
                }
                return capability.promise;
              },
              sendWithStream: function sendWithStream(actionName, data, queueingStrategy, transfers) {
                var _this2 = this;
                var streamId = this.streamId++;
                var sourceName = this.sourceName;
                var targetName = this.targetName;
                return new _streams_polyfill.ReadableStream({
                  start: function start(controller) {
                    var startCapability = createPromiseCapability();
                    _this2.streamControllers[streamId] = {
                      controller,
                      startCall: startCapability,
                      isClosed: false
                    };
                    _this2.postMessage({
                      sourceName,
                      targetName,
                      action: actionName,
                      streamId,
                      data,
                      desiredSize: controller.desiredSize
                    });
                    return startCapability.promise;
                  },
                  pull: function pull(controller) {
                    var pullCapability = createPromiseCapability();
                    _this2.streamControllers[streamId].pullCall = pullCapability;
                    _this2.postMessage({
                      sourceName,
                      targetName,
                      stream: "pull",
                      streamId,
                      desiredSize: controller.desiredSize
                    });
                    return pullCapability.promise;
                  },
                  cancel: function cancel(reason) {
                    var cancelCapability = createPromiseCapability();
                    _this2.streamControllers[streamId].cancelCall = cancelCapability;
                    _this2.streamControllers[streamId].isClosed = true;
                    _this2.postMessage({
                      sourceName,
                      targetName,
                      stream: "cancel",
                      reason,
                      streamId
                    });
                    return cancelCapability.promise;
                  }
                }, queueingStrategy);
              },
              _createStreamSink: function _createStreamSink(data) {
                var _this3 = this;
                var self2 = this;
                var action = this.actionHandler[data.action];
                var streamId = data.streamId;
                var desiredSize = data.desiredSize;
                var sourceName = this.sourceName;
                var targetName = data.sourceName;
                var capability = createPromiseCapability();
                var sendStreamRequest = function sendStreamRequest2(_ref) {
                  var stream = _ref.stream, chunk = _ref.chunk, transfers = _ref.transfers, success = _ref.success, reason = _ref.reason;
                  _this3.postMessage({
                    sourceName,
                    targetName,
                    stream,
                    streamId,
                    chunk,
                    success,
                    reason
                  }, transfers);
                };
                var streamSink = {
                  enqueue: function enqueue(chunk) {
                    var size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
                    var transfers = arguments[2];
                    if (this.isCancelled) {
                      return;
                    }
                    var lastDesiredSize = this.desiredSize;
                    this.desiredSize -= size;
                    if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                      this.sinkCapability = createPromiseCapability();
                      this.ready = this.sinkCapability.promise;
                    }
                    sendStreamRequest({
                      stream: "enqueue",
                      chunk,
                      transfers
                    });
                  },
                  close: function close() {
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    sendStreamRequest({ stream: "close" });
                    delete self2.streamSinks[streamId];
                  },
                  error: function error(reason) {
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    sendStreamRequest({
                      stream: "error",
                      reason
                    });
                  },
                  sinkCapability: capability,
                  onPull: null,
                  onCancel: null,
                  isCancelled: false,
                  desiredSize,
                  ready: null
                };
                streamSink.sinkCapability.resolve();
                streamSink.ready = streamSink.sinkCapability.promise;
                this.streamSinks[streamId] = streamSink;
                resolveCall(action[0], [data.data, streamSink], action[1]).then(function() {
                  sendStreamRequest({
                    stream: "start_complete",
                    success: true
                  });
                }, function(reason) {
                  sendStreamRequest({
                    stream: "start_complete",
                    success: false,
                    reason
                  });
                });
              },
              _processStreamMessage: function _processStreamMessage(data) {
                var _this4 = this;
                var sourceName = this.sourceName;
                var targetName = data.sourceName;
                var streamId = data.streamId;
                var sendStreamResponse = function sendStreamResponse2(_ref2) {
                  var stream = _ref2.stream, success = _ref2.success, reason = _ref2.reason;
                  _this4.comObj.postMessage({
                    sourceName,
                    targetName,
                    stream,
                    success,
                    streamId,
                    reason
                  });
                };
                var deleteStreamController = function deleteStreamController2() {
                  Promise.all([_this4.streamControllers[data.streamId].startCall, _this4.streamControllers[data.streamId].pullCall, _this4.streamControllers[data.streamId].cancelCall].map(function(capability) {
                    return capability && finalize(capability.promise);
                  })).then(function() {
                    delete _this4.streamControllers[data.streamId];
                  });
                };
                switch (data.stream) {
                  case "start_complete":
                    resolveOrReject(this.streamControllers[data.streamId].startCall, data.success, wrapReason(data.reason));
                    break;
                  case "pull_complete":
                    resolveOrReject(this.streamControllers[data.streamId].pullCall, data.success, wrapReason(data.reason));
                    break;
                  case "pull":
                    if (!this.streamSinks[data.streamId]) {
                      sendStreamResponse({
                        stream: "pull_complete",
                        success: true
                      });
                      break;
                    }
                    if (this.streamSinks[data.streamId].desiredSize <= 0 && data.desiredSize > 0) {
                      this.streamSinks[data.streamId].sinkCapability.resolve();
                    }
                    this.streamSinks[data.streamId].desiredSize = data.desiredSize;
                    resolveCall(this.streamSinks[data.streamId].onPull).then(function() {
                      sendStreamResponse({
                        stream: "pull_complete",
                        success: true
                      });
                    }, function(reason) {
                      sendStreamResponse({
                        stream: "pull_complete",
                        success: false,
                        reason
                      });
                    });
                    break;
                  case "enqueue":
                    assert(this.streamControllers[data.streamId], "enqueue should have stream controller");
                    if (!this.streamControllers[data.streamId].isClosed) {
                      this.streamControllers[data.streamId].controller.enqueue(data.chunk);
                    }
                    break;
                  case "close":
                    assert(this.streamControllers[data.streamId], "close should have stream controller");
                    if (this.streamControllers[data.streamId].isClosed) {
                      break;
                    }
                    this.streamControllers[data.streamId].isClosed = true;
                    this.streamControllers[data.streamId].controller.close();
                    deleteStreamController();
                    break;
                  case "error":
                    assert(this.streamControllers[data.streamId], "error should have stream controller");
                    this.streamControllers[data.streamId].controller.error(wrapReason(data.reason));
                    deleteStreamController();
                    break;
                  case "cancel_complete":
                    resolveOrReject(this.streamControllers[data.streamId].cancelCall, data.success, wrapReason(data.reason));
                    deleteStreamController();
                    break;
                  case "cancel":
                    if (!this.streamSinks[data.streamId]) {
                      break;
                    }
                    resolveCall(this.streamSinks[data.streamId].onCancel, [wrapReason(data.reason)]).then(function() {
                      sendStreamResponse({
                        stream: "cancel_complete",
                        success: true
                      });
                    }, function(reason) {
                      sendStreamResponse({
                        stream: "cancel_complete",
                        success: false,
                        reason
                      });
                    });
                    this.streamSinks[data.streamId].sinkCapability.reject(wrapReason(data.reason));
                    this.streamSinks[data.streamId].isCancelled = true;
                    delete this.streamSinks[data.streamId];
                    break;
                  default:
                    throw new Error("Unexpected stream case");
                }
              },
              postMessage: function postMessage2(message, transfers) {
                if (transfers && this.postMessageTransfers) {
                  this.comObj.postMessage(message, transfers);
                } else {
                  this.comObj.postMessage(message);
                }
              },
              destroy: function destroy() {
                this.comObj.removeEventListener("message", this._onComObjOnMessage);
              }
            };
            function loadJpegStream(id, imageUrl, objs) {
              var img = new Image();
              img.onload = function loadJpegStream_onloadClosure() {
                objs.resolve(id, img);
              };
              img.onerror = function loadJpegStream_onerrorClosure() {
                objs.resolve(id, null);
                warn("Error during JPEG image loading");
              };
              img.src = imageUrl;
            }
            exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
            exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
            exports2.OPS = OPS;
            exports2.VERBOSITY_LEVELS = VERBOSITY_LEVELS;
            exports2.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
            exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
            exports2.AnnotationFieldFlag = AnnotationFieldFlag;
            exports2.AnnotationFlag = AnnotationFlag;
            exports2.AnnotationType = AnnotationType;
            exports2.FontType = FontType;
            exports2.ImageKind = ImageKind;
            exports2.CMapCompressionType = CMapCompressionType;
            exports2.AbortException = AbortException;
            exports2.InvalidPDFException = InvalidPDFException;
            exports2.MessageHandler = MessageHandler;
            exports2.MissingDataException = MissingDataException;
            exports2.MissingPDFException = MissingPDFException;
            exports2.NativeImageDecoding = NativeImageDecoding;
            exports2.NotImplementedException = NotImplementedException;
            exports2.PageViewport = PageViewport;
            exports2.PasswordException = PasswordException;
            exports2.PasswordResponses = PasswordResponses;
            exports2.StatTimer = StatTimer;
            exports2.StreamType = StreamType;
            exports2.TextRenderingMode = TextRenderingMode;
            exports2.UnexpectedResponseException = UnexpectedResponseException;
            exports2.UnknownErrorException = UnknownErrorException;
            exports2.Util = Util;
            exports2.XRefParseException = XRefParseException;
            exports2.FormatError = FormatError;
            exports2.arrayByteLength = arrayByteLength;
            exports2.arraysToBytes = arraysToBytes;
            exports2.assert = assert;
            exports2.bytesToString = bytesToString;
            exports2.createBlob = createBlob;
            exports2.createPromiseCapability = createPromiseCapability;
            exports2.createObjectURL = createObjectURL;
            exports2.deprecated = deprecated;
            exports2.getLookupTableFactory = getLookupTableFactory;
            exports2.getVerbosityLevel = getVerbosityLevel;
            exports2.info = info;
            exports2.isArrayBuffer = isArrayBuffer;
            exports2.isBool = isBool;
            exports2.isEmptyObj = isEmptyObj;
            exports2.isNum = isNum;
            exports2.isString = isString;
            exports2.isSpace = isSpace;
            exports2.isNodeJS = isNodeJS;
            exports2.isSameOrigin = isSameOrigin;
            exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
            exports2.isLittleEndian = isLittleEndian;
            exports2.isEvalSupported = isEvalSupported;
            exports2.loadJpegStream = loadJpegStream;
            exports2.log2 = log2;
            exports2.readInt8 = readInt8;
            exports2.readUint16 = readUint16;
            exports2.readUint32 = readUint32;
            exports2.removeNullCharacters = removeNullCharacters;
            exports2.ReadableStream = _streams_polyfill.ReadableStream;
            exports2.setVerbosityLevel = setVerbosityLevel;
            exports2.shadow = shadow;
            exports2.string32 = string32;
            exports2.stringToBytes = stringToBytes;
            exports2.stringToPDFString = stringToPDFString;
            exports2.stringToUTF8String = stringToUTF8String;
            exports2.utf8StringToString = utf8StringToString;
            exports2.warn = warn;
            exports2.unreachable = unreachable;
          },
          /* 1 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var global2 = module2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
            if (typeof __g == "number") __g = global2;
          },
          /* 2 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var EOF = {};
            var Name = function NameClosure() {
              function Name2(name) {
                this.name = name;
              }
              Name2.prototype = {};
              var nameCache = /* @__PURE__ */ Object.create(null);
              Name2.get = function Name_get(name) {
                var nameValue = nameCache[name];
                return nameValue ? nameValue : nameCache[name] = new Name2(name);
              };
              return Name2;
            }();
            var Cmd = function CmdClosure() {
              function Cmd2(cmd) {
                this.cmd = cmd;
              }
              Cmd2.prototype = {};
              var cmdCache = /* @__PURE__ */ Object.create(null);
              Cmd2.get = function Cmd_get(cmd) {
                var cmdValue = cmdCache[cmd];
                return cmdValue ? cmdValue : cmdCache[cmd] = new Cmd2(cmd);
              };
              return Cmd2;
            }();
            var Dict = function DictClosure() {
              var nonSerializable = function nonSerializableClosure() {
                return nonSerializable;
              };
              function Dict2(xref) {
                this._map = /* @__PURE__ */ Object.create(null);
                this.xref = xref;
                this.objId = null;
                this.suppressEncryption = false;
                this.__nonSerializable__ = nonSerializable;
              }
              Dict2.prototype = {
                assignXref: function Dict_assignXref(newXref) {
                  this.xref = newXref;
                },
                get: function Dict_get(key1, key2, key3) {
                  var value;
                  var xref = this.xref, suppressEncryption = this.suppressEncryption;
                  if (typeof (value = this._map[key1]) !== "undefined" || key1 in this._map || typeof key2 === "undefined") {
                    return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
                  }
                  if (typeof (value = this._map[key2]) !== "undefined" || key2 in this._map || typeof key3 === "undefined") {
                    return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
                  }
                  value = this._map[key3] || null;
                  return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
                },
                getAsync: function Dict_getAsync(key1, key2, key3) {
                  var value;
                  var xref = this.xref, suppressEncryption = this.suppressEncryption;
                  if (typeof (value = this._map[key1]) !== "undefined" || key1 in this._map || typeof key2 === "undefined") {
                    if (xref) {
                      return xref.fetchIfRefAsync(value, suppressEncryption);
                    }
                    return Promise.resolve(value);
                  }
                  if (typeof (value = this._map[key2]) !== "undefined" || key2 in this._map || typeof key3 === "undefined") {
                    if (xref) {
                      return xref.fetchIfRefAsync(value, suppressEncryption);
                    }
                    return Promise.resolve(value);
                  }
                  value = this._map[key3] || null;
                  if (xref) {
                    return xref.fetchIfRefAsync(value, suppressEncryption);
                  }
                  return Promise.resolve(value);
                },
                getArray: function Dict_getArray(key1, key2, key3) {
                  var value = this.get(key1, key2, key3);
                  var xref = this.xref, suppressEncryption = this.suppressEncryption;
                  if (!Array.isArray(value) || !xref) {
                    return value;
                  }
                  value = value.slice();
                  for (var i = 0, ii = value.length; i < ii; i++) {
                    if (!isRef(value[i])) {
                      continue;
                    }
                    value[i] = xref.fetch(value[i], suppressEncryption);
                  }
                  return value;
                },
                getRaw: function Dict_getRaw(key) {
                  return this._map[key];
                },
                getKeys: function Dict_getKeys() {
                  return Object.keys(this._map);
                },
                set: function Dict_set(key, value) {
                  this._map[key] = value;
                },
                has: function Dict_has(key) {
                  return key in this._map;
                },
                forEach: function Dict_forEach(callback) {
                  for (var key in this._map) {
                    callback(key, this.get(key));
                  }
                }
              };
              Dict2.empty = new Dict2(null);
              Dict2.merge = function(xref, dictArray) {
                var mergedDict = new Dict2(xref);
                for (var i = 0, ii = dictArray.length; i < ii; i++) {
                  var dict = dictArray[i];
                  if (!isDict(dict)) {
                    continue;
                  }
                  for (var keyName in dict._map) {
                    if (mergedDict._map[keyName] !== void 0) {
                      continue;
                    }
                    mergedDict._map[keyName] = dict._map[keyName];
                  }
                }
                return mergedDict;
              };
              return Dict2;
            }();
            var Ref = function RefClosure() {
              function Ref2(num, gen) {
                this.num = num;
                this.gen = gen;
              }
              Ref2.prototype = {
                toString: function Ref_toString() {
                  var str = this.num + "R";
                  if (this.gen !== 0) {
                    str += this.gen;
                  }
                  return str;
                }
              };
              return Ref2;
            }();
            var RefSet = function RefSetClosure() {
              function RefSet2() {
                this.dict = /* @__PURE__ */ Object.create(null);
              }
              RefSet2.prototype = {
                has: function RefSet_has(ref) {
                  return ref.toString() in this.dict;
                },
                put: function RefSet_put(ref) {
                  this.dict[ref.toString()] = true;
                },
                remove: function RefSet_remove(ref) {
                  delete this.dict[ref.toString()];
                }
              };
              return RefSet2;
            }();
            var RefSetCache = function RefSetCacheClosure() {
              function RefSetCache2() {
                this.dict = /* @__PURE__ */ Object.create(null);
              }
              RefSetCache2.prototype = {
                get: function RefSetCache_get(ref) {
                  return this.dict[ref.toString()];
                },
                has: function RefSetCache_has(ref) {
                  return ref.toString() in this.dict;
                },
                put: function RefSetCache_put(ref, obj) {
                  this.dict[ref.toString()] = obj;
                },
                putAlias: function RefSetCache_putAlias(ref, aliasRef) {
                  this.dict[ref.toString()] = this.get(aliasRef);
                },
                forEach: function RefSetCache_forEach(fn, thisArg) {
                  for (var i in this.dict) {
                    fn.call(thisArg, this.dict[i]);
                  }
                },
                clear: function RefSetCache_clear() {
                  this.dict = /* @__PURE__ */ Object.create(null);
                }
              };
              return RefSetCache2;
            }();
            function isEOF(v) {
              return v === EOF;
            }
            function isName(v, name) {
              return v instanceof Name && (name === void 0 || v.name === name);
            }
            function isCmd(v, cmd) {
              return v instanceof Cmd && (cmd === void 0 || v.cmd === cmd);
            }
            function isDict(v, type) {
              return v instanceof Dict && (type === void 0 || isName(v.get("Type"), type));
            }
            function isRef(v) {
              return v instanceof Ref;
            }
            function isRefsEqual(v1, v2) {
              return v1.num === v2.num && v1.gen === v2.gen;
            }
            function isStream(v) {
              return (typeof v === "undefined" ? "undefined" : _typeof(v)) === "object" && v !== null && v.getBytes !== void 0;
            }
            exports2.EOF = EOF;
            exports2.Cmd = Cmd;
            exports2.Dict = Dict;
            exports2.Name = Name;
            exports2.Ref = Ref;
            exports2.RefSet = RefSet;
            exports2.RefSetCache = RefSetCache;
            exports2.isEOF = isEOF;
            exports2.isCmd = isCmd;
            exports2.isDict = isDict;
            exports2.isName = isName;
            exports2.isRef = isRef;
            exports2.isRefsEqual = isRefsEqual;
            exports2.isStream = isStream;
          },
          /* 3 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            module2.exports = function(it) {
              return (typeof it === "undefined" ? "undefined" : _typeof(it)) === "object" ? it !== null : typeof it === "function";
            };
          },
          /* 4 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var store = __w_pdfjs_require__(54)("wks");
            var uid = __w_pdfjs_require__(17);
            var _Symbol = __w_pdfjs_require__(1).Symbol;
            var USE_SYMBOL = typeof _Symbol == "function";
            var $exports = module2.exports = function(name) {
              return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)("Symbol." + name));
            };
            $exports.store = store;
          },
          /* 5 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.LZWStream = exports2.StringStream = exports2.StreamsSequenceStream = exports2.Stream = exports2.RunLengthStream = exports2.PredictorStream = exports2.NullStream = exports2.JpxStream = exports2.JpegStream = exports2.FlateStream = exports2.DecodeStream = exports2.DecryptStream = exports2.AsciiHexStream = exports2.Ascii85Stream = void 0;
            var _util = __w_pdfjs_require__(0);
            var _primitives = __w_pdfjs_require__(2);
            var _jpg = __w_pdfjs_require__(129);
            var _jpx = __w_pdfjs_require__(74);
            var Stream = function StreamClosure() {
              function Stream2(arrayBuffer, start, length, dict) {
                this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
                this.start = start || 0;
                this.pos = this.start;
                this.end = start + length || this.bytes.length;
                this.dict = dict;
              }
              Stream2.prototype = {
                get length() {
                  return this.end - this.start;
                },
                get isEmpty() {
                  return this.length === 0;
                },
                getByte: function Stream_getByte() {
                  if (this.pos >= this.end) {
                    return -1;
                  }
                  return this.bytes[this.pos++];
                },
                getUint16: function Stream_getUint16() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  if (b0 === -1 || b1 === -1) {
                    return -1;
                  }
                  return (b0 << 8) + b1;
                },
                getInt32: function Stream_getInt32() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  var b2 = this.getByte();
                  var b3 = this.getByte();
                  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                },
                getBytes: function Stream_getBytes(length) {
                  var bytes = this.bytes;
                  var pos = this.pos;
                  var strEnd = this.end;
                  if (!length) {
                    return bytes.subarray(pos, strEnd);
                  }
                  var end = pos + length;
                  if (end > strEnd) {
                    end = strEnd;
                  }
                  this.pos = end;
                  return bytes.subarray(pos, end);
                },
                peekByte: function Stream_peekByte() {
                  var peekedByte = this.getByte();
                  this.pos--;
                  return peekedByte;
                },
                peekBytes: function Stream_peekBytes(length) {
                  var bytes = this.getBytes(length);
                  this.pos -= bytes.length;
                  return bytes;
                },
                skip: function Stream_skip(n) {
                  if (!n) {
                    n = 1;
                  }
                  this.pos += n;
                },
                reset: function Stream_reset() {
                  this.pos = this.start;
                },
                moveStart: function Stream_moveStart() {
                  this.start = this.pos;
                },
                makeSubStream: function Stream_makeSubStream(start, length, dict) {
                  return new Stream2(this.bytes.buffer, start, length, dict);
                }
              };
              return Stream2;
            }();
            var StringStream = function StringStreamClosure() {
              function StringStream2(str) {
                var bytes = (0, _util.stringToBytes)(str);
                Stream.call(this, bytes);
              }
              StringStream2.prototype = Stream.prototype;
              return StringStream2;
            }();
            var DecodeStream = function DecodeStreamClosure() {
              var emptyBuffer = new Uint8Array(0);
              function DecodeStream2(maybeMinBufferLength) {
                this.pos = 0;
                this.bufferLength = 0;
                this.eof = false;
                this.buffer = emptyBuffer;
                this.minBufferLength = 512;
                if (maybeMinBufferLength) {
                  while (this.minBufferLength < maybeMinBufferLength) {
                    this.minBufferLength *= 2;
                  }
                }
              }
              DecodeStream2.prototype = {
                get isEmpty() {
                  while (!this.eof && this.bufferLength === 0) {
                    this.readBlock();
                  }
                  return this.bufferLength === 0;
                },
                ensureBuffer: function DecodeStream_ensureBuffer(requested) {
                  var buffer = this.buffer;
                  if (requested <= buffer.byteLength) {
                    return buffer;
                  }
                  var size = this.minBufferLength;
                  while (size < requested) {
                    size *= 2;
                  }
                  var buffer2 = new Uint8Array(size);
                  buffer2.set(buffer);
                  return this.buffer = buffer2;
                },
                getByte: function DecodeStream_getByte() {
                  var pos = this.pos;
                  while (this.bufferLength <= pos) {
                    if (this.eof) {
                      return -1;
                    }
                    this.readBlock();
                  }
                  return this.buffer[this.pos++];
                },
                getUint16: function DecodeStream_getUint16() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  if (b0 === -1 || b1 === -1) {
                    return -1;
                  }
                  return (b0 << 8) + b1;
                },
                getInt32: function DecodeStream_getInt32() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  var b2 = this.getByte();
                  var b3 = this.getByte();
                  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                },
                getBytes: function DecodeStream_getBytes(length) {
                  var end, pos = this.pos;
                  if (length) {
                    this.ensureBuffer(pos + length);
                    end = pos + length;
                    while (!this.eof && this.bufferLength < end) {
                      this.readBlock();
                    }
                    var bufEnd = this.bufferLength;
                    if (end > bufEnd) {
                      end = bufEnd;
                    }
                  } else {
                    while (!this.eof) {
                      this.readBlock();
                    }
                    end = this.bufferLength;
                  }
                  this.pos = end;
                  return this.buffer.subarray(pos, end);
                },
                peekByte: function DecodeStream_peekByte() {
                  var peekedByte = this.getByte();
                  this.pos--;
                  return peekedByte;
                },
                peekBytes: function DecodeStream_peekBytes(length) {
                  var bytes = this.getBytes(length);
                  this.pos -= bytes.length;
                  return bytes;
                },
                makeSubStream: function DecodeStream_makeSubStream(start, length, dict) {
                  var end = start + length;
                  while (this.bufferLength <= end && !this.eof) {
                    this.readBlock();
                  }
                  return new Stream(this.buffer, start, length, dict);
                },
                skip: function DecodeStream_skip(n) {
                  if (!n) {
                    n = 1;
                  }
                  this.pos += n;
                },
                reset: function DecodeStream_reset() {
                  this.pos = 0;
                },
                getBaseStreams: function DecodeStream_getBaseStreams() {
                  if (this.str && this.str.getBaseStreams) {
                    return this.str.getBaseStreams();
                  }
                  return [];
                }
              };
              return DecodeStream2;
            }();
            var StreamsSequenceStream = function StreamsSequenceStreamClosure() {
              function StreamsSequenceStream2(streams) {
                this.streams = streams;
                DecodeStream.call(this, null);
              }
              StreamsSequenceStream2.prototype = Object.create(DecodeStream.prototype);
              StreamsSequenceStream2.prototype.readBlock = function streamSequenceStreamReadBlock() {
                var streams = this.streams;
                if (streams.length === 0) {
                  this.eof = true;
                  return;
                }
                var stream = streams.shift();
                var chunk = stream.getBytes();
                var bufferLength = this.bufferLength;
                var newLength = bufferLength + chunk.length;
                var buffer = this.ensureBuffer(newLength);
                buffer.set(chunk, bufferLength);
                this.bufferLength = newLength;
              };
              StreamsSequenceStream2.prototype.getBaseStreams = function StreamsSequenceStream_getBaseStreams() {
                var baseStreams = [];
                for (var i = 0, ii = this.streams.length; i < ii; i++) {
                  var stream = this.streams[i];
                  if (stream.getBaseStreams) {
                    _util.Util.appendToArray(baseStreams, stream.getBaseStreams());
                  }
                }
                return baseStreams;
              };
              return StreamsSequenceStream2;
            }();
            var FlateStream = function FlateStreamClosure() {
              var codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
              var lengthDecode = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]);
              var distDecode = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]);
              var fixedLitCodeTab = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9];
              var fixedDistCodeTab = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
              function FlateStream2(str, maybeLength) {
                this.str = str;
                this.dict = str.dict;
                var cmf = str.getByte();
                var flg = str.getByte();
                if (cmf === -1 || flg === -1) {
                  throw new _util.FormatError("Invalid header in flate stream: " + cmf + ", " + flg);
                }
                if ((cmf & 15) !== 8) {
                  throw new _util.FormatError("Unknown compression method in flate stream: " + cmf + ", " + flg);
                }
                if (((cmf << 8) + flg) % 31 !== 0) {
                  throw new _util.FormatError("Bad FCHECK in flate stream: " + cmf + ", " + flg);
                }
                if (flg & 32) {
                  throw new _util.FormatError("FDICT bit set in flate stream: " + cmf + ", " + flg);
                }
                this.codeSize = 0;
                this.codeBuf = 0;
                DecodeStream.call(this, maybeLength);
              }
              FlateStream2.prototype = Object.create(DecodeStream.prototype);
              FlateStream2.prototype.getBits = function FlateStream_getBits(bits) {
                var str = this.str;
                var codeSize = this.codeSize;
                var codeBuf = this.codeBuf;
                var b;
                while (codeSize < bits) {
                  if ((b = str.getByte()) === -1) {
                    throw new _util.FormatError("Bad encoding in flate stream");
                  }
                  codeBuf |= b << codeSize;
                  codeSize += 8;
                }
                b = codeBuf & (1 << bits) - 1;
                this.codeBuf = codeBuf >> bits;
                this.codeSize = codeSize -= bits;
                return b;
              };
              FlateStream2.prototype.getCode = function FlateStream_getCode(table) {
                var str = this.str;
                var codes = table[0];
                var maxLen = table[1];
                var codeSize = this.codeSize;
                var codeBuf = this.codeBuf;
                var b;
                while (codeSize < maxLen) {
                  if ((b = str.getByte()) === -1) {
                    break;
                  }
                  codeBuf |= b << codeSize;
                  codeSize += 8;
                }
                var code = codes[codeBuf & (1 << maxLen) - 1];
                var codeLen = code >> 16;
                var codeVal = code & 65535;
                if (codeLen < 1 || codeSize < codeLen) {
                  throw new _util.FormatError("Bad encoding in flate stream");
                }
                this.codeBuf = codeBuf >> codeLen;
                this.codeSize = codeSize - codeLen;
                return codeVal;
              };
              FlateStream2.prototype.generateHuffmanTable = function flateStreamGenerateHuffmanTable(lengths) {
                var n = lengths.length;
                var maxLen = 0;
                var i;
                for (i = 0; i < n; ++i) {
                  if (lengths[i] > maxLen) {
                    maxLen = lengths[i];
                  }
                }
                var size = 1 << maxLen;
                var codes = new Int32Array(size);
                for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
                  for (var val = 0; val < n; ++val) {
                    if (lengths[val] === len) {
                      var code2 = 0;
                      var t = code;
                      for (i = 0; i < len; ++i) {
                        code2 = code2 << 1 | t & 1;
                        t >>= 1;
                      }
                      for (i = code2; i < size; i += skip) {
                        codes[i] = len << 16 | val;
                      }
                      ++code;
                    }
                  }
                }
                return [codes, maxLen];
              };
              FlateStream2.prototype.readBlock = function FlateStream_readBlock() {
                var buffer, len;
                var str = this.str;
                var hdr = this.getBits(3);
                if (hdr & 1) {
                  this.eof = true;
                }
                hdr >>= 1;
                if (hdr === 0) {
                  var b;
                  if ((b = str.getByte()) === -1) {
                    throw new _util.FormatError("Bad block header in flate stream");
                  }
                  var blockLen = b;
                  if ((b = str.getByte()) === -1) {
                    throw new _util.FormatError("Bad block header in flate stream");
                  }
                  blockLen |= b << 8;
                  if ((b = str.getByte()) === -1) {
                    throw new _util.FormatError("Bad block header in flate stream");
                  }
                  var check = b;
                  if ((b = str.getByte()) === -1) {
                    throw new _util.FormatError("Bad block header in flate stream");
                  }
                  check |= b << 8;
                  if (check !== (~blockLen & 65535) && (blockLen !== 0 || check !== 0)) {
                    throw new _util.FormatError("Bad uncompressed block length in flate stream");
                  }
                  this.codeBuf = 0;
                  this.codeSize = 0;
                  var bufferLength = this.bufferLength;
                  buffer = this.ensureBuffer(bufferLength + blockLen);
                  var end = bufferLength + blockLen;
                  this.bufferLength = end;
                  if (blockLen === 0) {
                    if (str.peekByte() === -1) {
                      this.eof = true;
                    }
                  } else {
                    for (var n = bufferLength; n < end; ++n) {
                      if ((b = str.getByte()) === -1) {
                        this.eof = true;
                        break;
                      }
                      buffer[n] = b;
                    }
                  }
                  return;
                }
                var litCodeTable;
                var distCodeTable;
                if (hdr === 1) {
                  litCodeTable = fixedLitCodeTab;
                  distCodeTable = fixedDistCodeTab;
                } else if (hdr === 2) {
                  var numLitCodes = this.getBits(5) + 257;
                  var numDistCodes = this.getBits(5) + 1;
                  var numCodeLenCodes = this.getBits(4) + 4;
                  var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
                  var i;
                  for (i = 0; i < numCodeLenCodes; ++i) {
                    codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
                  }
                  var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
                  len = 0;
                  i = 0;
                  var codes = numLitCodes + numDistCodes;
                  var codeLengths = new Uint8Array(codes);
                  var bitsLength, bitsOffset, what;
                  while (i < codes) {
                    var code = this.getCode(codeLenCodeTab);
                    if (code === 16) {
                      bitsLength = 2;
                      bitsOffset = 3;
                      what = len;
                    } else if (code === 17) {
                      bitsLength = 3;
                      bitsOffset = 3;
                      what = len = 0;
                    } else if (code === 18) {
                      bitsLength = 7;
                      bitsOffset = 11;
                      what = len = 0;
                    } else {
                      codeLengths[i++] = len = code;
                      continue;
                    }
                    var repeatLength = this.getBits(bitsLength) + bitsOffset;
                    while (repeatLength-- > 0) {
                      codeLengths[i++] = what;
                    }
                  }
                  litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
                  distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
                } else {
                  throw new _util.FormatError("Unknown block type in flate stream");
                }
                buffer = this.buffer;
                var limit = buffer ? buffer.length : 0;
                var pos = this.bufferLength;
                while (true) {
                  var code1 = this.getCode(litCodeTable);
                  if (code1 < 256) {
                    if (pos + 1 >= limit) {
                      buffer = this.ensureBuffer(pos + 1);
                      limit = buffer.length;
                    }
                    buffer[pos++] = code1;
                    continue;
                  }
                  if (code1 === 256) {
                    this.bufferLength = pos;
                    return;
                  }
                  code1 -= 257;
                  code1 = lengthDecode[code1];
                  var code2 = code1 >> 16;
                  if (code2 > 0) {
                    code2 = this.getBits(code2);
                  }
                  len = (code1 & 65535) + code2;
                  code1 = this.getCode(distCodeTable);
                  code1 = distDecode[code1];
                  code2 = code1 >> 16;
                  if (code2 > 0) {
                    code2 = this.getBits(code2);
                  }
                  var dist = (code1 & 65535) + code2;
                  if (pos + len >= limit) {
                    buffer = this.ensureBuffer(pos + len);
                    limit = buffer.length;
                  }
                  for (var k = 0; k < len; ++k, ++pos) {
                    buffer[pos] = buffer[pos - dist];
                  }
                }
              };
              return FlateStream2;
            }();
            var PredictorStream = function PredictorStreamClosure() {
              function PredictorStream2(str, maybeLength, params) {
                if (!(0, _primitives.isDict)(params)) {
                  return str;
                }
                var predictor = this.predictor = params.get("Predictor") || 1;
                if (predictor <= 1) {
                  return str;
                }
                if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
                  throw new _util.FormatError("Unsupported predictor: " + predictor);
                }
                if (predictor === 2) {
                  this.readBlock = this.readBlockTiff;
                } else {
                  this.readBlock = this.readBlockPng;
                }
                this.str = str;
                this.dict = str.dict;
                var colors = this.colors = params.get("Colors") || 1;
                var bits = this.bits = params.get("BitsPerComponent") || 8;
                var columns = this.columns = params.get("Columns") || 1;
                this.pixBytes = colors * bits + 7 >> 3;
                this.rowBytes = columns * colors * bits + 7 >> 3;
                DecodeStream.call(this, maybeLength);
                return this;
              }
              PredictorStream2.prototype = Object.create(DecodeStream.prototype);
              PredictorStream2.prototype.readBlockTiff = function predictorStreamReadBlockTiff() {
                var rowBytes = this.rowBytes;
                var bufferLength = this.bufferLength;
                var buffer = this.ensureBuffer(bufferLength + rowBytes);
                var bits = this.bits;
                var colors = this.colors;
                var rawBytes = this.str.getBytes(rowBytes);
                this.eof = !rawBytes.length;
                if (this.eof) {
                  return;
                }
                var inbuf = 0, outbuf = 0;
                var inbits = 0, outbits = 0;
                var pos = bufferLength;
                var i;
                if (bits === 1 && colors === 1) {
                  for (i = 0; i < rowBytes; ++i) {
                    var c = rawBytes[i] ^ inbuf;
                    c ^= c >> 1;
                    c ^= c >> 2;
                    c ^= c >> 4;
                    inbuf = (c & 1) << 7;
                    buffer[pos++] = c;
                  }
                } else if (bits === 8) {
                  for (i = 0; i < colors; ++i) {
                    buffer[pos++] = rawBytes[i];
                  }
                  for (; i < rowBytes; ++i) {
                    buffer[pos] = buffer[pos - colors] + rawBytes[i];
                    pos++;
                  }
                } else if (bits === 16) {
                  var bytesPerPixel = colors * 2;
                  for (i = 0; i < bytesPerPixel; ++i) {
                    buffer[pos++] = rawBytes[i];
                  }
                  for (; i < rowBytes; i += 2) {
                    var sum = ((rawBytes[i] & 255) << 8) + (rawBytes[i + 1] & 255) + ((buffer[pos - bytesPerPixel] & 255) << 8) + (buffer[pos - bytesPerPixel + 1] & 255);
                    buffer[pos++] = sum >> 8 & 255;
                    buffer[pos++] = sum & 255;
                  }
                } else {
                  var compArray = new Uint8Array(colors + 1);
                  var bitMask = (1 << bits) - 1;
                  var j = 0, k = bufferLength;
                  var columns = this.columns;
                  for (i = 0; i < columns; ++i) {
                    for (var kk = 0; kk < colors; ++kk) {
                      if (inbits < bits) {
                        inbuf = inbuf << 8 | rawBytes[j++] & 255;
                        inbits += 8;
                      }
                      compArray[kk] = compArray[kk] + (inbuf >> inbits - bits) & bitMask;
                      inbits -= bits;
                      outbuf = outbuf << bits | compArray[kk];
                      outbits += bits;
                      if (outbits >= 8) {
                        buffer[k++] = outbuf >> outbits - 8 & 255;
                        outbits -= 8;
                      }
                    }
                  }
                  if (outbits > 0) {
                    buffer[k++] = (outbuf << 8 - outbits) + (inbuf & (1 << 8 - outbits) - 1);
                  }
                }
                this.bufferLength += rowBytes;
              };
              PredictorStream2.prototype.readBlockPng = function predictorStreamReadBlockPng() {
                var rowBytes = this.rowBytes;
                var pixBytes = this.pixBytes;
                var predictor = this.str.getByte();
                var rawBytes = this.str.getBytes(rowBytes);
                this.eof = !rawBytes.length;
                if (this.eof) {
                  return;
                }
                var bufferLength = this.bufferLength;
                var buffer = this.ensureBuffer(bufferLength + rowBytes);
                var prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
                if (prevRow.length === 0) {
                  prevRow = new Uint8Array(rowBytes);
                }
                var i, j = bufferLength, up, c;
                switch (predictor) {
                  case 0:
                    for (i = 0; i < rowBytes; ++i) {
                      buffer[j++] = rawBytes[i];
                    }
                    break;
                  case 1:
                    for (i = 0; i < pixBytes; ++i) {
                      buffer[j++] = rawBytes[i];
                    }
                    for (; i < rowBytes; ++i) {
                      buffer[j] = buffer[j - pixBytes] + rawBytes[i] & 255;
                      j++;
                    }
                    break;
                  case 2:
                    for (i = 0; i < rowBytes; ++i) {
                      buffer[j++] = prevRow[i] + rawBytes[i] & 255;
                    }
                    break;
                  case 3:
                    for (i = 0; i < pixBytes; ++i) {
                      buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];
                    }
                    for (; i < rowBytes; ++i) {
                      buffer[j] = (prevRow[i] + buffer[j - pixBytes] >> 1) + rawBytes[i] & 255;
                      j++;
                    }
                    break;
                  case 4:
                    for (i = 0; i < pixBytes; ++i) {
                      up = prevRow[i];
                      c = rawBytes[i];
                      buffer[j++] = up + c;
                    }
                    for (; i < rowBytes; ++i) {
                      up = prevRow[i];
                      var upLeft = prevRow[i - pixBytes];
                      var left = buffer[j - pixBytes];
                      var p = left + up - upLeft;
                      var pa = p - left;
                      if (pa < 0) {
                        pa = -pa;
                      }
                      var pb = p - up;
                      if (pb < 0) {
                        pb = -pb;
                      }
                      var pc = p - upLeft;
                      if (pc < 0) {
                        pc = -pc;
                      }
                      c = rawBytes[i];
                      if (pa <= pb && pa <= pc) {
                        buffer[j++] = left + c;
                      } else if (pb <= pc) {
                        buffer[j++] = up + c;
                      } else {
                        buffer[j++] = upLeft + c;
                      }
                    }
                    break;
                  default:
                    throw new _util.FormatError("Unsupported predictor: " + predictor);
                }
                this.bufferLength += rowBytes;
              };
              return PredictorStream2;
            }();
            var JpegStream = function JpegStreamClosure() {
              function JpegStream2(stream, maybeLength, dict, params) {
                var ch;
                while ((ch = stream.getByte()) !== -1) {
                  if (ch === 255) {
                    stream.skip(-1);
                    break;
                  }
                }
                this.stream = stream;
                this.maybeLength = maybeLength;
                this.dict = dict;
                this.params = params;
                DecodeStream.call(this, maybeLength);
              }
              JpegStream2.prototype = Object.create(DecodeStream.prototype);
              Object.defineProperty(JpegStream2.prototype, "bytes", {
                get: function JpegStream_bytes() {
                  return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                },
                configurable: true
              });
              JpegStream2.prototype.ensureBuffer = function JpegStream_ensureBuffer(req) {
                if (this.bufferLength) {
                  return;
                }
                var jpegImage = new _jpg.JpegImage();
                var decodeArr = this.dict.getArray("Decode", "D");
                if (this.forceRGB && Array.isArray(decodeArr)) {
                  var bitsPerComponent = this.dict.get("BitsPerComponent") || 8;
                  var decodeArrLength = decodeArr.length;
                  var transform = new Int32Array(decodeArrLength);
                  var transformNeeded = false;
                  var maxValue = (1 << bitsPerComponent) - 1;
                  for (var i = 0; i < decodeArrLength; i += 2) {
                    transform[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0;
                    transform[i + 1] = decodeArr[i] * maxValue | 0;
                    if (transform[i] !== 256 || transform[i + 1] !== 0) {
                      transformNeeded = true;
                    }
                  }
                  if (transformNeeded) {
                    jpegImage.decodeTransform = transform;
                  }
                }
                if ((0, _primitives.isDict)(this.params)) {
                  var colorTransform = this.params.get("ColorTransform");
                  if (Number.isInteger(colorTransform)) {
                    jpegImage.colorTransform = colorTransform;
                  }
                }
                jpegImage.parse(this.bytes);
                var data = jpegImage.getData(this.drawWidth, this.drawHeight, this.forceRGB);
                this.buffer = data;
                this.bufferLength = data.length;
                this.eof = true;
              };
              JpegStream2.prototype.getBytes = function JpegStream_getBytes(length) {
                this.ensureBuffer();
                return this.buffer;
              };
              JpegStream2.prototype.getIR = function JpegStream_getIR(forceDataSchema) {
                return (0, _util.createObjectURL)(this.bytes, "image/jpeg", forceDataSchema);
              };
              return JpegStream2;
            }();
            var JpxStream = function JpxStreamClosure() {
              function JpxStream2(stream, maybeLength, dict, params) {
                this.stream = stream;
                this.maybeLength = maybeLength;
                this.dict = dict;
                this.params = params;
                DecodeStream.call(this, maybeLength);
              }
              JpxStream2.prototype = Object.create(DecodeStream.prototype);
              Object.defineProperty(JpxStream2.prototype, "bytes", {
                get: function JpxStream_bytes() {
                  return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                },
                configurable: true
              });
              JpxStream2.prototype.ensureBuffer = function JpxStream_ensureBuffer(req) {
                if (this.bufferLength) {
                  return;
                }
                var jpxImage = new _jpx.JpxImage();
                jpxImage.parse(this.bytes);
                var width = jpxImage.width;
                var height = jpxImage.height;
                var componentsCount = jpxImage.componentsCount;
                var tileCount = jpxImage.tiles.length;
                if (tileCount === 1) {
                  this.buffer = jpxImage.tiles[0].items;
                } else {
                  var data = new Uint8ClampedArray(width * height * componentsCount);
                  for (var k = 0; k < tileCount; k++) {
                    var tileComponents = jpxImage.tiles[k];
                    var tileWidth = tileComponents.width;
                    var tileHeight = tileComponents.height;
                    var tileLeft = tileComponents.left;
                    var tileTop = tileComponents.top;
                    var src = tileComponents.items;
                    var srcPosition = 0;
                    var dataPosition = (width * tileTop + tileLeft) * componentsCount;
                    var imgRowSize = width * componentsCount;
                    var tileRowSize = tileWidth * componentsCount;
                    for (var j = 0; j < tileHeight; j++) {
                      var rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize);
                      data.set(rowBytes, dataPosition);
                      srcPosition += tileRowSize;
                      dataPosition += imgRowSize;
                    }
                  }
                  this.buffer = data;
                }
                this.bufferLength = this.buffer.length;
                this.eof = true;
              };
              return JpxStream2;
            }();
            var DecryptStream = function DecryptStreamClosure() {
              function DecryptStream2(str, maybeLength, decrypt) {
                this.str = str;
                this.dict = str.dict;
                this.decrypt = decrypt;
                this.nextChunk = null;
                this.initialized = false;
                DecodeStream.call(this, maybeLength);
              }
              var chunkSize = 512;
              DecryptStream2.prototype = Object.create(DecodeStream.prototype);
              DecryptStream2.prototype.readBlock = function DecryptStream_readBlock() {
                var chunk;
                if (this.initialized) {
                  chunk = this.nextChunk;
                } else {
                  chunk = this.str.getBytes(chunkSize);
                  this.initialized = true;
                }
                if (!chunk || chunk.length === 0) {
                  this.eof = true;
                  return;
                }
                this.nextChunk = this.str.getBytes(chunkSize);
                var hasMoreData = this.nextChunk && this.nextChunk.length > 0;
                var decrypt = this.decrypt;
                chunk = decrypt(chunk, !hasMoreData);
                var bufferLength = this.bufferLength;
                var i, n = chunk.length;
                var buffer = this.ensureBuffer(bufferLength + n);
                for (i = 0; i < n; i++) {
                  buffer[bufferLength++] = chunk[i];
                }
                this.bufferLength = bufferLength;
              };
              return DecryptStream2;
            }();
            var Ascii85Stream = function Ascii85StreamClosure() {
              function Ascii85Stream2(str, maybeLength) {
                this.str = str;
                this.dict = str.dict;
                this.input = new Uint8Array(5);
                if (maybeLength) {
                  maybeLength = 0.8 * maybeLength;
                }
                DecodeStream.call(this, maybeLength);
              }
              Ascii85Stream2.prototype = Object.create(DecodeStream.prototype);
              Ascii85Stream2.prototype.readBlock = function Ascii85Stream_readBlock() {
                var TILDA_CHAR = 126;
                var Z_LOWER_CHAR = 122;
                var EOF = -1;
                var str = this.str;
                var c = str.getByte();
                while ((0, _util.isSpace)(c)) {
                  c = str.getByte();
                }
                if (c === EOF || c === TILDA_CHAR) {
                  this.eof = true;
                  return;
                }
                var bufferLength = this.bufferLength, buffer;
                var i;
                if (c === Z_LOWER_CHAR) {
                  buffer = this.ensureBuffer(bufferLength + 4);
                  for (i = 0; i < 4; ++i) {
                    buffer[bufferLength + i] = 0;
                  }
                  this.bufferLength += 4;
                } else {
                  var input = this.input;
                  input[0] = c;
                  for (i = 1; i < 5; ++i) {
                    c = str.getByte();
                    while ((0, _util.isSpace)(c)) {
                      c = str.getByte();
                    }
                    input[i] = c;
                    if (c === EOF || c === TILDA_CHAR) {
                      break;
                    }
                  }
                  buffer = this.ensureBuffer(bufferLength + i - 1);
                  this.bufferLength += i - 1;
                  if (i < 5) {
                    for (; i < 5; ++i) {
                      input[i] = 33 + 84;
                    }
                    this.eof = true;
                  }
                  var t = 0;
                  for (i = 0; i < 5; ++i) {
                    t = t * 85 + (input[i] - 33);
                  }
                  for (i = 3; i >= 0; --i) {
                    buffer[bufferLength + i] = t & 255;
                    t >>= 8;
                  }
                }
              };
              return Ascii85Stream2;
            }();
            var AsciiHexStream = function AsciiHexStreamClosure() {
              function AsciiHexStream2(str, maybeLength) {
                this.str = str;
                this.dict = str.dict;
                this.firstDigit = -1;
                if (maybeLength) {
                  maybeLength = 0.5 * maybeLength;
                }
                DecodeStream.call(this, maybeLength);
              }
              AsciiHexStream2.prototype = Object.create(DecodeStream.prototype);
              AsciiHexStream2.prototype.readBlock = function AsciiHexStream_readBlock() {
                var UPSTREAM_BLOCK_SIZE = 8e3;
                var bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE);
                if (!bytes.length) {
                  this.eof = true;
                  return;
                }
                var maxDecodeLength = bytes.length + 1 >> 1;
                var buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
                var bufferLength = this.bufferLength;
                var firstDigit = this.firstDigit;
                for (var i = 0, ii = bytes.length; i < ii; i++) {
                  var ch = bytes[i], digit;
                  if (ch >= 48 && ch <= 57) {
                    digit = ch & 15;
                  } else if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
                    digit = (ch & 15) + 9;
                  } else if (ch === 62) {
                    this.eof = true;
                    break;
                  } else {
                    continue;
                  }
                  if (firstDigit < 0) {
                    firstDigit = digit;
                  } else {
                    buffer[bufferLength++] = firstDigit << 4 | digit;
                    firstDigit = -1;
                  }
                }
                if (firstDigit >= 0 && this.eof) {
                  buffer[bufferLength++] = firstDigit << 4;
                  firstDigit = -1;
                }
                this.firstDigit = firstDigit;
                this.bufferLength = bufferLength;
              };
              return AsciiHexStream2;
            }();
            var RunLengthStream = function RunLengthStreamClosure() {
              function RunLengthStream2(str, maybeLength) {
                this.str = str;
                this.dict = str.dict;
                DecodeStream.call(this, maybeLength);
              }
              RunLengthStream2.prototype = Object.create(DecodeStream.prototype);
              RunLengthStream2.prototype.readBlock = function RunLengthStream_readBlock() {
                var repeatHeader = this.str.getBytes(2);
                if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
                  this.eof = true;
                  return;
                }
                var buffer;
                var bufferLength = this.bufferLength;
                var n = repeatHeader[0];
                if (n < 128) {
                  buffer = this.ensureBuffer(bufferLength + n + 1);
                  buffer[bufferLength++] = repeatHeader[1];
                  if (n > 0) {
                    var source = this.str.getBytes(n);
                    buffer.set(source, bufferLength);
                    bufferLength += n;
                  }
                } else {
                  n = 257 - n;
                  var b = repeatHeader[1];
                  buffer = this.ensureBuffer(bufferLength + n + 1);
                  for (var i = 0; i < n; i++) {
                    buffer[bufferLength++] = b;
                  }
                }
                this.bufferLength = bufferLength;
              };
              return RunLengthStream2;
            }();
            var LZWStream = function LZWStreamClosure() {
              function LZWStream2(str, maybeLength, earlyChange) {
                this.str = str;
                this.dict = str.dict;
                this.cachedData = 0;
                this.bitsCached = 0;
                var maxLzwDictionarySize = 4096;
                var lzwState = {
                  earlyChange,
                  codeLength: 9,
                  nextCode: 258,
                  dictionaryValues: new Uint8Array(maxLzwDictionarySize),
                  dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
                  dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
                  currentSequence: new Uint8Array(maxLzwDictionarySize),
                  currentSequenceLength: 0
                };
                for (var i = 0; i < 256; ++i) {
                  lzwState.dictionaryValues[i] = i;
                  lzwState.dictionaryLengths[i] = 1;
                }
                this.lzwState = lzwState;
                DecodeStream.call(this, maybeLength);
              }
              LZWStream2.prototype = Object.create(DecodeStream.prototype);
              LZWStream2.prototype.readBits = function LZWStream_readBits(n) {
                var bitsCached = this.bitsCached;
                var cachedData = this.cachedData;
                while (bitsCached < n) {
                  var c = this.str.getByte();
                  if (c === -1) {
                    this.eof = true;
                    return null;
                  }
                  cachedData = cachedData << 8 | c;
                  bitsCached += 8;
                }
                this.bitsCached = bitsCached -= n;
                this.cachedData = cachedData;
                this.lastCode = null;
                return cachedData >>> bitsCached & (1 << n) - 1;
              };
              LZWStream2.prototype.readBlock = function LZWStream_readBlock() {
                var blockSize = 512;
                var estimatedDecodedSize = blockSize * 2, decodedSizeDelta = blockSize;
                var i, j, q;
                var lzwState = this.lzwState;
                if (!lzwState) {
                  return;
                }
                var earlyChange = lzwState.earlyChange;
                var nextCode = lzwState.nextCode;
                var dictionaryValues = lzwState.dictionaryValues;
                var dictionaryLengths = lzwState.dictionaryLengths;
                var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
                var codeLength = lzwState.codeLength;
                var prevCode = lzwState.prevCode;
                var currentSequence = lzwState.currentSequence;
                var currentSequenceLength = lzwState.currentSequenceLength;
                var decodedLength = 0;
                var currentBufferLength = this.bufferLength;
                var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                for (i = 0; i < blockSize; i++) {
                  var code = this.readBits(codeLength);
                  var hasPrev = currentSequenceLength > 0;
                  if (code < 256) {
                    currentSequence[0] = code;
                    currentSequenceLength = 1;
                  } else if (code >= 258) {
                    if (code < nextCode) {
                      currentSequenceLength = dictionaryLengths[code];
                      for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
                        currentSequence[j] = dictionaryValues[q];
                        q = dictionaryPrevCodes[q];
                      }
                    } else {
                      currentSequence[currentSequenceLength++] = currentSequence[0];
                    }
                  } else if (code === 256) {
                    codeLength = 9;
                    nextCode = 258;
                    currentSequenceLength = 0;
                    continue;
                  } else {
                    this.eof = true;
                    delete this.lzwState;
                    break;
                  }
                  if (hasPrev) {
                    dictionaryPrevCodes[nextCode] = prevCode;
                    dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
                    dictionaryValues[nextCode] = currentSequence[0];
                    nextCode++;
                    codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
                  }
                  prevCode = code;
                  decodedLength += currentSequenceLength;
                  if (estimatedDecodedSize < decodedLength) {
                    do {
                      estimatedDecodedSize += decodedSizeDelta;
                    } while (estimatedDecodedSize < decodedLength);
                    buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                  }
                  for (j = 0; j < currentSequenceLength; j++) {
                    buffer[currentBufferLength++] = currentSequence[j];
                  }
                }
                lzwState.nextCode = nextCode;
                lzwState.codeLength = codeLength;
                lzwState.prevCode = prevCode;
                lzwState.currentSequenceLength = currentSequenceLength;
                this.bufferLength = currentBufferLength;
              };
              return LZWStream2;
            }();
            var NullStream = function NullStreamClosure() {
              function NullStream2() {
                Stream.call(this, new Uint8Array(0));
              }
              NullStream2.prototype = Stream.prototype;
              return NullStream2;
            }();
            exports2.Ascii85Stream = Ascii85Stream;
            exports2.AsciiHexStream = AsciiHexStream;
            exports2.DecryptStream = DecryptStream;
            exports2.DecodeStream = DecodeStream;
            exports2.FlateStream = FlateStream;
            exports2.JpegStream = JpegStream;
            exports2.JpxStream = JpxStream;
            exports2.NullStream = NullStream;
            exports2.PredictorStream = PredictorStream;
            exports2.RunLengthStream = RunLengthStream;
            exports2.Stream = Stream;
            exports2.StreamsSequenceStream = StreamsSequenceStream;
            exports2.StringStream = StringStream;
            exports2.LZWStream = LZWStream;
          },
          /* 6 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var core = module2.exports = { version: "2.5.7" };
            if (typeof __e == "number") __e = core;
          },
          /* 7 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(1);
            var core = __w_pdfjs_require__(6);
            var hide = __w_pdfjs_require__(8);
            var redefine = __w_pdfjs_require__(16);
            var ctx = __w_pdfjs_require__(13);
            var PROTOTYPE = "prototype";
            var $export = function $export2(type, name, source) {
              var IS_FORCED = type & $export2.F;
              var IS_GLOBAL = type & $export2.G;
              var IS_STATIC = type & $export2.S;
              var IS_PROTO = type & $export2.P;
              var IS_BIND = type & $export2.B;
              var target = IS_GLOBAL ? global2 : IS_STATIC ? global2[name] || (global2[name] = {}) : (global2[name] || {})[PROTOTYPE];
              var exports3 = IS_GLOBAL ? core : core[name] || (core[name] = {});
              var expProto = exports3[PROTOTYPE] || (exports3[PROTOTYPE] = {});
              var key, own, out, exp;
              if (IS_GLOBAL) source = name;
              for (key in source) {
                own = !IS_FORCED && target && target[key] !== void 0;
                out = (own ? target : source)[key];
                exp = IS_BIND && own ? ctx(out, global2) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
                if (target) redefine(target, key, out, type & $export2.U);
                if (exports3[key] != out) hide(exports3, key, exp);
                if (IS_PROTO && expProto[key] != out) expProto[key] = out;
              }
            };
            global2.core = core;
            $export.F = 1;
            $export.G = 2;
            $export.S = 4;
            $export.P = 8;
            $export.B = 16;
            $export.W = 32;
            $export.U = 64;
            $export.R = 128;
            module2.exports = $export;
          },
          /* 8 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var dP = __w_pdfjs_require__(15);
            var createDesc = __w_pdfjs_require__(29);
            module2.exports = __w_pdfjs_require__(10) ? function(object, key, value) {
              return dP.f(object, key, createDesc(1, value));
            } : function(object, key, value) {
              object[key] = value;
              return object;
            };
          },
          /* 9 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(3);
            module2.exports = function(it) {
              if (!isObject(it)) throw TypeError(it + " is not an object!");
              return it;
            };
          },
          /* 10 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = !__w_pdfjs_require__(11)(function() {
              return Object.defineProperty({}, "a", {
                get: function get() {
                  return 7;
                }
              }).a != 7;
            });
          },
          /* 11 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = function(exec) {
              try {
                return !!exec();
              } catch (e) {
                return true;
              }
            };
          },
          /* 12 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var hasOwnProperty = {}.hasOwnProperty;
            module2.exports = function(it, key) {
              return hasOwnProperty.call(it, key);
            };
          },
          /* 13 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var aFunction = __w_pdfjs_require__(22);
            module2.exports = function(fn, that, length) {
              aFunction(fn);
              if (that === void 0) return fn;
              switch (length) {
                case 1:
                  return function(a) {
                    return fn.call(that, a);
                  };
                case 2:
                  return function(a, b) {
                    return fn.call(that, a, b);
                  };
                case 3:
                  return function(a, b, c) {
                    return fn.call(that, a, b, c);
                  };
              }
              return function() {
                return fn.apply(that, arguments);
              };
            };
          },
          /* 14 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var toInteger = __w_pdfjs_require__(18);
            var min = Math.min;
            module2.exports = function(it) {
              return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
            };
          },
          /* 15 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var anObject = __w_pdfjs_require__(9);
            var IE8_DOM_DEFINE = __w_pdfjs_require__(48);
            var toPrimitive = __w_pdfjs_require__(36);
            var dP = Object.defineProperty;
            exports2.f = __w_pdfjs_require__(10) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
              anObject(O);
              P = toPrimitive(P, true);
              anObject(Attributes);
              if (IE8_DOM_DEFINE) try {
                return dP(O, P, Attributes);
              } catch (e) {
              }
              if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
              if ("value" in Attributes) O[P] = Attributes.value;
              return O;
            };
          },
          /* 16 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(1);
            var hide = __w_pdfjs_require__(8);
            var has = __w_pdfjs_require__(12);
            var SRC = __w_pdfjs_require__(17)("src");
            var TO_STRING = "toString";
            var $toString = Function[TO_STRING];
            var TPL = ("" + $toString).split(TO_STRING);
            __w_pdfjs_require__(6).inspectSource = function(it) {
              return $toString.call(it);
            };
            (module2.exports = function(O, key, val, safe) {
              var isFunction = typeof val == "function";
              if (isFunction) has(val, "name") || hide(val, "name", key);
              if (O[key] === val) return;
              if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? "" + O[key] : TPL.join(String(key)));
              if (O === global2) {
                O[key] = val;
              } else if (!safe) {
                delete O[key];
                hide(O, key, val);
              } else if (O[key]) {
                O[key] = val;
              } else {
                hide(O, key, val);
              }
            })(Function.prototype, TO_STRING, function toString() {
              return typeof this == "function" && this[SRC] || $toString.call(this);
            });
          },
          /* 17 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var id = 0;
            var px = Math.random();
            module2.exports = function(key) {
              return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
            };
          },
          /* 18 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var ceil = Math.ceil;
            var floor = Math.floor;
            module2.exports = function(it) {
              return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
            };
          },
          /* 19 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var defined = __w_pdfjs_require__(38);
            module2.exports = function(it) {
              return Object(defined(it));
            };
          },
          /* 20 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = {};
          },
          /* 21 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = false;
          },
          /* 22 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = function(it) {
              if (typeof it != "function") throw TypeError(it + " is not a function!");
              return it;
            };
          },
          /* 23 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var redefine = __w_pdfjs_require__(16);
            module2.exports = function(target, src, safe) {
              for (var key in src) {
                redefine(target, key, src[key], safe);
              }
              return target;
            };
          },
          /* 24 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = function(it, Constructor, name, forbiddenField) {
              if (!(it instanceof Constructor) || forbiddenField !== void 0 && forbiddenField in it) {
                throw TypeError(name + ": incorrect invocation!");
              }
              return it;
            };
          },
          /* 25 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var toString = {}.toString;
            module2.exports = function(it) {
              return toString.call(it).slice(8, -1);
            };
          },
          /* 26 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var def = __w_pdfjs_require__(15).f;
            var has = __w_pdfjs_require__(12);
            var TAG = __w_pdfjs_require__(4)("toStringTag");
            module2.exports = function(it, tag, stat) {
              if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
                configurable: true,
                value: tag
              });
            };
          },
          /* 27 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.ColorSpace = void 0;
            var _util = __w_pdfjs_require__(0);
            var _primitives = __w_pdfjs_require__(2);
            var ColorSpace = function ColorSpaceClosure() {
              function resizeRgbImage(src, bpc, w1, h1, w2, h2, alpha01, dest) {
                var COMPONENTS = 3;
                alpha01 = alpha01 !== 1 ? 0 : alpha01;
                var xRatio = w1 / w2;
                var yRatio = h1 / h2;
                var i, j, py, newIndex = 0, oldIndex;
                var xScaled = new Uint16Array(w2);
                var w1Scanline = w1 * COMPONENTS;
                for (i = 0; i < w2; i++) {
                  xScaled[i] = Math.floor(i * xRatio) * COMPONENTS;
                }
                for (i = 0; i < h2; i++) {
                  py = Math.floor(i * yRatio) * w1Scanline;
                  for (j = 0; j < w2; j++) {
                    oldIndex = py + xScaled[j];
                    dest[newIndex++] = src[oldIndex++];
                    dest[newIndex++] = src[oldIndex++];
                    dest[newIndex++] = src[oldIndex++];
                    newIndex += alpha01;
                  }
                }
              }
              function ColorSpace2() {
                throw new Error("should not call ColorSpace constructor");
              }
              ColorSpace2.prototype = {
                getRgb: function ColorSpace_getRgb(src, srcOffset) {
                  var rgb = new Uint8Array(3);
                  this.getRgbItem(src, srcOffset, rgb, 0);
                  return rgb;
                },
                getRgbItem: function ColorSpace_getRgbItem(src, srcOffset, dest, destOffset) {
                  throw new Error("Should not call ColorSpace.getRgbItem");
                },
                getRgbBuffer: function ColorSpace_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  throw new Error("Should not call ColorSpace.getRgbBuffer");
                },
                getOutputLength: function ColorSpace_getOutputLength(inputLength, alpha01) {
                  throw new Error("Should not call ColorSpace.getOutputLength");
                },
                isPassthrough: function ColorSpace_isPassthrough(bits) {
                  return false;
                },
                fillRgb: function ColorSpace_fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) {
                  var count = originalWidth * originalHeight;
                  var rgbBuf = null;
                  var numComponentColors = 1 << bpc;
                  var needsResizing = originalHeight !== height || originalWidth !== width;
                  var i, ii;
                  if (this.isPassthrough(bpc)) {
                    rgbBuf = comps;
                  } else if (this.numComps === 1 && count > numComponentColors && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
                    var allColors = bpc <= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors);
                    var key;
                    for (i = 0; i < numComponentColors; i++) {
                      allColors[i] = i;
                    }
                    var colorMap = new Uint8Array(numComponentColors * 3);
                    this.getRgbBuffer(allColors, 0, numComponentColors, colorMap, 0, bpc, 0);
                    var destPos, rgbPos;
                    if (!needsResizing) {
                      destPos = 0;
                      for (i = 0; i < count; ++i) {
                        key = comps[i] * 3;
                        dest[destPos++] = colorMap[key];
                        dest[destPos++] = colorMap[key + 1];
                        dest[destPos++] = colorMap[key + 2];
                        destPos += alpha01;
                      }
                    } else {
                      rgbBuf = new Uint8Array(count * 3);
                      rgbPos = 0;
                      for (i = 0; i < count; ++i) {
                        key = comps[i] * 3;
                        rgbBuf[rgbPos++] = colorMap[key];
                        rgbBuf[rgbPos++] = colorMap[key + 1];
                        rgbBuf[rgbPos++] = colorMap[key + 2];
                      }
                    }
                  } else {
                    if (!needsResizing) {
                      this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01);
                    } else {
                      rgbBuf = new Uint8Array(count * 3);
                      this.getRgbBuffer(comps, 0, count, rgbBuf, 0, bpc, 0);
                    }
                  }
                  if (rgbBuf) {
                    if (needsResizing) {
                      resizeRgbImage(rgbBuf, bpc, originalWidth, originalHeight, width, height, alpha01, dest);
                    } else {
                      rgbPos = 0;
                      destPos = 0;
                      for (i = 0, ii = width * actualHeight; i < ii; i++) {
                        dest[destPos++] = rgbBuf[rgbPos++];
                        dest[destPos++] = rgbBuf[rgbPos++];
                        dest[destPos++] = rgbBuf[rgbPos++];
                        destPos += alpha01;
                      }
                    }
                  }
                },
                usesZeroToOneRange: true
              };
              ColorSpace2.parse = function(cs, xref, res, pdfFunctionFactory) {
                var IR = ColorSpace2.parseToIR(cs, xref, res, pdfFunctionFactory);
                return ColorSpace2.fromIR(IR);
              };
              ColorSpace2.fromIR = function(IR) {
                var name = Array.isArray(IR) ? IR[0] : IR;
                var whitePoint, blackPoint, gamma;
                switch (name) {
                  case "DeviceGrayCS":
                    return this.singletons.gray;
                  case "DeviceRgbCS":
                    return this.singletons.rgb;
                  case "DeviceCmykCS":
                    return this.singletons.cmyk;
                  case "CalGrayCS":
                    whitePoint = IR[1];
                    blackPoint = IR[2];
                    gamma = IR[3];
                    return new CalGrayCS(whitePoint, blackPoint, gamma);
                  case "CalRGBCS":
                    whitePoint = IR[1];
                    blackPoint = IR[2];
                    gamma = IR[3];
                    var matrix = IR[4];
                    return new CalRGBCS(whitePoint, blackPoint, gamma, matrix);
                  case "PatternCS":
                    var basePatternCS = IR[1];
                    if (basePatternCS) {
                      basePatternCS = ColorSpace2.fromIR(basePatternCS);
                    }
                    return new PatternCS(basePatternCS);
                  case "IndexedCS":
                    var baseIndexedCS = IR[1];
                    var hiVal = IR[2];
                    var lookup = IR[3];
                    return new IndexedCS(ColorSpace2.fromIR(baseIndexedCS), hiVal, lookup);
                  case "AlternateCS":
                    var numComps = IR[1];
                    var alt = IR[2];
                    var tintFn = IR[3];
                    return new AlternateCS(numComps, ColorSpace2.fromIR(alt), tintFn);
                  case "LabCS":
                    whitePoint = IR[1];
                    blackPoint = IR[2];
                    var range = IR[3];
                    return new LabCS(whitePoint, blackPoint, range);
                  default:
                    throw new _util.FormatError("Unknown colorspace name: " + name);
                }
              };
              ColorSpace2.parseToIR = function(cs, xref, res, pdfFunctionFactory) {
                if ((0, _primitives.isName)(cs)) {
                  var colorSpaces = res.get("ColorSpace");
                  if ((0, _primitives.isDict)(colorSpaces)) {
                    var refcs = colorSpaces.get(cs.name);
                    if (refcs) {
                      cs = refcs;
                    }
                  }
                }
                cs = xref.fetchIfRef(cs);
                if ((0, _primitives.isName)(cs)) {
                  switch (cs.name) {
                    case "DeviceGray":
                    case "G":
                      return "DeviceGrayCS";
                    case "DeviceRGB":
                    case "RGB":
                      return "DeviceRgbCS";
                    case "DeviceCMYK":
                    case "CMYK":
                      return "DeviceCmykCS";
                    case "Pattern":
                      return ["PatternCS", null];
                    default:
                      throw new _util.FormatError("unrecognized colorspace " + cs.name);
                  }
                }
                if (Array.isArray(cs)) {
                  var mode = xref.fetchIfRef(cs[0]).name;
                  var numComps, params, alt, whitePoint, blackPoint, gamma;
                  switch (mode) {
                    case "DeviceGray":
                    case "G":
                      return "DeviceGrayCS";
                    case "DeviceRGB":
                    case "RGB":
                      return "DeviceRgbCS";
                    case "DeviceCMYK":
                    case "CMYK":
                      return "DeviceCmykCS";
                    case "CalGray":
                      params = xref.fetchIfRef(cs[1]);
                      whitePoint = params.getArray("WhitePoint");
                      blackPoint = params.getArray("BlackPoint");
                      gamma = params.get("Gamma");
                      return ["CalGrayCS", whitePoint, blackPoint, gamma];
                    case "CalRGB":
                      params = xref.fetchIfRef(cs[1]);
                      whitePoint = params.getArray("WhitePoint");
                      blackPoint = params.getArray("BlackPoint");
                      gamma = params.getArray("Gamma");
                      var matrix = params.getArray("Matrix");
                      return ["CalRGBCS", whitePoint, blackPoint, gamma, matrix];
                    case "ICCBased":
                      var stream = xref.fetchIfRef(cs[1]);
                      var dict = stream.dict;
                      numComps = dict.get("N");
                      alt = dict.get("Alternate");
                      if (alt) {
                        var altIR = ColorSpace2.parseToIR(alt, xref, res, pdfFunctionFactory);
                        var altCS = ColorSpace2.fromIR(altIR, pdfFunctionFactory);
                        if (altCS.numComps === numComps) {
                          return altIR;
                        }
                        (0, _util.warn)("ICCBased color space: Ignoring incorrect /Alternate entry.");
                      }
                      if (numComps === 1) {
                        return "DeviceGrayCS";
                      } else if (numComps === 3) {
                        return "DeviceRgbCS";
                      } else if (numComps === 4) {
                        return "DeviceCmykCS";
                      }
                      break;
                    case "Pattern":
                      var basePatternCS = cs[1] || null;
                      if (basePatternCS) {
                        basePatternCS = ColorSpace2.parseToIR(basePatternCS, xref, res, pdfFunctionFactory);
                      }
                      return ["PatternCS", basePatternCS];
                    case "Indexed":
                    case "I":
                      var baseIndexedCS = ColorSpace2.parseToIR(cs[1], xref, res, pdfFunctionFactory);
                      var hiVal = xref.fetchIfRef(cs[2]) + 1;
                      var lookup = xref.fetchIfRef(cs[3]);
                      if ((0, _primitives.isStream)(lookup)) {
                        lookup = lookup.getBytes();
                      }
                      return ["IndexedCS", baseIndexedCS, hiVal, lookup];
                    case "Separation":
                    case "DeviceN":
                      var name = xref.fetchIfRef(cs[1]);
                      numComps = Array.isArray(name) ? name.length : 1;
                      alt = ColorSpace2.parseToIR(cs[2], xref, res, pdfFunctionFactory);
                      var tintFn = pdfFunctionFactory.create(xref.fetchIfRef(cs[3]));
                      return ["AlternateCS", numComps, alt, tintFn];
                    case "Lab":
                      params = xref.fetchIfRef(cs[1]);
                      whitePoint = params.getArray("WhitePoint");
                      blackPoint = params.getArray("BlackPoint");
                      var range = params.getArray("Range");
                      return ["LabCS", whitePoint, blackPoint, range];
                    default:
                      throw new _util.FormatError('unimplemented color space object "' + mode + '"');
                  }
                }
                throw new _util.FormatError('unrecognized color space object: "' + cs + '"');
              };
              ColorSpace2.isDefaultDecode = function ColorSpace_isDefaultDecode(decode, n) {
                if (!Array.isArray(decode)) {
                  return true;
                }
                if (n * 2 !== decode.length) {
                  (0, _util.warn)("The decode map is not the correct length");
                  return true;
                }
                for (var i = 0, ii = decode.length; i < ii; i += 2) {
                  if (decode[i] !== 0 || decode[i + 1] !== 1) {
                    return false;
                  }
                }
                return true;
              };
              ColorSpace2.singletons = {
                get gray() {
                  return (0, _util.shadow)(this, "gray", new DeviceGrayCS());
                },
                get rgb() {
                  return (0, _util.shadow)(this, "rgb", new DeviceRgbCS());
                },
                get cmyk() {
                  return (0, _util.shadow)(this, "cmyk", new DeviceCmykCS());
                }
              };
              return ColorSpace2;
            }();
            var AlternateCS = function AlternateCSClosure() {
              function AlternateCS2(numComps, base, tintFn) {
                this.name = "Alternate";
                this.numComps = numComps;
                this.defaultColor = new Float32Array(numComps);
                for (var i = 0; i < numComps; ++i) {
                  this.defaultColor[i] = 1;
                }
                this.base = base;
                this.tintFn = tintFn;
                this.tmpBuf = new Float32Array(base.numComps);
              }
              AlternateCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function AlternateCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  var tmpBuf = this.tmpBuf;
                  this.tintFn(src, srcOffset, tmpBuf, 0);
                  this.base.getRgbItem(tmpBuf, 0, dest, destOffset);
                },
                getRgbBuffer: function AlternateCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var tintFn = this.tintFn;
                  var base = this.base;
                  var scale = 1 / ((1 << bits) - 1);
                  var baseNumComps = base.numComps;
                  var usesZeroToOneRange = base.usesZeroToOneRange;
                  var isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) && alpha01 === 0;
                  var pos = isPassthrough ? destOffset : 0;
                  var baseBuf = isPassthrough ? dest : new Uint8Array(baseNumComps * count);
                  var numComps = this.numComps;
                  var scaled = new Float32Array(numComps);
                  var tinted = new Float32Array(baseNumComps);
                  var i, j;
                  for (i = 0; i < count; i++) {
                    for (j = 0; j < numComps; j++) {
                      scaled[j] = src[srcOffset++] * scale;
                    }
                    tintFn(scaled, 0, tinted, 0);
                    if (usesZeroToOneRange) {
                      for (j = 0; j < baseNumComps; j++) {
                        baseBuf[pos++] = tinted[j] * 255;
                      }
                    } else {
                      base.getRgbItem(tinted, 0, baseBuf, pos);
                      pos += baseNumComps;
                    }
                  }
                  if (!isPassthrough) {
                    base.getRgbBuffer(baseBuf, 0, count, dest, destOffset, 8, alpha01);
                  }
                },
                getOutputLength: function AlternateCS_getOutputLength(inputLength, alpha01) {
                  return this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01);
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function AlternateCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return AlternateCS2;
            }();
            var PatternCS = function PatternCSClosure() {
              function PatternCS2(baseCS) {
                this.name = "Pattern";
                this.base = baseCS;
              }
              PatternCS2.prototype = {};
              return PatternCS2;
            }();
            var IndexedCS = function IndexedCSClosure() {
              function IndexedCS2(base, highVal, lookup) {
                this.name = "Indexed";
                this.numComps = 1;
                this.defaultColor = new Uint8Array(this.numComps);
                this.base = base;
                this.highVal = highVal;
                var baseNumComps = base.numComps;
                var length = baseNumComps * highVal;
                if ((0, _primitives.isStream)(lookup)) {
                  this.lookup = new Uint8Array(length);
                  var bytes = lookup.getBytes(length);
                  this.lookup.set(bytes);
                } else if ((0, _util.isString)(lookup)) {
                  this.lookup = new Uint8Array(length);
                  for (var i = 0; i < length; ++i) {
                    this.lookup[i] = lookup.charCodeAt(i);
                  }
                } else if (lookup instanceof Uint8Array || lookup instanceof Array) {
                  this.lookup = lookup;
                } else {
                  throw new _util.FormatError("Unrecognized lookup table: " + lookup);
                }
              }
              IndexedCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function IndexedCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  var numComps = this.base.numComps;
                  var start = src[srcOffset] * numComps;
                  this.base.getRgbBuffer(this.lookup, start, 1, dest, destOffset, 8, 0);
                },
                getRgbBuffer: function IndexedCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var base = this.base;
                  var numComps = base.numComps;
                  var outputDelta = base.getOutputLength(numComps, alpha01);
                  var lookup = this.lookup;
                  for (var i = 0; i < count; ++i) {
                    var lookupPos = src[srcOffset++] * numComps;
                    base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);
                    destOffset += outputDelta;
                  }
                },
                getOutputLength: function IndexedCS_getOutputLength(inputLength, alpha01) {
                  return this.base.getOutputLength(inputLength * this.base.numComps, alpha01);
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function IndexedCS_isDefaultDecode(decodeMap) {
                  return true;
                },
                usesZeroToOneRange: true
              };
              return IndexedCS2;
            }();
            var DeviceGrayCS = function DeviceGrayCSClosure() {
              function DeviceGrayCS2() {
                this.name = "DeviceGray";
                this.numComps = 1;
                this.defaultColor = new Float32Array(this.numComps);
              }
              DeviceGrayCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function DeviceGrayCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  var c = src[srcOffset] * 255 | 0;
                  c = c < 0 ? 0 : c > 255 ? 255 : c;
                  dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c;
                },
                getRgbBuffer: function DeviceGrayCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var scale = 255 / ((1 << bits) - 1);
                  var j = srcOffset, q = destOffset;
                  for (var i = 0; i < count; ++i) {
                    var c = scale * src[j++] | 0;
                    dest[q++] = c;
                    dest[q++] = c;
                    dest[q++] = c;
                    q += alpha01;
                  }
                },
                getOutputLength: function DeviceGrayCS_getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01);
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function DeviceGrayCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return DeviceGrayCS2;
            }();
            var DeviceRgbCS = function DeviceRgbCSClosure() {
              function DeviceRgbCS2() {
                this.name = "DeviceRGB";
                this.numComps = 3;
                this.defaultColor = new Float32Array(this.numComps);
              }
              DeviceRgbCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function DeviceRgbCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  var r = src[srcOffset] * 255 | 0;
                  var g = src[srcOffset + 1] * 255 | 0;
                  var b = src[srcOffset + 2] * 255 | 0;
                  dest[destOffset] = r < 0 ? 0 : r > 255 ? 255 : r;
                  dest[destOffset + 1] = g < 0 ? 0 : g > 255 ? 255 : g;
                  dest[destOffset + 2] = b < 0 ? 0 : b > 255 ? 255 : b;
                },
                getRgbBuffer: function DeviceRgbCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  if (bits === 8 && alpha01 === 0) {
                    dest.set(src.subarray(srcOffset, srcOffset + count * 3), destOffset);
                    return;
                  }
                  var scale = 255 / ((1 << bits) - 1);
                  var j = srcOffset, q = destOffset;
                  for (var i = 0; i < count; ++i) {
                    dest[q++] = scale * src[j++] | 0;
                    dest[q++] = scale * src[j++] | 0;
                    dest[q++] = scale * src[j++] | 0;
                    q += alpha01;
                  }
                },
                getOutputLength: function DeviceRgbCS_getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01) / 3 | 0;
                },
                isPassthrough: function DeviceRgbCS_isPassthrough(bits) {
                  return bits === 8;
                },
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function DeviceRgbCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return DeviceRgbCS2;
            }();
            var DeviceCmykCS = function DeviceCmykCSClosure() {
              function convertToRgb(src, srcOffset, srcScale, dest, destOffset) {
                var c = src[srcOffset + 0] * srcScale;
                var m = src[srcOffset + 1] * srcScale;
                var y = src[srcOffset + 2] * srcScale;
                var k = src[srcOffset + 3] * srcScale;
                var r = c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747) + 255 | 0;
                var g = c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) + k * (-20.737325471181034 * k - 187.80453709719578) + 255 | 0;
                var b = c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505) + k * (-22.33816807309886 * k - 180.12613974708367) + 255 | 0;
                dest[destOffset] = r > 255 ? 255 : r < 0 ? 0 : r;
                dest[destOffset + 1] = g > 255 ? 255 : g < 0 ? 0 : g;
                dest[destOffset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;
              }
              function DeviceCmykCS2() {
                this.name = "DeviceCMYK";
                this.numComps = 4;
                this.defaultColor = new Float32Array(this.numComps);
                this.defaultColor[3] = 1;
              }
              DeviceCmykCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function DeviceCmykCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  convertToRgb(src, srcOffset, 1, dest, destOffset);
                },
                getRgbBuffer: function DeviceCmykCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var scale = 1 / ((1 << bits) - 1);
                  for (var i = 0; i < count; i++) {
                    convertToRgb(src, srcOffset, scale, dest, destOffset);
                    srcOffset += 4;
                    destOffset += 3 + alpha01;
                  }
                },
                getOutputLength: function DeviceCmykCS_getOutputLength(inputLength, alpha01) {
                  return inputLength / 4 * (3 + alpha01) | 0;
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function DeviceCmykCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return DeviceCmykCS2;
            }();
            var CalGrayCS = function CalGrayCSClosure() {
              function CalGrayCS2(whitePoint, blackPoint, gamma) {
                this.name = "CalGray";
                this.numComps = 1;
                this.defaultColor = new Float32Array(this.numComps);
                if (!whitePoint) {
                  throw new _util.FormatError("WhitePoint missing - required for color space CalGray");
                }
                blackPoint = blackPoint || [0, 0, 0];
                gamma = gamma || 1;
                this.XW = whitePoint[0];
                this.YW = whitePoint[1];
                this.ZW = whitePoint[2];
                this.XB = blackPoint[0];
                this.YB = blackPoint[1];
                this.ZB = blackPoint[2];
                this.G = gamma;
                if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
                  throw new _util.FormatError("Invalid WhitePoint components for " + this.name + ", no fallback available");
                }
                if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
                  (0, _util.info)("Invalid BlackPoint for " + this.name + ", falling back to default");
                  this.XB = this.YB = this.ZB = 0;
                }
                if (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) {
                  (0, _util.warn)(this.name + ", BlackPoint: XB: " + this.XB + ", YB: " + this.YB + ", ZB: " + this.ZB + ", only default values are supported.");
                }
                if (this.G < 1) {
                  (0, _util.info)("Invalid Gamma: " + this.G + " for " + this.name + ", falling back to default");
                  this.G = 1;
                }
              }
              function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
                var A = src[srcOffset] * scale;
                var AG = Math.pow(A, cs.G);
                var L = cs.YW * AG;
                var val = Math.max(295.8 * Math.pow(L, 0.3333333333333333) - 40.8, 0) | 0;
                dest[destOffset] = val;
                dest[destOffset + 1] = val;
                dest[destOffset + 2] = val;
              }
              CalGrayCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function CalGrayCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  convertToRgb(this, src, srcOffset, dest, destOffset, 1);
                },
                getRgbBuffer: function CalGrayCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var scale = 1 / ((1 << bits) - 1);
                  for (var i = 0; i < count; ++i) {
                    convertToRgb(this, src, srcOffset, dest, destOffset, scale);
                    srcOffset += 1;
                    destOffset += 3 + alpha01;
                  }
                },
                getOutputLength: function CalGrayCS_getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01);
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function CalGrayCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return CalGrayCS2;
            }();
            var CalRGBCS = function CalRGBCSClosure() {
              var BRADFORD_SCALE_MATRIX = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
              var BRADFORD_SCALE_INVERSE_MATRIX = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]);
              var SRGB_D65_XYZ_TO_RGB_MATRIX = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]);
              var FLAT_WHITEPOINT_MATRIX = new Float32Array([1, 1, 1]);
              var tempNormalizeMatrix = new Float32Array(3);
              var tempConvertMatrix1 = new Float32Array(3);
              var tempConvertMatrix2 = new Float32Array(3);
              var DECODE_L_CONSTANT = Math.pow((8 + 16) / 116, 3) / 8;
              function CalRGBCS2(whitePoint, blackPoint, gamma, matrix) {
                this.name = "CalRGB";
                this.numComps = 3;
                this.defaultColor = new Float32Array(this.numComps);
                if (!whitePoint) {
                  throw new _util.FormatError("WhitePoint missing - required for color space CalRGB");
                }
                blackPoint = blackPoint || new Float32Array(3);
                gamma = gamma || new Float32Array([1, 1, 1]);
                matrix = matrix || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                var XW = whitePoint[0];
                var YW = whitePoint[1];
                var ZW = whitePoint[2];
                this.whitePoint = whitePoint;
                var XB = blackPoint[0];
                var YB = blackPoint[1];
                var ZB = blackPoint[2];
                this.blackPoint = blackPoint;
                this.GR = gamma[0];
                this.GG = gamma[1];
                this.GB = gamma[2];
                this.MXA = matrix[0];
                this.MYA = matrix[1];
                this.MZA = matrix[2];
                this.MXB = matrix[3];
                this.MYB = matrix[4];
                this.MZB = matrix[5];
                this.MXC = matrix[6];
                this.MYC = matrix[7];
                this.MZC = matrix[8];
                if (XW < 0 || ZW < 0 || YW !== 1) {
                  throw new _util.FormatError("Invalid WhitePoint components for " + this.name + ", no fallback available");
                }
                if (XB < 0 || YB < 0 || ZB < 0) {
                  (0, _util.info)("Invalid BlackPoint for " + this.name + " [" + XB + ", " + YB + ", " + ZB + "], falling back to default");
                  this.blackPoint = new Float32Array(3);
                }
                if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
                  (0, _util.info)("Invalid Gamma [" + this.GR + ", " + this.GG + ", " + this.GB + "] for " + this.name + ", falling back to default");
                  this.GR = this.GG = this.GB = 1;
                }
                if (this.MXA < 0 || this.MYA < 0 || this.MZA < 0 || this.MXB < 0 || this.MYB < 0 || this.MZB < 0 || this.MXC < 0 || this.MYC < 0 || this.MZC < 0) {
                  (0, _util.info)("Invalid Matrix for " + this.name + " [" + this.MXA + ", " + this.MYA + ", " + this.MZA + this.MXB + ", " + this.MYB + ", " + this.MZB + this.MXC + ", " + this.MYC + ", " + this.MZC + "], falling back to default");
                  this.MXA = this.MYB = this.MZC = 1;
                  this.MXB = this.MYA = this.MZA = this.MXC = this.MYC = this.MZB = 0;
                }
              }
              function matrixProduct(a, b, result) {
                result[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
                result[1] = a[3] * b[0] + a[4] * b[1] + a[5] * b[2];
                result[2] = a[6] * b[0] + a[7] * b[1] + a[8] * b[2];
              }
              function convertToFlat(sourceWhitePoint, LMS, result) {
                result[0] = LMS[0] * 1 / sourceWhitePoint[0];
                result[1] = LMS[1] * 1 / sourceWhitePoint[1];
                result[2] = LMS[2] * 1 / sourceWhitePoint[2];
              }
              function convertToD65(sourceWhitePoint, LMS, result) {
                var D65X = 0.95047;
                var D65Y = 1;
                var D65Z = 1.08883;
                result[0] = LMS[0] * D65X / sourceWhitePoint[0];
                result[1] = LMS[1] * D65Y / sourceWhitePoint[1];
                result[2] = LMS[2] * D65Z / sourceWhitePoint[2];
              }
              function sRGBTransferFunction(color) {
                if (color <= 31308e-7) {
                  return adjustToRange(0, 1, 12.92 * color);
                }
                return adjustToRange(0, 1, (1 + 0.055) * Math.pow(color, 1 / 2.4) - 0.055);
              }
              function adjustToRange(min, max, value) {
                return Math.max(min, Math.min(max, value));
              }
              function decodeL(L) {
                if (L < 0) {
                  return -decodeL(-L);
                }
                if (L > 8) {
                  return Math.pow((L + 16) / 116, 3);
                }
                return L * DECODE_L_CONSTANT;
              }
              function compensateBlackPoint(sourceBlackPoint, XYZ_Flat, result) {
                if (sourceBlackPoint[0] === 0 && sourceBlackPoint[1] === 0 && sourceBlackPoint[2] === 0) {
                  result[0] = XYZ_Flat[0];
                  result[1] = XYZ_Flat[1];
                  result[2] = XYZ_Flat[2];
                  return;
                }
                var zeroDecodeL = decodeL(0);
                var X_DST = zeroDecodeL;
                var X_SRC = decodeL(sourceBlackPoint[0]);
                var Y_DST = zeroDecodeL;
                var Y_SRC = decodeL(sourceBlackPoint[1]);
                var Z_DST = zeroDecodeL;
                var Z_SRC = decodeL(sourceBlackPoint[2]);
                var X_Scale = (1 - X_DST) / (1 - X_SRC);
                var X_Offset = 1 - X_Scale;
                var Y_Scale = (1 - Y_DST) / (1 - Y_SRC);
                var Y_Offset = 1 - Y_Scale;
                var Z_Scale = (1 - Z_DST) / (1 - Z_SRC);
                var Z_Offset = 1 - Z_Scale;
                result[0] = XYZ_Flat[0] * X_Scale + X_Offset;
                result[1] = XYZ_Flat[1] * Y_Scale + Y_Offset;
                result[2] = XYZ_Flat[2] * Z_Scale + Z_Offset;
              }
              function normalizeWhitePointToFlat(sourceWhitePoint, XYZ_In, result) {
                if (sourceWhitePoint[0] === 1 && sourceWhitePoint[2] === 1) {
                  result[0] = XYZ_In[0];
                  result[1] = XYZ_In[1];
                  result[2] = XYZ_In[2];
                  return;
                }
                var LMS = result;
                matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
                var LMS_Flat = tempNormalizeMatrix;
                convertToFlat(sourceWhitePoint, LMS, LMS_Flat);
                matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_Flat, result);
              }
              function normalizeWhitePointToD65(sourceWhitePoint, XYZ_In, result) {
                var LMS = result;
                matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
                var LMS_D65 = tempNormalizeMatrix;
                convertToD65(sourceWhitePoint, LMS, LMS_D65);
                matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_D65, result);
              }
              function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
                var A = adjustToRange(0, 1, src[srcOffset] * scale);
                var B = adjustToRange(0, 1, src[srcOffset + 1] * scale);
                var C = adjustToRange(0, 1, src[srcOffset + 2] * scale);
                var AGR = Math.pow(A, cs.GR);
                var BGG = Math.pow(B, cs.GG);
                var CGB = Math.pow(C, cs.GB);
                var X = cs.MXA * AGR + cs.MXB * BGG + cs.MXC * CGB;
                var Y = cs.MYA * AGR + cs.MYB * BGG + cs.MYC * CGB;
                var Z = cs.MZA * AGR + cs.MZB * BGG + cs.MZC * CGB;
                var XYZ = tempConvertMatrix1;
                XYZ[0] = X;
                XYZ[1] = Y;
                XYZ[2] = Z;
                var XYZ_Flat = tempConvertMatrix2;
                normalizeWhitePointToFlat(cs.whitePoint, XYZ, XYZ_Flat);
                var XYZ_Black = tempConvertMatrix1;
                compensateBlackPoint(cs.blackPoint, XYZ_Flat, XYZ_Black);
                var XYZ_D65 = tempConvertMatrix2;
                normalizeWhitePointToD65(FLAT_WHITEPOINT_MATRIX, XYZ_Black, XYZ_D65);
                var SRGB = tempConvertMatrix1;
                matrixProduct(SRGB_D65_XYZ_TO_RGB_MATRIX, XYZ_D65, SRGB);
                var sR = sRGBTransferFunction(SRGB[0]);
                var sG = sRGBTransferFunction(SRGB[1]);
                var sB = sRGBTransferFunction(SRGB[2]);
                dest[destOffset] = Math.round(sR * 255);
                dest[destOffset + 1] = Math.round(sG * 255);
                dest[destOffset + 2] = Math.round(sB * 255);
              }
              CalRGBCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function CalRGBCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  convertToRgb(this, src, srcOffset, dest, destOffset, 1);
                },
                getRgbBuffer: function CalRGBCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var scale = 1 / ((1 << bits) - 1);
                  for (var i = 0; i < count; ++i) {
                    convertToRgb(this, src, srcOffset, dest, destOffset, scale);
                    srcOffset += 3;
                    destOffset += 3 + alpha01;
                  }
                },
                getOutputLength: function CalRGBCS_getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01) / 3 | 0;
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function CalRGBCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return CalRGBCS2;
            }();
            var LabCS = function LabCSClosure() {
              function LabCS2(whitePoint, blackPoint, range) {
                this.name = "Lab";
                this.numComps = 3;
                this.defaultColor = new Float32Array(this.numComps);
                if (!whitePoint) {
                  throw new _util.FormatError("WhitePoint missing - required for color space Lab");
                }
                blackPoint = blackPoint || [0, 0, 0];
                range = range || [-100, 100, -100, 100];
                this.XW = whitePoint[0];
                this.YW = whitePoint[1];
                this.ZW = whitePoint[2];
                this.amin = range[0];
                this.amax = range[1];
                this.bmin = range[2];
                this.bmax = range[3];
                this.XB = blackPoint[0];
                this.YB = blackPoint[1];
                this.ZB = blackPoint[2];
                if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
                  throw new _util.FormatError("Invalid WhitePoint components, no fallback available");
                }
                if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
                  (0, _util.info)("Invalid BlackPoint, falling back to default");
                  this.XB = this.YB = this.ZB = 0;
                }
                if (this.amin > this.amax || this.bmin > this.bmax) {
                  (0, _util.info)("Invalid Range, falling back to defaults");
                  this.amin = -100;
                  this.amax = 100;
                  this.bmin = -100;
                  this.bmax = 100;
                }
              }
              function fn_g(x) {
                var result;
                if (x >= 6 / 29) {
                  result = x * x * x;
                } else {
                  result = 108 / 841 * (x - 4 / 29);
                }
                return result;
              }
              function decode(value, high1, low2, high2) {
                return low2 + value * (high2 - low2) / high1;
              }
              function convertToRgb(cs, src, srcOffset, maxVal, dest, destOffset) {
                var Ls = src[srcOffset];
                var as = src[srcOffset + 1];
                var bs = src[srcOffset + 2];
                if (maxVal !== false) {
                  Ls = decode(Ls, maxVal, 0, 100);
                  as = decode(as, maxVal, cs.amin, cs.amax);
                  bs = decode(bs, maxVal, cs.bmin, cs.bmax);
                }
                as = as > cs.amax ? cs.amax : as < cs.amin ? cs.amin : as;
                bs = bs > cs.bmax ? cs.bmax : bs < cs.bmin ? cs.bmin : bs;
                var M = (Ls + 16) / 116;
                var L = M + as / 500;
                var N = M - bs / 200;
                var X = cs.XW * fn_g(L);
                var Y = cs.YW * fn_g(M);
                var Z = cs.ZW * fn_g(N);
                var r, g, b;
                if (cs.ZW < 1) {
                  r = X * 3.1339 + Y * -1.617 + Z * -0.4906;
                  g = X * -0.9785 + Y * 1.916 + Z * 0.0333;
                  b = X * 0.072 + Y * -0.229 + Z * 1.4057;
                } else {
                  r = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
                  g = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
                  b = X * 0.0557 + Y * -0.204 + Z * 1.057;
                }
                dest[destOffset] = r <= 0 ? 0 : r >= 1 ? 255 : Math.sqrt(r) * 255 | 0;
                dest[destOffset + 1] = g <= 0 ? 0 : g >= 1 ? 255 : Math.sqrt(g) * 255 | 0;
                dest[destOffset + 2] = b <= 0 ? 0 : b >= 1 ? 255 : Math.sqrt(b) * 255 | 0;
              }
              LabCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function LabCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  convertToRgb(this, src, srcOffset, false, dest, destOffset);
                },
                getRgbBuffer: function LabCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var maxVal = (1 << bits) - 1;
                  for (var i = 0; i < count; i++) {
                    convertToRgb(this, src, srcOffset, maxVal, dest, destOffset);
                    srcOffset += 3;
                    destOffset += 3 + alpha01;
                  }
                },
                getOutputLength: function LabCS_getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01) / 3 | 0;
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function LabCS_isDefaultDecode(decodeMap) {
                  return true;
                },
                usesZeroToOneRange: false
              };
              return LabCS2;
            }();
            exports2.ColorSpace = ColorSpace;
          },
          /* 28 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var ExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
            var MacExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall"];
            var MacRomanEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
            var StandardEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls"];
            var WinAnsiEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
            var SymbolSetEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt"];
            var ZapfDingbatsEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191"];
            function getEncoding(encodingName) {
              switch (encodingName) {
                case "WinAnsiEncoding":
                  return WinAnsiEncoding;
                case "StandardEncoding":
                  return StandardEncoding;
                case "MacRomanEncoding":
                  return MacRomanEncoding;
                case "SymbolSetEncoding":
                  return SymbolSetEncoding;
                case "ZapfDingbatsEncoding":
                  return ZapfDingbatsEncoding;
                case "ExpertEncoding":
                  return ExpertEncoding;
                case "MacExpertEncoding":
                  return MacExpertEncoding;
                default:
                  return null;
              }
            }
            exports2.WinAnsiEncoding = WinAnsiEncoding;
            exports2.StandardEncoding = StandardEncoding;
            exports2.MacRomanEncoding = MacRomanEncoding;
            exports2.SymbolSetEncoding = SymbolSetEncoding;
            exports2.ZapfDingbatsEncoding = ZapfDingbatsEncoding;
            exports2.ExpertEncoding = ExpertEncoding;
            exports2.getEncoding = getEncoding;
          },
          /* 29 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = function(bitmap, value) {
              return {
                enumerable: !(bitmap & 1),
                configurable: !(bitmap & 2),
                writable: !(bitmap & 4),
                value
              };
            };
          },
          /* 30 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var IObject = __w_pdfjs_require__(37);
            var defined = __w_pdfjs_require__(38);
            module2.exports = function(it) {
              return IObject(defined(it));
            };
          },
          /* 31 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var toInteger = __w_pdfjs_require__(18);
            var max = Math.max;
            var min = Math.min;
            module2.exports = function(index, length) {
              index = toInteger(index);
              return index < 0 ? max(index + length, 0) : min(index, length);
            };
          },
          /* 32 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var cof = __w_pdfjs_require__(25);
            var TAG = __w_pdfjs_require__(4)("toStringTag");
            var ARG = cof(/* @__PURE__ */ function() {
              return arguments;
            }()) == "Arguments";
            var tryGet = function tryGet2(it, key) {
              try {
                return it[key];
              } catch (e) {
              }
            };
            module2.exports = function(it) {
              var O, T, B;
              return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = tryGet(O = Object(it), TAG)) == "string" ? T : ARG ? cof(O) : (B = cof(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
            };
          },
          /* 33 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var ctx = __w_pdfjs_require__(13);
            var call = __w_pdfjs_require__(107);
            var isArrayIter = __w_pdfjs_require__(56);
            var anObject = __w_pdfjs_require__(9);
            var toLength = __w_pdfjs_require__(14);
            var getIterFn = __w_pdfjs_require__(60);
            var BREAK = {};
            var RETURN = {};
            var _exports = module2.exports = function(iterable, entries, fn, that, ITERATOR) {
              var iterFn = ITERATOR ? function() {
                return iterable;
              } : getIterFn(iterable);
              var f = ctx(fn, that, entries ? 2 : 1);
              var index = 0;
              var length, step, iterator, result;
              if (typeof iterFn != "function") throw TypeError(iterable + " is not iterable!");
              if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
                result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
                if (result === BREAK || result === RETURN) return result;
              }
              else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
                result = call(iterator, f, step.value, entries);
                if (result === BREAK || result === RETURN) return result;
              }
            };
            _exports.BREAK = BREAK;
            _exports.RETURN = RETURN;
          },
          /* 34 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.Parser = exports2.Linearization = exports2.Lexer = void 0;
            var _stream = __w_pdfjs_require__(5);
            var _util = __w_pdfjs_require__(0);
            var _primitives = __w_pdfjs_require__(2);
            var _ccitt_stream = __w_pdfjs_require__(130);
            var _jbig2_stream = __w_pdfjs_require__(132);
            var MAX_LENGTH_TO_CACHE = 1e3;
            var Parser = function ParserClosure() {
              function Parser2(lexer, allowStreams, xref, recoveryMode) {
                this.lexer = lexer;
                this.allowStreams = allowStreams;
                this.xref = xref;
                this.recoveryMode = recoveryMode || false;
                this.imageCache = /* @__PURE__ */ Object.create(null);
                this.refill();
              }
              Parser2.prototype = {
                refill: function Parser_refill() {
                  this.buf1 = this.lexer.getObj();
                  this.buf2 = this.lexer.getObj();
                },
                shift: function Parser_shift() {
                  if ((0, _primitives.isCmd)(this.buf2, "ID")) {
                    this.buf1 = this.buf2;
                    this.buf2 = null;
                  } else {
                    this.buf1 = this.buf2;
                    this.buf2 = this.lexer.getObj();
                  }
                },
                tryShift: function Parser_tryShift() {
                  try {
                    this.shift();
                    return true;
                  } catch (e) {
                    if (e instanceof _util.MissingDataException) {
                      throw e;
                    }
                    return false;
                  }
                },
                getObj: function Parser_getObj(cipherTransform) {
                  var buf1 = this.buf1;
                  this.shift();
                  if (buf1 instanceof _primitives.Cmd) {
                    switch (buf1.cmd) {
                      case "BI":
                        return this.makeInlineImage(cipherTransform);
                      case "[":
                        var array = [];
                        while (!(0, _primitives.isCmd)(this.buf1, "]") && !(0, _primitives.isEOF)(this.buf1)) {
                          array.push(this.getObj(cipherTransform));
                        }
                        if ((0, _primitives.isEOF)(this.buf1)) {
                          if (!this.recoveryMode) {
                            throw new _util.FormatError("End of file inside array");
                          }
                          return array;
                        }
                        this.shift();
                        return array;
                      case "<<":
                        var dict = new _primitives.Dict(this.xref);
                        while (!(0, _primitives.isCmd)(this.buf1, ">>") && !(0, _primitives.isEOF)(this.buf1)) {
                          if (!(0, _primitives.isName)(this.buf1)) {
                            (0, _util.info)("Malformed dictionary: key must be a name object");
                            this.shift();
                            continue;
                          }
                          var key = this.buf1.name;
                          this.shift();
                          if ((0, _primitives.isEOF)(this.buf1)) {
                            break;
                          }
                          dict.set(key, this.getObj(cipherTransform));
                        }
                        if ((0, _primitives.isEOF)(this.buf1)) {
                          if (!this.recoveryMode) {
                            throw new _util.FormatError("End of file inside dictionary");
                          }
                          return dict;
                        }
                        if ((0, _primitives.isCmd)(this.buf2, "stream")) {
                          return this.allowStreams ? this.makeStream(dict, cipherTransform) : dict;
                        }
                        this.shift();
                        return dict;
                      default:
                        return buf1;
                    }
                  }
                  if (Number.isInteger(buf1)) {
                    var num = buf1;
                    if (Number.isInteger(this.buf1) && (0, _primitives.isCmd)(this.buf2, "R")) {
                      var ref = new _primitives.Ref(num, this.buf1);
                      this.shift();
                      this.shift();
                      return ref;
                    }
                    return num;
                  }
                  if ((0, _util.isString)(buf1)) {
                    var str = buf1;
                    if (cipherTransform) {
                      str = cipherTransform.decryptString(str);
                    }
                    return str;
                  }
                  return buf1;
                },
                findDefaultInlineStreamEnd: function findDefaultInlineStreamEnd(stream) {
                  var E = 69, I = 73, SPACE = 32, LF = 10, CR = 13;
                  var n = 10, NUL = 0;
                  var startPos = stream.pos, state = 0, ch = void 0, maybeEIPos = void 0;
                  while ((ch = stream.getByte()) !== -1) {
                    if (state === 0) {
                      state = ch === E ? 1 : 0;
                    } else if (state === 1) {
                      state = ch === I ? 2 : 0;
                    } else {
                      (0, _util.assert)(state === 2);
                      if (ch === SPACE || ch === LF || ch === CR) {
                        maybeEIPos = stream.pos;
                        var followingBytes = stream.peekBytes(n);
                        for (var i = 0, ii = followingBytes.length; i < ii; i++) {
                          ch = followingBytes[i];
                          if (ch === NUL && followingBytes[i + 1] !== NUL) {
                            continue;
                          }
                          if (ch !== LF && ch !== CR && (ch < SPACE || ch > 127)) {
                            state = 0;
                            break;
                          }
                        }
                        if (state === 2) {
                          break;
                        }
                      } else {
                        state = 0;
                      }
                    }
                  }
                  if (ch === -1) {
                    (0, _util.warn)("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker");
                    if (maybeEIPos) {
                      (0, _util.warn)('... trying to recover by using the last "EI" occurrence.');
                      stream.skip(-(stream.pos - maybeEIPos));
                    }
                  }
                  return stream.pos - 4 - startPos;
                },
                findDCTDecodeInlineStreamEnd: function Parser_findDCTDecodeInlineStreamEnd(stream) {
                  var startPos = stream.pos, foundEOI = false, b, markerLength, length;
                  while ((b = stream.getByte()) !== -1) {
                    if (b !== 255) {
                      continue;
                    }
                    switch (stream.getByte()) {
                      case 0:
                        break;
                      case 255:
                        stream.skip(-1);
                        break;
                      case 217:
                        foundEOI = true;
                        break;
                      case 192:
                      case 193:
                      case 194:
                      case 195:
                      case 197:
                      case 198:
                      case 199:
                      case 201:
                      case 202:
                      case 203:
                      case 205:
                      case 206:
                      case 207:
                      case 196:
                      case 204:
                      case 218:
                      case 219:
                      case 220:
                      case 221:
                      case 222:
                      case 223:
                      case 224:
                      case 225:
                      case 226:
                      case 227:
                      case 228:
                      case 229:
                      case 230:
                      case 231:
                      case 232:
                      case 233:
                      case 234:
                      case 235:
                      case 236:
                      case 237:
                      case 238:
                      case 239:
                      case 254:
                        markerLength = stream.getUint16();
                        if (markerLength > 2) {
                          stream.skip(markerLength - 2);
                        } else {
                          stream.skip(-2);
                        }
                        break;
                    }
                    if (foundEOI) {
                      break;
                    }
                  }
                  length = stream.pos - startPos;
                  if (b === -1) {
                    (0, _util.warn)("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead.");
                    stream.skip(-length);
                    return this.findDefaultInlineStreamEnd(stream);
                  }
                  this.inlineStreamSkipEI(stream);
                  return length;
                },
                findASCII85DecodeInlineStreamEnd: function Parser_findASCII85DecodeInlineStreamEnd(stream) {
                  var TILDE = 126, GT = 62;
                  var startPos = stream.pos, ch, length;
                  while ((ch = stream.getByte()) !== -1) {
                    if (ch === TILDE && stream.peekByte() === GT) {
                      stream.skip();
                      break;
                    }
                  }
                  length = stream.pos - startPos;
                  if (ch === -1) {
                    (0, _util.warn)("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead.");
                    stream.skip(-length);
                    return this.findDefaultInlineStreamEnd(stream);
                  }
                  this.inlineStreamSkipEI(stream);
                  return length;
                },
                findASCIIHexDecodeInlineStreamEnd: function Parser_findASCIIHexDecodeInlineStreamEnd(stream) {
                  var GT = 62;
                  var startPos = stream.pos, ch, length;
                  while ((ch = stream.getByte()) !== -1) {
                    if (ch === GT) {
                      break;
                    }
                  }
                  length = stream.pos - startPos;
                  if (ch === -1) {
                    (0, _util.warn)("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead.");
                    stream.skip(-length);
                    return this.findDefaultInlineStreamEnd(stream);
                  }
                  this.inlineStreamSkipEI(stream);
                  return length;
                },
                inlineStreamSkipEI: function Parser_inlineStreamSkipEI(stream) {
                  var E = 69, I = 73;
                  var state = 0, ch;
                  while ((ch = stream.getByte()) !== -1) {
                    if (state === 0) {
                      state = ch === E ? 1 : 0;
                    } else if (state === 1) {
                      state = ch === I ? 2 : 0;
                    } else if (state === 2) {
                      break;
                    }
                  }
                },
                makeInlineImage: function Parser_makeInlineImage(cipherTransform) {
                  var lexer = this.lexer;
                  var stream = lexer.stream;
                  var dict = new _primitives.Dict(this.xref);
                  while (!(0, _primitives.isCmd)(this.buf1, "ID") && !(0, _primitives.isEOF)(this.buf1)) {
                    if (!(0, _primitives.isName)(this.buf1)) {
                      throw new _util.FormatError("Dictionary key must be a name object");
                    }
                    var key = this.buf1.name;
                    this.shift();
                    if ((0, _primitives.isEOF)(this.buf1)) {
                      break;
                    }
                    dict.set(key, this.getObj(cipherTransform));
                  }
                  var filter = dict.get("Filter", "F"), filterName;
                  if ((0, _primitives.isName)(filter)) {
                    filterName = filter.name;
                  } else if (Array.isArray(filter)) {
                    var filterZero = this.xref.fetchIfRef(filter[0]);
                    if ((0, _primitives.isName)(filterZero)) {
                      filterName = filterZero.name;
                    }
                  }
                  var startPos = stream.pos, length, i, ii;
                  if (filterName === "DCTDecode" || filterName === "DCT") {
                    length = this.findDCTDecodeInlineStreamEnd(stream);
                  } else if (filterName === "ASCII85Decode" || filterName === "A85") {
                    length = this.findASCII85DecodeInlineStreamEnd(stream);
                  } else if (filterName === "ASCIIHexDecode" || filterName === "AHx") {
                    length = this.findASCIIHexDecodeInlineStreamEnd(stream);
                  } else {
                    length = this.findDefaultInlineStreamEnd(stream);
                  }
                  var imageStream = stream.makeSubStream(startPos, length, dict);
                  var adler32;
                  if (length < MAX_LENGTH_TO_CACHE) {
                    var imageBytes = imageStream.getBytes();
                    imageStream.reset();
                    var a = 1;
                    var b = 0;
                    for (i = 0, ii = imageBytes.length; i < ii; ++i) {
                      a += imageBytes[i] & 255;
                      b += a;
                    }
                    adler32 = b % 65521 << 16 | a % 65521;
                    var cacheEntry = this.imageCache[adler32];
                    if (cacheEntry !== void 0) {
                      this.buf2 = _primitives.Cmd.get("EI");
                      this.shift();
                      cacheEntry.reset();
                      return cacheEntry;
                    }
                  }
                  if (cipherTransform) {
                    imageStream = cipherTransform.createStream(imageStream, length);
                  }
                  imageStream = this.filter(imageStream, dict, length);
                  imageStream.dict = dict;
                  if (adler32 !== void 0) {
                    imageStream.cacheKey = "inline_" + length + "_" + adler32;
                    this.imageCache[adler32] = imageStream;
                  }
                  this.buf2 = _primitives.Cmd.get("EI");
                  this.shift();
                  return imageStream;
                },
                makeStream: function Parser_makeStream(dict, cipherTransform) {
                  var lexer = this.lexer;
                  var stream = lexer.stream;
                  lexer.skipToNextLine();
                  var pos = stream.pos - 1;
                  var length = dict.get("Length");
                  if (!Number.isInteger(length)) {
                    (0, _util.info)("Bad " + length + " attribute in stream");
                    length = 0;
                  }
                  stream.pos = pos + length;
                  lexer.nextChar();
                  if (this.tryShift() && (0, _primitives.isCmd)(this.buf2, "endstream")) {
                    this.shift();
                  } else {
                    stream.pos = pos;
                    var SCAN_BLOCK_SIZE = 2048;
                    var ENDSTREAM_SIGNATURE_LENGTH = 9;
                    var ENDSTREAM_SIGNATURE = [101, 110, 100, 115, 116, 114, 101, 97, 109];
                    var skipped = 0, found = false, i, j;
                    while (stream.pos < stream.end) {
                      var scanBytes = stream.peekBytes(SCAN_BLOCK_SIZE);
                      var scanLength = scanBytes.length - ENDSTREAM_SIGNATURE_LENGTH;
                      if (scanLength <= 0) {
                        break;
                      }
                      found = false;
                      i = 0;
                      while (i < scanLength) {
                        j = 0;
                        while (j < ENDSTREAM_SIGNATURE_LENGTH && scanBytes[i + j] === ENDSTREAM_SIGNATURE[j]) {
                          j++;
                        }
                        if (j >= ENDSTREAM_SIGNATURE_LENGTH) {
                          found = true;
                          break;
                        }
                        i++;
                      }
                      if (found) {
                        skipped += i;
                        stream.pos += i;
                        break;
                      }
                      skipped += scanLength;
                      stream.pos += scanLength;
                    }
                    if (!found) {
                      throw new _util.FormatError("Missing endstream");
                    }
                    length = skipped;
                    lexer.nextChar();
                    this.shift();
                    this.shift();
                  }
                  this.shift();
                  stream = stream.makeSubStream(pos, length, dict);
                  if (cipherTransform) {
                    stream = cipherTransform.createStream(stream, length);
                  }
                  stream = this.filter(stream, dict, length);
                  stream.dict = dict;
                  return stream;
                },
                filter: function Parser_filter(stream, dict, length) {
                  var filter = dict.get("Filter", "F");
                  var params = dict.get("DecodeParms", "DP");
                  if ((0, _primitives.isName)(filter)) {
                    if (Array.isArray(params)) {
                      (0, _util.warn)("/DecodeParms should not contain an Array, when /Filter contains a Name.");
                    }
                    return this.makeFilter(stream, filter.name, length, params);
                  }
                  var maybeLength = length;
                  if (Array.isArray(filter)) {
                    var filterArray = filter;
                    var paramsArray = params;
                    for (var i = 0, ii = filterArray.length; i < ii; ++i) {
                      filter = this.xref.fetchIfRef(filterArray[i]);
                      if (!(0, _primitives.isName)(filter)) {
                        throw new _util.FormatError("Bad filter name: " + filter);
                      }
                      params = null;
                      if (Array.isArray(paramsArray) && i in paramsArray) {
                        params = this.xref.fetchIfRef(paramsArray[i]);
                      }
                      stream = this.makeFilter(stream, filter.name, maybeLength, params);
                      maybeLength = null;
                    }
                  }
                  return stream;
                },
                makeFilter: function Parser_makeFilter(stream, name, maybeLength, params) {
                  if (maybeLength === 0) {
                    (0, _util.warn)('Empty "' + name + '" stream.');
                    return new _stream.NullStream(stream);
                  }
                  try {
                    var xrefStreamStats = this.xref.stats.streamTypes;
                    if (name === "FlateDecode" || name === "Fl") {
                      xrefStreamStats[_util.StreamType.FLATE] = true;
                      if (params) {
                        return new _stream.PredictorStream(new _stream.FlateStream(stream, maybeLength), maybeLength, params);
                      }
                      return new _stream.FlateStream(stream, maybeLength);
                    }
                    if (name === "LZWDecode" || name === "LZW") {
                      xrefStreamStats[_util.StreamType.LZW] = true;
                      var earlyChange = 1;
                      if (params) {
                        if (params.has("EarlyChange")) {
                          earlyChange = params.get("EarlyChange");
                        }
                        return new _stream.PredictorStream(new _stream.LZWStream(stream, maybeLength, earlyChange), maybeLength, params);
                      }
                      return new _stream.LZWStream(stream, maybeLength, earlyChange);
                    }
                    if (name === "DCTDecode" || name === "DCT") {
                      xrefStreamStats[_util.StreamType.DCT] = true;
                      return new _stream.JpegStream(stream, maybeLength, stream.dict, params);
                    }
                    if (name === "JPXDecode" || name === "JPX") {
                      xrefStreamStats[_util.StreamType.JPX] = true;
                      return new _stream.JpxStream(stream, maybeLength, stream.dict, params);
                    }
                    if (name === "ASCII85Decode" || name === "A85") {
                      xrefStreamStats[_util.StreamType.A85] = true;
                      return new _stream.Ascii85Stream(stream, maybeLength);
                    }
                    if (name === "ASCIIHexDecode" || name === "AHx") {
                      xrefStreamStats[_util.StreamType.AHX] = true;
                      return new _stream.AsciiHexStream(stream, maybeLength);
                    }
                    if (name === "CCITTFaxDecode" || name === "CCF") {
                      xrefStreamStats[_util.StreamType.CCF] = true;
                      return new _ccitt_stream.CCITTFaxStream(stream, maybeLength, params);
                    }
                    if (name === "RunLengthDecode" || name === "RL") {
                      xrefStreamStats[_util.StreamType.RL] = true;
                      return new _stream.RunLengthStream(stream, maybeLength);
                    }
                    if (name === "JBIG2Decode") {
                      xrefStreamStats[_util.StreamType.JBIG] = true;
                      return new _jbig2_stream.Jbig2Stream(stream, maybeLength, stream.dict, params);
                    }
                    (0, _util.warn)('filter "' + name + '" not supported yet');
                    return stream;
                  } catch (ex) {
                    if (ex instanceof _util.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)('Invalid stream: "' + ex + '"');
                    return new _stream.NullStream(stream);
                  }
                }
              };
              return Parser2;
            }();
            var Lexer = function LexerClosure() {
              function Lexer2(stream, knownCommands) {
                this.stream = stream;
                this.nextChar();
                this.strBuf = [];
                this.knownCommands = knownCommands;
              }
              var specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              function toHexDigit(ch) {
                if (ch >= 48 && ch <= 57) {
                  return ch & 15;
                }
                if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
                  return (ch & 15) + 9;
                }
                return -1;
              }
              Lexer2.prototype = {
                nextChar: function Lexer_nextChar() {
                  return this.currentChar = this.stream.getByte();
                },
                peekChar: function Lexer_peekChar() {
                  return this.stream.peekByte();
                },
                getNumber: function Lexer_getNumber() {
                  var ch = this.currentChar;
                  var eNotation = false;
                  var divideBy = 0;
                  var sign = 1;
                  if (ch === 45) {
                    sign = -1;
                    ch = this.nextChar();
                    if (ch === 45) {
                      ch = this.nextChar();
                    }
                  } else if (ch === 43) {
                    ch = this.nextChar();
                  }
                  if (ch === 46) {
                    divideBy = 10;
                    ch = this.nextChar();
                  }
                  if (ch === 10 || ch === 13) {
                    do {
                      ch = this.nextChar();
                    } while (ch === 10 || ch === 13);
                  }
                  if (ch < 48 || ch > 57) {
                    throw new _util.FormatError("Invalid number: " + String.fromCharCode(ch) + " (charCode " + ch + ")");
                  }
                  var baseValue = ch - 48;
                  var powerValue = 0;
                  var powerValueSign = 1;
                  while ((ch = this.nextChar()) >= 0) {
                    if (48 <= ch && ch <= 57) {
                      var currentDigit = ch - 48;
                      if (eNotation) {
                        powerValue = powerValue * 10 + currentDigit;
                      } else {
                        if (divideBy !== 0) {
                          divideBy *= 10;
                        }
                        baseValue = baseValue * 10 + currentDigit;
                      }
                    } else if (ch === 46) {
                      if (divideBy === 0) {
                        divideBy = 1;
                      } else {
                        break;
                      }
                    } else if (ch === 45) {
                      (0, _util.warn)("Badly formatted number");
                    } else if (ch === 69 || ch === 101) {
                      ch = this.peekChar();
                      if (ch === 43 || ch === 45) {
                        powerValueSign = ch === 45 ? -1 : 1;
                        this.nextChar();
                      } else if (ch < 48 || ch > 57) {
                        break;
                      }
                      eNotation = true;
                    } else {
                      break;
                    }
                  }
                  if (divideBy !== 0) {
                    baseValue /= divideBy;
                  }
                  if (eNotation) {
                    baseValue *= Math.pow(10, powerValueSign * powerValue);
                  }
                  return sign * baseValue;
                },
                getString: function Lexer_getString() {
                  var numParen = 1;
                  var done = false;
                  var strBuf = this.strBuf;
                  strBuf.length = 0;
                  var ch = this.nextChar();
                  while (true) {
                    var charBuffered = false;
                    switch (ch | 0) {
                      case -1:
                        (0, _util.warn)("Unterminated string");
                        done = true;
                        break;
                      case 40:
                        ++numParen;
                        strBuf.push("(");
                        break;
                      case 41:
                        if (--numParen === 0) {
                          this.nextChar();
                          done = true;
                        } else {
                          strBuf.push(")");
                        }
                        break;
                      case 92:
                        ch = this.nextChar();
                        switch (ch) {
                          case -1:
                            (0, _util.warn)("Unterminated string");
                            done = true;
                            break;
                          case 110:
                            strBuf.push("\n");
                            break;
                          case 114:
                            strBuf.push("\r");
                            break;
                          case 116:
                            strBuf.push("	");
                            break;
                          case 98:
                            strBuf.push("\b");
                            break;
                          case 102:
                            strBuf.push("\f");
                            break;
                          case 92:
                          case 40:
                          case 41:
                            strBuf.push(String.fromCharCode(ch));
                            break;
                          case 48:
                          case 49:
                          case 50:
                          case 51:
                          case 52:
                          case 53:
                          case 54:
                          case 55:
                            var x = ch & 15;
                            ch = this.nextChar();
                            charBuffered = true;
                            if (ch >= 48 && ch <= 55) {
                              x = (x << 3) + (ch & 15);
                              ch = this.nextChar();
                              if (ch >= 48 && ch <= 55) {
                                charBuffered = false;
                                x = (x << 3) + (ch & 15);
                              }
                            }
                            strBuf.push(String.fromCharCode(x));
                            break;
                          case 13:
                            if (this.peekChar() === 10) {
                              this.nextChar();
                            }
                            break;
                          case 10:
                            break;
                          default:
                            strBuf.push(String.fromCharCode(ch));
                            break;
                        }
                        break;
                      default:
                        strBuf.push(String.fromCharCode(ch));
                        break;
                    }
                    if (done) {
                      break;
                    }
                    if (!charBuffered) {
                      ch = this.nextChar();
                    }
                  }
                  return strBuf.join("");
                },
                getName: function Lexer_getName() {
                  var ch, previousCh;
                  var strBuf = this.strBuf;
                  strBuf.length = 0;
                  while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
                    if (ch === 35) {
                      ch = this.nextChar();
                      if (specialChars[ch]) {
                        (0, _util.warn)("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.");
                        strBuf.push("#");
                        break;
                      }
                      var x = toHexDigit(ch);
                      if (x !== -1) {
                        previousCh = ch;
                        ch = this.nextChar();
                        var x2 = toHexDigit(ch);
                        if (x2 === -1) {
                          (0, _util.warn)("Lexer_getName: Illegal digit (" + String.fromCharCode(ch) + ") in hexadecimal number.");
                          strBuf.push("#", String.fromCharCode(previousCh));
                          if (specialChars[ch]) {
                            break;
                          }
                          strBuf.push(String.fromCharCode(ch));
                          continue;
                        }
                        strBuf.push(String.fromCharCode(x << 4 | x2));
                      } else {
                        strBuf.push("#", String.fromCharCode(ch));
                      }
                    } else {
                      strBuf.push(String.fromCharCode(ch));
                    }
                  }
                  if (strBuf.length > 127) {
                    (0, _util.warn)("name token is longer than allowed by the spec: " + strBuf.length);
                  }
                  return _primitives.Name.get(strBuf.join(""));
                },
                getHexString: function Lexer_getHexString() {
                  var strBuf = this.strBuf;
                  strBuf.length = 0;
                  var ch = this.currentChar;
                  var isFirstHex = true;
                  var firstDigit;
                  var secondDigit;
                  while (true) {
                    if (ch < 0) {
                      (0, _util.warn)("Unterminated hex string");
                      break;
                    } else if (ch === 62) {
                      this.nextChar();
                      break;
                    } else if (specialChars[ch] === 1) {
                      ch = this.nextChar();
                      continue;
                    } else {
                      if (isFirstHex) {
                        firstDigit = toHexDigit(ch);
                        if (firstDigit === -1) {
                          (0, _util.warn)('Ignoring invalid character "' + ch + '" in hex string');
                          ch = this.nextChar();
                          continue;
                        }
                      } else {
                        secondDigit = toHexDigit(ch);
                        if (secondDigit === -1) {
                          (0, _util.warn)('Ignoring invalid character "' + ch + '" in hex string');
                          ch = this.nextChar();
                          continue;
                        }
                        strBuf.push(String.fromCharCode(firstDigit << 4 | secondDigit));
                      }
                      isFirstHex = !isFirstHex;
                      ch = this.nextChar();
                    }
                  }
                  return strBuf.join("");
                },
                getObj: function Lexer_getObj() {
                  var comment = false;
                  var ch = this.currentChar;
                  while (true) {
                    if (ch < 0) {
                      return _primitives.EOF;
                    }
                    if (comment) {
                      if (ch === 10 || ch === 13) {
                        comment = false;
                      }
                    } else if (ch === 37) {
                      comment = true;
                    } else if (specialChars[ch] !== 1) {
                      break;
                    }
                    ch = this.nextChar();
                  }
                  switch (ch | 0) {
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                    case 43:
                    case 45:
                    case 46:
                      return this.getNumber();
                    case 40:
                      return this.getString();
                    case 47:
                      return this.getName();
                    case 91:
                      this.nextChar();
                      return _primitives.Cmd.get("[");
                    case 93:
                      this.nextChar();
                      return _primitives.Cmd.get("]");
                    case 60:
                      ch = this.nextChar();
                      if (ch === 60) {
                        this.nextChar();
                        return _primitives.Cmd.get("<<");
                      }
                      return this.getHexString();
                    case 62:
                      ch = this.nextChar();
                      if (ch === 62) {
                        this.nextChar();
                        return _primitives.Cmd.get(">>");
                      }
                      return _primitives.Cmd.get(">");
                    case 123:
                      this.nextChar();
                      return _primitives.Cmd.get("{");
                    case 125:
                      this.nextChar();
                      return _primitives.Cmd.get("}");
                    case 41:
                      this.nextChar();
                      throw new _util.FormatError("Illegal character: " + ch);
                  }
                  var str = String.fromCharCode(ch);
                  var knownCommands = this.knownCommands;
                  var knownCommandFound = knownCommands && knownCommands[str] !== void 0;
                  while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
                    var possibleCommand = str + String.fromCharCode(ch);
                    if (knownCommandFound && knownCommands[possibleCommand] === void 0) {
                      break;
                    }
                    if (str.length === 128) {
                      throw new _util.FormatError("Command token too long: " + str.length);
                    }
                    str = possibleCommand;
                    knownCommandFound = knownCommands && knownCommands[str] !== void 0;
                  }
                  if (str === "true") {
                    return true;
                  }
                  if (str === "false") {
                    return false;
                  }
                  if (str === "null") {
                    return null;
                  }
                  return _primitives.Cmd.get(str);
                },
                skipToNextLine: function Lexer_skipToNextLine() {
                  var ch = this.currentChar;
                  while (ch >= 0) {
                    if (ch === 13) {
                      ch = this.nextChar();
                      if (ch === 10) {
                        this.nextChar();
                      }
                      break;
                    } else if (ch === 10) {
                      this.nextChar();
                      break;
                    }
                    ch = this.nextChar();
                  }
                }
              };
              return Lexer2;
            }();
            var Linearization = {
              create: function LinearizationCreate(stream) {
                function getInt(name, allowZeroValue) {
                  var obj4 = linDict.get(name);
                  if (Number.isInteger(obj4) && (allowZeroValue ? obj4 >= 0 : obj4 > 0)) {
                    return obj4;
                  }
                  throw new Error('The "' + name + '" parameter in the linearization dictionary is invalid.');
                }
                function getHints() {
                  var hints = linDict.get("H"), hintsLength, item;
                  if (Array.isArray(hints) && ((hintsLength = hints.length) === 2 || hintsLength === 4)) {
                    for (var index = 0; index < hintsLength; index++) {
                      if (!(Number.isInteger(item = hints[index]) && item > 0)) {
                        throw new Error("Hint (" + index + ") in the linearization dictionary is invalid.");
                      }
                    }
                    return hints;
                  }
                  throw new Error("Hint array in the linearization dictionary is invalid.");
                }
                var parser = new Parser(new Lexer(stream), false, null);
                var obj1 = parser.getObj();
                var obj2 = parser.getObj();
                var obj3 = parser.getObj();
                var linDict = parser.getObj();
                var obj, length;
                if (!(Number.isInteger(obj1) && Number.isInteger(obj2) && (0, _primitives.isCmd)(obj3, "obj") && (0, _primitives.isDict)(linDict) && (0, _util.isNum)(obj = linDict.get("Linearized")) && obj > 0)) {
                  return null;
                } else if ((length = getInt("L")) !== stream.length) {
                  throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
                }
                return {
                  length,
                  hints: getHints(),
                  objectNumberFirst: getInt("O"),
                  endFirst: getInt("E"),
                  numPages: getInt("N"),
                  mainXRefEntriesOffset: getInt("T"),
                  pageFirst: linDict.has("P") ? getInt("P", true) : 0
                };
              }
            };
            exports2.Lexer = Lexer;
            exports2.Linearization = Linearization;
            exports2.Parser = Parser;
          },
          /* 35 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(3);
            var document2 = __w_pdfjs_require__(1).document;
            var is = isObject(document2) && isObject(document2.createElement);
            module2.exports = function(it) {
              return is ? document2.createElement(it) : {};
            };
          },
          /* 36 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(3);
            module2.exports = function(it, S) {
              if (!isObject(it)) return it;
              var fn, val;
              if (S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
              if (typeof (fn = it.valueOf) == "function" && !isObject(val = fn.call(it))) return val;
              if (!S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
              throw TypeError("Can't convert object to primitive value");
            };
          },
          /* 37 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var cof = __w_pdfjs_require__(25);
            module2.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
              return cof(it) == "String" ? it.split("") : Object(it);
            };
          },
          /* 38 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = function(it) {
              if (it == void 0) throw TypeError("Can't call method on  " + it);
              return it;
            };
          },
          /* 39 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var shared = __w_pdfjs_require__(54)("keys");
            var uid = __w_pdfjs_require__(17);
            module2.exports = function(key) {
              return shared[key] || (shared[key] = uid(key));
            };
          },
          /* 40 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
          },
          /* 41 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var $keys = __w_pdfjs_require__(52);
            var enumBugKeys = __w_pdfjs_require__(40);
            module2.exports = Object.keys || function keys(O) {
              return $keys(O, enumBugKeys);
            };
          },
          /* 42 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var ctx = __w_pdfjs_require__(13);
            var IObject = __w_pdfjs_require__(37);
            var toObject = __w_pdfjs_require__(19);
            var toLength = __w_pdfjs_require__(14);
            var asc = __w_pdfjs_require__(91);
            module2.exports = function(TYPE, $create) {
              var IS_MAP = TYPE == 1;
              var IS_FILTER = TYPE == 2;
              var IS_SOME = TYPE == 3;
              var IS_EVERY = TYPE == 4;
              var IS_FIND_INDEX = TYPE == 6;
              var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
              var create = $create || asc;
              return function($this, callbackfn, that) {
                var O = toObject($this);
                var self2 = IObject(O);
                var f = ctx(callbackfn, that, 3);
                var length = toLength(self2.length);
                var index = 0;
                var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
                var val, res;
                for (; length > index; index++) {
                  if (NO_HOLES || index in self2) {
                    val = self2[index];
                    res = f(val, index, O);
                    if (TYPE) {
                      if (IS_MAP) result[index] = res;
                      else if (res) switch (TYPE) {
                        case 3:
                          return true;
                        case 5:
                          return val;
                        case 6:
                          return index;
                        case 2:
                          result.push(val);
                      }
                      else if (IS_EVERY) return false;
                    }
                  }
                }
                return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
              };
            };
          },
          /* 43 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var anObject = __w_pdfjs_require__(9);
            var aFunction = __w_pdfjs_require__(22);
            var SPECIES = __w_pdfjs_require__(4)("species");
            module2.exports = function(O, D) {
              var C = anObject(O).constructor;
              var S;
              return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? D : aFunction(S);
            };
          },
          /* 44 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var ITERATOR = __w_pdfjs_require__(4)("iterator");
            var SAFE_CLOSING = false;
            try {
              var riter = [7][ITERATOR]();
              riter["return"] = function() {
                SAFE_CLOSING = true;
              };
              Array.from(riter, function() {
                throw 2;
              });
            } catch (e) {
            }
            module2.exports = function(exec, skipClosing) {
              if (!skipClosing && !SAFE_CLOSING) return false;
              var safe = false;
              try {
                var arr = [7];
                var iter = arr[ITERATOR]();
                iter.next = function() {
                  return { done: safe = true };
                };
                arr[ITERATOR] = function() {
                  return iter;
                };
                exec(arr);
              } catch (e) {
              }
              return safe;
            };
          },
          /* 45 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var aFunction = __w_pdfjs_require__(22);
            function PromiseCapability(C) {
              var resolve, reject;
              this.promise = new C(function($$resolve, $$reject) {
                if (resolve !== void 0 || reject !== void 0) throw TypeError("Bad Promise constructor");
                resolve = $$resolve;
                reject = $$reject;
              });
              this.resolve = aFunction(resolve);
              this.reject = aFunction(reject);
            }
            module2.exports.f = function(C) {
              return new PromiseCapability(C);
            };
          },
          /* 46 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var META = __w_pdfjs_require__(17)("meta");
            var isObject = __w_pdfjs_require__(3);
            var has = __w_pdfjs_require__(12);
            var setDesc = __w_pdfjs_require__(15).f;
            var id = 0;
            var isExtensible = Object.isExtensible || function() {
              return true;
            };
            var FREEZE = !__w_pdfjs_require__(11)(function() {
              return isExtensible(Object.preventExtensions({}));
            });
            var setMeta = function setMeta2(it) {
              setDesc(it, META, {
                value: {
                  i: "O" + ++id,
                  w: {}
                }
              });
            };
            var fastKey = function fastKey2(it, create) {
              if (!isObject(it)) return (typeof it === "undefined" ? "undefined" : _typeof(it)) == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
              if (!has(it, META)) {
                if (!isExtensible(it)) return "F";
                if (!create) return "E";
                setMeta(it);
              }
              return it[META].i;
            };
            var getWeak = function getWeak2(it, create) {
              if (!has(it, META)) {
                if (!isExtensible(it)) return true;
                if (!create) return false;
                setMeta(it);
              }
              return it[META].w;
            };
            var onFreeze = function onFreeze2(it) {
              if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
              return it;
            };
            var meta = module2.exports = {
              KEY: META,
              NEED: false,
              fastKey,
              getWeak,
              onFreeze
            };
          },
          /* 47 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            var getLookupTableFactory = __w_pdfjs_require__(0).getLookupTableFactory;
            var getGlyphsUnicode = getLookupTableFactory(function(t) {
              t["A"] = 65;
              t["AE"] = 198;
              t["AEacute"] = 508;
              t["AEmacron"] = 482;
              t["AEsmall"] = 63462;
              t["Aacute"] = 193;
              t["Aacutesmall"] = 63457;
              t["Abreve"] = 258;
              t["Abreveacute"] = 7854;
              t["Abrevecyrillic"] = 1232;
              t["Abrevedotbelow"] = 7862;
              t["Abrevegrave"] = 7856;
              t["Abrevehookabove"] = 7858;
              t["Abrevetilde"] = 7860;
              t["Acaron"] = 461;
              t["Acircle"] = 9398;
              t["Acircumflex"] = 194;
              t["Acircumflexacute"] = 7844;
              t["Acircumflexdotbelow"] = 7852;
              t["Acircumflexgrave"] = 7846;
              t["Acircumflexhookabove"] = 7848;
              t["Acircumflexsmall"] = 63458;
              t["Acircumflextilde"] = 7850;
              t["Acute"] = 63177;
              t["Acutesmall"] = 63412;
              t["Acyrillic"] = 1040;
              t["Adblgrave"] = 512;
              t["Adieresis"] = 196;
              t["Adieresiscyrillic"] = 1234;
              t["Adieresismacron"] = 478;
              t["Adieresissmall"] = 63460;
              t["Adotbelow"] = 7840;
              t["Adotmacron"] = 480;
              t["Agrave"] = 192;
              t["Agravesmall"] = 63456;
              t["Ahookabove"] = 7842;
              t["Aiecyrillic"] = 1236;
              t["Ainvertedbreve"] = 514;
              t["Alpha"] = 913;
              t["Alphatonos"] = 902;
              t["Amacron"] = 256;
              t["Amonospace"] = 65313;
              t["Aogonek"] = 260;
              t["Aring"] = 197;
              t["Aringacute"] = 506;
              t["Aringbelow"] = 7680;
              t["Aringsmall"] = 63461;
              t["Asmall"] = 63329;
              t["Atilde"] = 195;
              t["Atildesmall"] = 63459;
              t["Aybarmenian"] = 1329;
              t["B"] = 66;
              t["Bcircle"] = 9399;
              t["Bdotaccent"] = 7682;
              t["Bdotbelow"] = 7684;
              t["Becyrillic"] = 1041;
              t["Benarmenian"] = 1330;
              t["Beta"] = 914;
              t["Bhook"] = 385;
              t["Blinebelow"] = 7686;
              t["Bmonospace"] = 65314;
              t["Brevesmall"] = 63220;
              t["Bsmall"] = 63330;
              t["Btopbar"] = 386;
              t["C"] = 67;
              t["Caarmenian"] = 1342;
              t["Cacute"] = 262;
              t["Caron"] = 63178;
              t["Caronsmall"] = 63221;
              t["Ccaron"] = 268;
              t["Ccedilla"] = 199;
              t["Ccedillaacute"] = 7688;
              t["Ccedillasmall"] = 63463;
              t["Ccircle"] = 9400;
              t["Ccircumflex"] = 264;
              t["Cdot"] = 266;
              t["Cdotaccent"] = 266;
              t["Cedillasmall"] = 63416;
              t["Chaarmenian"] = 1353;
              t["Cheabkhasiancyrillic"] = 1212;
              t["Checyrillic"] = 1063;
              t["Chedescenderabkhasiancyrillic"] = 1214;
              t["Chedescendercyrillic"] = 1206;
              t["Chedieresiscyrillic"] = 1268;
              t["Cheharmenian"] = 1347;
              t["Chekhakassiancyrillic"] = 1227;
              t["Cheverticalstrokecyrillic"] = 1208;
              t["Chi"] = 935;
              t["Chook"] = 391;
              t["Circumflexsmall"] = 63222;
              t["Cmonospace"] = 65315;
              t["Coarmenian"] = 1361;
              t["Csmall"] = 63331;
              t["D"] = 68;
              t["DZ"] = 497;
              t["DZcaron"] = 452;
              t["Daarmenian"] = 1332;
              t["Dafrican"] = 393;
              t["Dcaron"] = 270;
              t["Dcedilla"] = 7696;
              t["Dcircle"] = 9401;
              t["Dcircumflexbelow"] = 7698;
              t["Dcroat"] = 272;
              t["Ddotaccent"] = 7690;
              t["Ddotbelow"] = 7692;
              t["Decyrillic"] = 1044;
              t["Deicoptic"] = 1006;
              t["Delta"] = 8710;
              t["Deltagreek"] = 916;
              t["Dhook"] = 394;
              t["Dieresis"] = 63179;
              t["DieresisAcute"] = 63180;
              t["DieresisGrave"] = 63181;
              t["Dieresissmall"] = 63400;
              t["Digammagreek"] = 988;
              t["Djecyrillic"] = 1026;
              t["Dlinebelow"] = 7694;
              t["Dmonospace"] = 65316;
              t["Dotaccentsmall"] = 63223;
              t["Dslash"] = 272;
              t["Dsmall"] = 63332;
              t["Dtopbar"] = 395;
              t["Dz"] = 498;
              t["Dzcaron"] = 453;
              t["Dzeabkhasiancyrillic"] = 1248;
              t["Dzecyrillic"] = 1029;
              t["Dzhecyrillic"] = 1039;
              t["E"] = 69;
              t["Eacute"] = 201;
              t["Eacutesmall"] = 63465;
              t["Ebreve"] = 276;
              t["Ecaron"] = 282;
              t["Ecedillabreve"] = 7708;
              t["Echarmenian"] = 1333;
              t["Ecircle"] = 9402;
              t["Ecircumflex"] = 202;
              t["Ecircumflexacute"] = 7870;
              t["Ecircumflexbelow"] = 7704;
              t["Ecircumflexdotbelow"] = 7878;
              t["Ecircumflexgrave"] = 7872;
              t["Ecircumflexhookabove"] = 7874;
              t["Ecircumflexsmall"] = 63466;
              t["Ecircumflextilde"] = 7876;
              t["Ecyrillic"] = 1028;
              t["Edblgrave"] = 516;
              t["Edieresis"] = 203;
              t["Edieresissmall"] = 63467;
              t["Edot"] = 278;
              t["Edotaccent"] = 278;
              t["Edotbelow"] = 7864;
              t["Efcyrillic"] = 1060;
              t["Egrave"] = 200;
              t["Egravesmall"] = 63464;
              t["Eharmenian"] = 1335;
              t["Ehookabove"] = 7866;
              t["Eightroman"] = 8551;
              t["Einvertedbreve"] = 518;
              t["Eiotifiedcyrillic"] = 1124;
              t["Elcyrillic"] = 1051;
              t["Elevenroman"] = 8554;
              t["Emacron"] = 274;
              t["Emacronacute"] = 7702;
              t["Emacrongrave"] = 7700;
              t["Emcyrillic"] = 1052;
              t["Emonospace"] = 65317;
              t["Encyrillic"] = 1053;
              t["Endescendercyrillic"] = 1186;
              t["Eng"] = 330;
              t["Enghecyrillic"] = 1188;
              t["Enhookcyrillic"] = 1223;
              t["Eogonek"] = 280;
              t["Eopen"] = 400;
              t["Epsilon"] = 917;
              t["Epsilontonos"] = 904;
              t["Ercyrillic"] = 1056;
              t["Ereversed"] = 398;
              t["Ereversedcyrillic"] = 1069;
              t["Escyrillic"] = 1057;
              t["Esdescendercyrillic"] = 1194;
              t["Esh"] = 425;
              t["Esmall"] = 63333;
              t["Eta"] = 919;
              t["Etarmenian"] = 1336;
              t["Etatonos"] = 905;
              t["Eth"] = 208;
              t["Ethsmall"] = 63472;
              t["Etilde"] = 7868;
              t["Etildebelow"] = 7706;
              t["Euro"] = 8364;
              t["Ezh"] = 439;
              t["Ezhcaron"] = 494;
              t["Ezhreversed"] = 440;
              t["F"] = 70;
              t["Fcircle"] = 9403;
              t["Fdotaccent"] = 7710;
              t["Feharmenian"] = 1366;
              t["Feicoptic"] = 996;
              t["Fhook"] = 401;
              t["Fitacyrillic"] = 1138;
              t["Fiveroman"] = 8548;
              t["Fmonospace"] = 65318;
              t["Fourroman"] = 8547;
              t["Fsmall"] = 63334;
              t["G"] = 71;
              t["GBsquare"] = 13191;
              t["Gacute"] = 500;
              t["Gamma"] = 915;
              t["Gammaafrican"] = 404;
              t["Gangiacoptic"] = 1002;
              t["Gbreve"] = 286;
              t["Gcaron"] = 486;
              t["Gcedilla"] = 290;
              t["Gcircle"] = 9404;
              t["Gcircumflex"] = 284;
              t["Gcommaaccent"] = 290;
              t["Gdot"] = 288;
              t["Gdotaccent"] = 288;
              t["Gecyrillic"] = 1043;
              t["Ghadarmenian"] = 1346;
              t["Ghemiddlehookcyrillic"] = 1172;
              t["Ghestrokecyrillic"] = 1170;
              t["Gheupturncyrillic"] = 1168;
              t["Ghook"] = 403;
              t["Gimarmenian"] = 1331;
              t["Gjecyrillic"] = 1027;
              t["Gmacron"] = 7712;
              t["Gmonospace"] = 65319;
              t["Grave"] = 63182;
              t["Gravesmall"] = 63328;
              t["Gsmall"] = 63335;
              t["Gsmallhook"] = 667;
              t["Gstroke"] = 484;
              t["H"] = 72;
              t["H18533"] = 9679;
              t["H18543"] = 9642;
              t["H18551"] = 9643;
              t["H22073"] = 9633;
              t["HPsquare"] = 13259;
              t["Haabkhasiancyrillic"] = 1192;
              t["Hadescendercyrillic"] = 1202;
              t["Hardsigncyrillic"] = 1066;
              t["Hbar"] = 294;
              t["Hbrevebelow"] = 7722;
              t["Hcedilla"] = 7720;
              t["Hcircle"] = 9405;
              t["Hcircumflex"] = 292;
              t["Hdieresis"] = 7718;
              t["Hdotaccent"] = 7714;
              t["Hdotbelow"] = 7716;
              t["Hmonospace"] = 65320;
              t["Hoarmenian"] = 1344;
              t["Horicoptic"] = 1e3;
              t["Hsmall"] = 63336;
              t["Hungarumlaut"] = 63183;
              t["Hungarumlautsmall"] = 63224;
              t["Hzsquare"] = 13200;
              t["I"] = 73;
              t["IAcyrillic"] = 1071;
              t["IJ"] = 306;
              t["IUcyrillic"] = 1070;
              t["Iacute"] = 205;
              t["Iacutesmall"] = 63469;
              t["Ibreve"] = 300;
              t["Icaron"] = 463;
              t["Icircle"] = 9406;
              t["Icircumflex"] = 206;
              t["Icircumflexsmall"] = 63470;
              t["Icyrillic"] = 1030;
              t["Idblgrave"] = 520;
              t["Idieresis"] = 207;
              t["Idieresisacute"] = 7726;
              t["Idieresiscyrillic"] = 1252;
              t["Idieresissmall"] = 63471;
              t["Idot"] = 304;
              t["Idotaccent"] = 304;
              t["Idotbelow"] = 7882;
              t["Iebrevecyrillic"] = 1238;
              t["Iecyrillic"] = 1045;
              t["Ifraktur"] = 8465;
              t["Igrave"] = 204;
              t["Igravesmall"] = 63468;
              t["Ihookabove"] = 7880;
              t["Iicyrillic"] = 1048;
              t["Iinvertedbreve"] = 522;
              t["Iishortcyrillic"] = 1049;
              t["Imacron"] = 298;
              t["Imacroncyrillic"] = 1250;
              t["Imonospace"] = 65321;
              t["Iniarmenian"] = 1339;
              t["Iocyrillic"] = 1025;
              t["Iogonek"] = 302;
              t["Iota"] = 921;
              t["Iotaafrican"] = 406;
              t["Iotadieresis"] = 938;
              t["Iotatonos"] = 906;
              t["Ismall"] = 63337;
              t["Istroke"] = 407;
              t["Itilde"] = 296;
              t["Itildebelow"] = 7724;
              t["Izhitsacyrillic"] = 1140;
              t["Izhitsadblgravecyrillic"] = 1142;
              t["J"] = 74;
              t["Jaarmenian"] = 1345;
              t["Jcircle"] = 9407;
              t["Jcircumflex"] = 308;
              t["Jecyrillic"] = 1032;
              t["Jheharmenian"] = 1355;
              t["Jmonospace"] = 65322;
              t["Jsmall"] = 63338;
              t["K"] = 75;
              t["KBsquare"] = 13189;
              t["KKsquare"] = 13261;
              t["Kabashkircyrillic"] = 1184;
              t["Kacute"] = 7728;
              t["Kacyrillic"] = 1050;
              t["Kadescendercyrillic"] = 1178;
              t["Kahookcyrillic"] = 1219;
              t["Kappa"] = 922;
              t["Kastrokecyrillic"] = 1182;
              t["Kaverticalstrokecyrillic"] = 1180;
              t["Kcaron"] = 488;
              t["Kcedilla"] = 310;
              t["Kcircle"] = 9408;
              t["Kcommaaccent"] = 310;
              t["Kdotbelow"] = 7730;
              t["Keharmenian"] = 1364;
              t["Kenarmenian"] = 1343;
              t["Khacyrillic"] = 1061;
              t["Kheicoptic"] = 998;
              t["Khook"] = 408;
              t["Kjecyrillic"] = 1036;
              t["Klinebelow"] = 7732;
              t["Kmonospace"] = 65323;
              t["Koppacyrillic"] = 1152;
              t["Koppagreek"] = 990;
              t["Ksicyrillic"] = 1134;
              t["Ksmall"] = 63339;
              t["L"] = 76;
              t["LJ"] = 455;
              t["LL"] = 63167;
              t["Lacute"] = 313;
              t["Lambda"] = 923;
              t["Lcaron"] = 317;
              t["Lcedilla"] = 315;
              t["Lcircle"] = 9409;
              t["Lcircumflexbelow"] = 7740;
              t["Lcommaaccent"] = 315;
              t["Ldot"] = 319;
              t["Ldotaccent"] = 319;
              t["Ldotbelow"] = 7734;
              t["Ldotbelowmacron"] = 7736;
              t["Liwnarmenian"] = 1340;
              t["Lj"] = 456;
              t["Ljecyrillic"] = 1033;
              t["Llinebelow"] = 7738;
              t["Lmonospace"] = 65324;
              t["Lslash"] = 321;
              t["Lslashsmall"] = 63225;
              t["Lsmall"] = 63340;
              t["M"] = 77;
              t["MBsquare"] = 13190;
              t["Macron"] = 63184;
              t["Macronsmall"] = 63407;
              t["Macute"] = 7742;
              t["Mcircle"] = 9410;
              t["Mdotaccent"] = 7744;
              t["Mdotbelow"] = 7746;
              t["Menarmenian"] = 1348;
              t["Mmonospace"] = 65325;
              t["Msmall"] = 63341;
              t["Mturned"] = 412;
              t["Mu"] = 924;
              t["N"] = 78;
              t["NJ"] = 458;
              t["Nacute"] = 323;
              t["Ncaron"] = 327;
              t["Ncedilla"] = 325;
              t["Ncircle"] = 9411;
              t["Ncircumflexbelow"] = 7754;
              t["Ncommaaccent"] = 325;
              t["Ndotaccent"] = 7748;
              t["Ndotbelow"] = 7750;
              t["Nhookleft"] = 413;
              t["Nineroman"] = 8552;
              t["Nj"] = 459;
              t["Njecyrillic"] = 1034;
              t["Nlinebelow"] = 7752;
              t["Nmonospace"] = 65326;
              t["Nowarmenian"] = 1350;
              t["Nsmall"] = 63342;
              t["Ntilde"] = 209;
              t["Ntildesmall"] = 63473;
              t["Nu"] = 925;
              t["O"] = 79;
              t["OE"] = 338;
              t["OEsmall"] = 63226;
              t["Oacute"] = 211;
              t["Oacutesmall"] = 63475;
              t["Obarredcyrillic"] = 1256;
              t["Obarreddieresiscyrillic"] = 1258;
              t["Obreve"] = 334;
              t["Ocaron"] = 465;
              t["Ocenteredtilde"] = 415;
              t["Ocircle"] = 9412;
              t["Ocircumflex"] = 212;
              t["Ocircumflexacute"] = 7888;
              t["Ocircumflexdotbelow"] = 7896;
              t["Ocircumflexgrave"] = 7890;
              t["Ocircumflexhookabove"] = 7892;
              t["Ocircumflexsmall"] = 63476;
              t["Ocircumflextilde"] = 7894;
              t["Ocyrillic"] = 1054;
              t["Odblacute"] = 336;
              t["Odblgrave"] = 524;
              t["Odieresis"] = 214;
              t["Odieresiscyrillic"] = 1254;
              t["Odieresissmall"] = 63478;
              t["Odotbelow"] = 7884;
              t["Ogoneksmall"] = 63227;
              t["Ograve"] = 210;
              t["Ogravesmall"] = 63474;
              t["Oharmenian"] = 1365;
              t["Ohm"] = 8486;
              t["Ohookabove"] = 7886;
              t["Ohorn"] = 416;
              t["Ohornacute"] = 7898;
              t["Ohorndotbelow"] = 7906;
              t["Ohorngrave"] = 7900;
              t["Ohornhookabove"] = 7902;
              t["Ohorntilde"] = 7904;
              t["Ohungarumlaut"] = 336;
              t["Oi"] = 418;
              t["Oinvertedbreve"] = 526;
              t["Omacron"] = 332;
              t["Omacronacute"] = 7762;
              t["Omacrongrave"] = 7760;
              t["Omega"] = 8486;
              t["Omegacyrillic"] = 1120;
              t["Omegagreek"] = 937;
              t["Omegaroundcyrillic"] = 1146;
              t["Omegatitlocyrillic"] = 1148;
              t["Omegatonos"] = 911;
              t["Omicron"] = 927;
              t["Omicrontonos"] = 908;
              t["Omonospace"] = 65327;
              t["Oneroman"] = 8544;
              t["Oogonek"] = 490;
              t["Oogonekmacron"] = 492;
              t["Oopen"] = 390;
              t["Oslash"] = 216;
              t["Oslashacute"] = 510;
              t["Oslashsmall"] = 63480;
              t["Osmall"] = 63343;
              t["Ostrokeacute"] = 510;
              t["Otcyrillic"] = 1150;
              t["Otilde"] = 213;
              t["Otildeacute"] = 7756;
              t["Otildedieresis"] = 7758;
              t["Otildesmall"] = 63477;
              t["P"] = 80;
              t["Pacute"] = 7764;
              t["Pcircle"] = 9413;
              t["Pdotaccent"] = 7766;
              t["Pecyrillic"] = 1055;
              t["Peharmenian"] = 1354;
              t["Pemiddlehookcyrillic"] = 1190;
              t["Phi"] = 934;
              t["Phook"] = 420;
              t["Pi"] = 928;
              t["Piwrarmenian"] = 1363;
              t["Pmonospace"] = 65328;
              t["Psi"] = 936;
              t["Psicyrillic"] = 1136;
              t["Psmall"] = 63344;
              t["Q"] = 81;
              t["Qcircle"] = 9414;
              t["Qmonospace"] = 65329;
              t["Qsmall"] = 63345;
              t["R"] = 82;
              t["Raarmenian"] = 1356;
              t["Racute"] = 340;
              t["Rcaron"] = 344;
              t["Rcedilla"] = 342;
              t["Rcircle"] = 9415;
              t["Rcommaaccent"] = 342;
              t["Rdblgrave"] = 528;
              t["Rdotaccent"] = 7768;
              t["Rdotbelow"] = 7770;
              t["Rdotbelowmacron"] = 7772;
              t["Reharmenian"] = 1360;
              t["Rfraktur"] = 8476;
              t["Rho"] = 929;
              t["Ringsmall"] = 63228;
              t["Rinvertedbreve"] = 530;
              t["Rlinebelow"] = 7774;
              t["Rmonospace"] = 65330;
              t["Rsmall"] = 63346;
              t["Rsmallinverted"] = 641;
              t["Rsmallinvertedsuperior"] = 694;
              t["S"] = 83;
              t["SF010000"] = 9484;
              t["SF020000"] = 9492;
              t["SF030000"] = 9488;
              t["SF040000"] = 9496;
              t["SF050000"] = 9532;
              t["SF060000"] = 9516;
              t["SF070000"] = 9524;
              t["SF080000"] = 9500;
              t["SF090000"] = 9508;
              t["SF100000"] = 9472;
              t["SF110000"] = 9474;
              t["SF190000"] = 9569;
              t["SF200000"] = 9570;
              t["SF210000"] = 9558;
              t["SF220000"] = 9557;
              t["SF230000"] = 9571;
              t["SF240000"] = 9553;
              t["SF250000"] = 9559;
              t["SF260000"] = 9565;
              t["SF270000"] = 9564;
              t["SF280000"] = 9563;
              t["SF360000"] = 9566;
              t["SF370000"] = 9567;
              t["SF380000"] = 9562;
              t["SF390000"] = 9556;
              t["SF400000"] = 9577;
              t["SF410000"] = 9574;
              t["SF420000"] = 9568;
              t["SF430000"] = 9552;
              t["SF440000"] = 9580;
              t["SF450000"] = 9575;
              t["SF460000"] = 9576;
              t["SF470000"] = 9572;
              t["SF480000"] = 9573;
              t["SF490000"] = 9561;
              t["SF500000"] = 9560;
              t["SF510000"] = 9554;
              t["SF520000"] = 9555;
              t["SF530000"] = 9579;
              t["SF540000"] = 9578;
              t["Sacute"] = 346;
              t["Sacutedotaccent"] = 7780;
              t["Sampigreek"] = 992;
              t["Scaron"] = 352;
              t["Scarondotaccent"] = 7782;
              t["Scaronsmall"] = 63229;
              t["Scedilla"] = 350;
              t["Schwa"] = 399;
              t["Schwacyrillic"] = 1240;
              t["Schwadieresiscyrillic"] = 1242;
              t["Scircle"] = 9416;
              t["Scircumflex"] = 348;
              t["Scommaaccent"] = 536;
              t["Sdotaccent"] = 7776;
              t["Sdotbelow"] = 7778;
              t["Sdotbelowdotaccent"] = 7784;
              t["Seharmenian"] = 1357;
              t["Sevenroman"] = 8550;
              t["Shaarmenian"] = 1351;
              t["Shacyrillic"] = 1064;
              t["Shchacyrillic"] = 1065;
              t["Sheicoptic"] = 994;
              t["Shhacyrillic"] = 1210;
              t["Shimacoptic"] = 1004;
              t["Sigma"] = 931;
              t["Sixroman"] = 8549;
              t["Smonospace"] = 65331;
              t["Softsigncyrillic"] = 1068;
              t["Ssmall"] = 63347;
              t["Stigmagreek"] = 986;
              t["T"] = 84;
              t["Tau"] = 932;
              t["Tbar"] = 358;
              t["Tcaron"] = 356;
              t["Tcedilla"] = 354;
              t["Tcircle"] = 9417;
              t["Tcircumflexbelow"] = 7792;
              t["Tcommaaccent"] = 354;
              t["Tdotaccent"] = 7786;
              t["Tdotbelow"] = 7788;
              t["Tecyrillic"] = 1058;
              t["Tedescendercyrillic"] = 1196;
              t["Tenroman"] = 8553;
              t["Tetsecyrillic"] = 1204;
              t["Theta"] = 920;
              t["Thook"] = 428;
              t["Thorn"] = 222;
              t["Thornsmall"] = 63486;
              t["Threeroman"] = 8546;
              t["Tildesmall"] = 63230;
              t["Tiwnarmenian"] = 1359;
              t["Tlinebelow"] = 7790;
              t["Tmonospace"] = 65332;
              t["Toarmenian"] = 1337;
              t["Tonefive"] = 444;
              t["Tonesix"] = 388;
              t["Tonetwo"] = 423;
              t["Tretroflexhook"] = 430;
              t["Tsecyrillic"] = 1062;
              t["Tshecyrillic"] = 1035;
              t["Tsmall"] = 63348;
              t["Twelveroman"] = 8555;
              t["Tworoman"] = 8545;
              t["U"] = 85;
              t["Uacute"] = 218;
              t["Uacutesmall"] = 63482;
              t["Ubreve"] = 364;
              t["Ucaron"] = 467;
              t["Ucircle"] = 9418;
              t["Ucircumflex"] = 219;
              t["Ucircumflexbelow"] = 7798;
              t["Ucircumflexsmall"] = 63483;
              t["Ucyrillic"] = 1059;
              t["Udblacute"] = 368;
              t["Udblgrave"] = 532;
              t["Udieresis"] = 220;
              t["Udieresisacute"] = 471;
              t["Udieresisbelow"] = 7794;
              t["Udieresiscaron"] = 473;
              t["Udieresiscyrillic"] = 1264;
              t["Udieresisgrave"] = 475;
              t["Udieresismacron"] = 469;
              t["Udieresissmall"] = 63484;
              t["Udotbelow"] = 7908;
              t["Ugrave"] = 217;
              t["Ugravesmall"] = 63481;
              t["Uhookabove"] = 7910;
              t["Uhorn"] = 431;
              t["Uhornacute"] = 7912;
              t["Uhorndotbelow"] = 7920;
              t["Uhorngrave"] = 7914;
              t["Uhornhookabove"] = 7916;
              t["Uhorntilde"] = 7918;
              t["Uhungarumlaut"] = 368;
              t["Uhungarumlautcyrillic"] = 1266;
              t["Uinvertedbreve"] = 534;
              t["Ukcyrillic"] = 1144;
              t["Umacron"] = 362;
              t["Umacroncyrillic"] = 1262;
              t["Umacrondieresis"] = 7802;
              t["Umonospace"] = 65333;
              t["Uogonek"] = 370;
              t["Upsilon"] = 933;
              t["Upsilon1"] = 978;
              t["Upsilonacutehooksymbolgreek"] = 979;
              t["Upsilonafrican"] = 433;
              t["Upsilondieresis"] = 939;
              t["Upsilondieresishooksymbolgreek"] = 980;
              t["Upsilonhooksymbol"] = 978;
              t["Upsilontonos"] = 910;
              t["Uring"] = 366;
              t["Ushortcyrillic"] = 1038;
              t["Usmall"] = 63349;
              t["Ustraightcyrillic"] = 1198;
              t["Ustraightstrokecyrillic"] = 1200;
              t["Utilde"] = 360;
              t["Utildeacute"] = 7800;
              t["Utildebelow"] = 7796;
              t["V"] = 86;
              t["Vcircle"] = 9419;
              t["Vdotbelow"] = 7806;
              t["Vecyrillic"] = 1042;
              t["Vewarmenian"] = 1358;
              t["Vhook"] = 434;
              t["Vmonospace"] = 65334;
              t["Voarmenian"] = 1352;
              t["Vsmall"] = 63350;
              t["Vtilde"] = 7804;
              t["W"] = 87;
              t["Wacute"] = 7810;
              t["Wcircle"] = 9420;
              t["Wcircumflex"] = 372;
              t["Wdieresis"] = 7812;
              t["Wdotaccent"] = 7814;
              t["Wdotbelow"] = 7816;
              t["Wgrave"] = 7808;
              t["Wmonospace"] = 65335;
              t["Wsmall"] = 63351;
              t["X"] = 88;
              t["Xcircle"] = 9421;
              t["Xdieresis"] = 7820;
              t["Xdotaccent"] = 7818;
              t["Xeharmenian"] = 1341;
              t["Xi"] = 926;
              t["Xmonospace"] = 65336;
              t["Xsmall"] = 63352;
              t["Y"] = 89;
              t["Yacute"] = 221;
              t["Yacutesmall"] = 63485;
              t["Yatcyrillic"] = 1122;
              t["Ycircle"] = 9422;
              t["Ycircumflex"] = 374;
              t["Ydieresis"] = 376;
              t["Ydieresissmall"] = 63487;
              t["Ydotaccent"] = 7822;
              t["Ydotbelow"] = 7924;
              t["Yericyrillic"] = 1067;
              t["Yerudieresiscyrillic"] = 1272;
              t["Ygrave"] = 7922;
              t["Yhook"] = 435;
              t["Yhookabove"] = 7926;
              t["Yiarmenian"] = 1349;
              t["Yicyrillic"] = 1031;
              t["Yiwnarmenian"] = 1362;
              t["Ymonospace"] = 65337;
              t["Ysmall"] = 63353;
              t["Ytilde"] = 7928;
              t["Yusbigcyrillic"] = 1130;
              t["Yusbigiotifiedcyrillic"] = 1132;
              t["Yuslittlecyrillic"] = 1126;
              t["Yuslittleiotifiedcyrillic"] = 1128;
              t["Z"] = 90;
              t["Zaarmenian"] = 1334;
              t["Zacute"] = 377;
              t["Zcaron"] = 381;
              t["Zcaronsmall"] = 63231;
              t["Zcircle"] = 9423;
              t["Zcircumflex"] = 7824;
              t["Zdot"] = 379;
              t["Zdotaccent"] = 379;
              t["Zdotbelow"] = 7826;
              t["Zecyrillic"] = 1047;
              t["Zedescendercyrillic"] = 1176;
              t["Zedieresiscyrillic"] = 1246;
              t["Zeta"] = 918;
              t["Zhearmenian"] = 1338;
              t["Zhebrevecyrillic"] = 1217;
              t["Zhecyrillic"] = 1046;
              t["Zhedescendercyrillic"] = 1174;
              t["Zhedieresiscyrillic"] = 1244;
              t["Zlinebelow"] = 7828;
              t["Zmonospace"] = 65338;
              t["Zsmall"] = 63354;
              t["Zstroke"] = 437;
              t["a"] = 97;
              t["aabengali"] = 2438;
              t["aacute"] = 225;
              t["aadeva"] = 2310;
              t["aagujarati"] = 2694;
              t["aagurmukhi"] = 2566;
              t["aamatragurmukhi"] = 2622;
              t["aarusquare"] = 13059;
              t["aavowelsignbengali"] = 2494;
              t["aavowelsigndeva"] = 2366;
              t["aavowelsigngujarati"] = 2750;
              t["abbreviationmarkarmenian"] = 1375;
              t["abbreviationsigndeva"] = 2416;
              t["abengali"] = 2437;
              t["abopomofo"] = 12570;
              t["abreve"] = 259;
              t["abreveacute"] = 7855;
              t["abrevecyrillic"] = 1233;
              t["abrevedotbelow"] = 7863;
              t["abrevegrave"] = 7857;
              t["abrevehookabove"] = 7859;
              t["abrevetilde"] = 7861;
              t["acaron"] = 462;
              t["acircle"] = 9424;
              t["acircumflex"] = 226;
              t["acircumflexacute"] = 7845;
              t["acircumflexdotbelow"] = 7853;
              t["acircumflexgrave"] = 7847;
              t["acircumflexhookabove"] = 7849;
              t["acircumflextilde"] = 7851;
              t["acute"] = 180;
              t["acutebelowcmb"] = 791;
              t["acutecmb"] = 769;
              t["acutecomb"] = 769;
              t["acutedeva"] = 2388;
              t["acutelowmod"] = 719;
              t["acutetonecmb"] = 833;
              t["acyrillic"] = 1072;
              t["adblgrave"] = 513;
              t["addakgurmukhi"] = 2673;
              t["adeva"] = 2309;
              t["adieresis"] = 228;
              t["adieresiscyrillic"] = 1235;
              t["adieresismacron"] = 479;
              t["adotbelow"] = 7841;
              t["adotmacron"] = 481;
              t["ae"] = 230;
              t["aeacute"] = 509;
              t["aekorean"] = 12624;
              t["aemacron"] = 483;
              t["afii00208"] = 8213;
              t["afii08941"] = 8356;
              t["afii10017"] = 1040;
              t["afii10018"] = 1041;
              t["afii10019"] = 1042;
              t["afii10020"] = 1043;
              t["afii10021"] = 1044;
              t["afii10022"] = 1045;
              t["afii10023"] = 1025;
              t["afii10024"] = 1046;
              t["afii10025"] = 1047;
              t["afii10026"] = 1048;
              t["afii10027"] = 1049;
              t["afii10028"] = 1050;
              t["afii10029"] = 1051;
              t["afii10030"] = 1052;
              t["afii10031"] = 1053;
              t["afii10032"] = 1054;
              t["afii10033"] = 1055;
              t["afii10034"] = 1056;
              t["afii10035"] = 1057;
              t["afii10036"] = 1058;
              t["afii10037"] = 1059;
              t["afii10038"] = 1060;
              t["afii10039"] = 1061;
              t["afii10040"] = 1062;
              t["afii10041"] = 1063;
              t["afii10042"] = 1064;
              t["afii10043"] = 1065;
              t["afii10044"] = 1066;
              t["afii10045"] = 1067;
              t["afii10046"] = 1068;
              t["afii10047"] = 1069;
              t["afii10048"] = 1070;
              t["afii10049"] = 1071;
              t["afii10050"] = 1168;
              t["afii10051"] = 1026;
              t["afii10052"] = 1027;
              t["afii10053"] = 1028;
              t["afii10054"] = 1029;
              t["afii10055"] = 1030;
              t["afii10056"] = 1031;
              t["afii10057"] = 1032;
              t["afii10058"] = 1033;
              t["afii10059"] = 1034;
              t["afii10060"] = 1035;
              t["afii10061"] = 1036;
              t["afii10062"] = 1038;
              t["afii10063"] = 63172;
              t["afii10064"] = 63173;
              t["afii10065"] = 1072;
              t["afii10066"] = 1073;
              t["afii10067"] = 1074;
              t["afii10068"] = 1075;
              t["afii10069"] = 1076;
              t["afii10070"] = 1077;
              t["afii10071"] = 1105;
              t["afii10072"] = 1078;
              t["afii10073"] = 1079;
              t["afii10074"] = 1080;
              t["afii10075"] = 1081;
              t["afii10076"] = 1082;
              t["afii10077"] = 1083;
              t["afii10078"] = 1084;
              t["afii10079"] = 1085;
              t["afii10080"] = 1086;
              t["afii10081"] = 1087;
              t["afii10082"] = 1088;
              t["afii10083"] = 1089;
              t["afii10084"] = 1090;
              t["afii10085"] = 1091;
              t["afii10086"] = 1092;
              t["afii10087"] = 1093;
              t["afii10088"] = 1094;
              t["afii10089"] = 1095;
              t["afii10090"] = 1096;
              t["afii10091"] = 1097;
              t["afii10092"] = 1098;
              t["afii10093"] = 1099;
              t["afii10094"] = 1100;
              t["afii10095"] = 1101;
              t["afii10096"] = 1102;
              t["afii10097"] = 1103;
              t["afii10098"] = 1169;
              t["afii10099"] = 1106;
              t["afii10100"] = 1107;
              t["afii10101"] = 1108;
              t["afii10102"] = 1109;
              t["afii10103"] = 1110;
              t["afii10104"] = 1111;
              t["afii10105"] = 1112;
              t["afii10106"] = 1113;
              t["afii10107"] = 1114;
              t["afii10108"] = 1115;
              t["afii10109"] = 1116;
              t["afii10110"] = 1118;
              t["afii10145"] = 1039;
              t["afii10146"] = 1122;
              t["afii10147"] = 1138;
              t["afii10148"] = 1140;
              t["afii10192"] = 63174;
              t["afii10193"] = 1119;
              t["afii10194"] = 1123;
              t["afii10195"] = 1139;
              t["afii10196"] = 1141;
              t["afii10831"] = 63175;
              t["afii10832"] = 63176;
              t["afii10846"] = 1241;
              t["afii299"] = 8206;
              t["afii300"] = 8207;
              t["afii301"] = 8205;
              t["afii57381"] = 1642;
              t["afii57388"] = 1548;
              t["afii57392"] = 1632;
              t["afii57393"] = 1633;
              t["afii57394"] = 1634;
              t["afii57395"] = 1635;
              t["afii57396"] = 1636;
              t["afii57397"] = 1637;
              t["afii57398"] = 1638;
              t["afii57399"] = 1639;
              t["afii57400"] = 1640;
              t["afii57401"] = 1641;
              t["afii57403"] = 1563;
              t["afii57407"] = 1567;
              t["afii57409"] = 1569;
              t["afii57410"] = 1570;
              t["afii57411"] = 1571;
              t["afii57412"] = 1572;
              t["afii57413"] = 1573;
              t["afii57414"] = 1574;
              t["afii57415"] = 1575;
              t["afii57416"] = 1576;
              t["afii57417"] = 1577;
              t["afii57418"] = 1578;
              t["afii57419"] = 1579;
              t["afii57420"] = 1580;
              t["afii57421"] = 1581;
              t["afii57422"] = 1582;
              t["afii57423"] = 1583;
              t["afii57424"] = 1584;
              t["afii57425"] = 1585;
              t["afii57426"] = 1586;
              t["afii57427"] = 1587;
              t["afii57428"] = 1588;
              t["afii57429"] = 1589;
              t["afii57430"] = 1590;
              t["afii57431"] = 1591;
              t["afii57432"] = 1592;
              t["afii57433"] = 1593;
              t["afii57434"] = 1594;
              t["afii57440"] = 1600;
              t["afii57441"] = 1601;
              t["afii57442"] = 1602;
              t["afii57443"] = 1603;
              t["afii57444"] = 1604;
              t["afii57445"] = 1605;
              t["afii57446"] = 1606;
              t["afii57448"] = 1608;
              t["afii57449"] = 1609;
              t["afii57450"] = 1610;
              t["afii57451"] = 1611;
              t["afii57452"] = 1612;
              t["afii57453"] = 1613;
              t["afii57454"] = 1614;
              t["afii57455"] = 1615;
              t["afii57456"] = 1616;
              t["afii57457"] = 1617;
              t["afii57458"] = 1618;
              t["afii57470"] = 1607;
              t["afii57505"] = 1700;
              t["afii57506"] = 1662;
              t["afii57507"] = 1670;
              t["afii57508"] = 1688;
              t["afii57509"] = 1711;
              t["afii57511"] = 1657;
              t["afii57512"] = 1672;
              t["afii57513"] = 1681;
              t["afii57514"] = 1722;
              t["afii57519"] = 1746;
              t["afii57534"] = 1749;
              t["afii57636"] = 8362;
              t["afii57645"] = 1470;
              t["afii57658"] = 1475;
              t["afii57664"] = 1488;
              t["afii57665"] = 1489;
              t["afii57666"] = 1490;
              t["afii57667"] = 1491;
              t["afii57668"] = 1492;
              t["afii57669"] = 1493;
              t["afii57670"] = 1494;
              t["afii57671"] = 1495;
              t["afii57672"] = 1496;
              t["afii57673"] = 1497;
              t["afii57674"] = 1498;
              t["afii57675"] = 1499;
              t["afii57676"] = 1500;
              t["afii57677"] = 1501;
              t["afii57678"] = 1502;
              t["afii57679"] = 1503;
              t["afii57680"] = 1504;
              t["afii57681"] = 1505;
              t["afii57682"] = 1506;
              t["afii57683"] = 1507;
              t["afii57684"] = 1508;
              t["afii57685"] = 1509;
              t["afii57686"] = 1510;
              t["afii57687"] = 1511;
              t["afii57688"] = 1512;
              t["afii57689"] = 1513;
              t["afii57690"] = 1514;
              t["afii57694"] = 64298;
              t["afii57695"] = 64299;
              t["afii57700"] = 64331;
              t["afii57705"] = 64287;
              t["afii57716"] = 1520;
              t["afii57717"] = 1521;
              t["afii57718"] = 1522;
              t["afii57723"] = 64309;
              t["afii57793"] = 1460;
              t["afii57794"] = 1461;
              t["afii57795"] = 1462;
              t["afii57796"] = 1467;
              t["afii57797"] = 1464;
              t["afii57798"] = 1463;
              t["afii57799"] = 1456;
              t["afii57800"] = 1458;
              t["afii57801"] = 1457;
              t["afii57802"] = 1459;
              t["afii57803"] = 1474;
              t["afii57804"] = 1473;
              t["afii57806"] = 1465;
              t["afii57807"] = 1468;
              t["afii57839"] = 1469;
              t["afii57841"] = 1471;
              t["afii57842"] = 1472;
              t["afii57929"] = 700;
              t["afii61248"] = 8453;
              t["afii61289"] = 8467;
              t["afii61352"] = 8470;
              t["afii61573"] = 8236;
              t["afii61574"] = 8237;
              t["afii61575"] = 8238;
              t["afii61664"] = 8204;
              t["afii63167"] = 1645;
              t["afii64937"] = 701;
              t["agrave"] = 224;
              t["agujarati"] = 2693;
              t["agurmukhi"] = 2565;
              t["ahiragana"] = 12354;
              t["ahookabove"] = 7843;
              t["aibengali"] = 2448;
              t["aibopomofo"] = 12574;
              t["aideva"] = 2320;
              t["aiecyrillic"] = 1237;
              t["aigujarati"] = 2704;
              t["aigurmukhi"] = 2576;
              t["aimatragurmukhi"] = 2632;
              t["ainarabic"] = 1593;
              t["ainfinalarabic"] = 65226;
              t["aininitialarabic"] = 65227;
              t["ainmedialarabic"] = 65228;
              t["ainvertedbreve"] = 515;
              t["aivowelsignbengali"] = 2504;
              t["aivowelsigndeva"] = 2376;
              t["aivowelsigngujarati"] = 2760;
              t["akatakana"] = 12450;
              t["akatakanahalfwidth"] = 65393;
              t["akorean"] = 12623;
              t["alef"] = 1488;
              t["alefarabic"] = 1575;
              t["alefdageshhebrew"] = 64304;
              t["aleffinalarabic"] = 65166;
              t["alefhamzaabovearabic"] = 1571;
              t["alefhamzaabovefinalarabic"] = 65156;
              t["alefhamzabelowarabic"] = 1573;
              t["alefhamzabelowfinalarabic"] = 65160;
              t["alefhebrew"] = 1488;
              t["aleflamedhebrew"] = 64335;
              t["alefmaddaabovearabic"] = 1570;
              t["alefmaddaabovefinalarabic"] = 65154;
              t["alefmaksuraarabic"] = 1609;
              t["alefmaksurafinalarabic"] = 65264;
              t["alefmaksurainitialarabic"] = 65267;
              t["alefmaksuramedialarabic"] = 65268;
              t["alefpatahhebrew"] = 64302;
              t["alefqamatshebrew"] = 64303;
              t["aleph"] = 8501;
              t["allequal"] = 8780;
              t["alpha"] = 945;
              t["alphatonos"] = 940;
              t["amacron"] = 257;
              t["amonospace"] = 65345;
              t["ampersand"] = 38;
              t["ampersandmonospace"] = 65286;
              t["ampersandsmall"] = 63270;
              t["amsquare"] = 13250;
              t["anbopomofo"] = 12578;
              t["angbopomofo"] = 12580;
              t["angbracketleft"] = 12296;
              t["angbracketright"] = 12297;
              t["angkhankhuthai"] = 3674;
              t["angle"] = 8736;
              t["anglebracketleft"] = 12296;
              t["anglebracketleftvertical"] = 65087;
              t["anglebracketright"] = 12297;
              t["anglebracketrightvertical"] = 65088;
              t["angleleft"] = 9001;
              t["angleright"] = 9002;
              t["angstrom"] = 8491;
              t["anoteleia"] = 903;
              t["anudattadeva"] = 2386;
              t["anusvarabengali"] = 2434;
              t["anusvaradeva"] = 2306;
              t["anusvaragujarati"] = 2690;
              t["aogonek"] = 261;
              t["apaatosquare"] = 13056;
              t["aparen"] = 9372;
              t["apostrophearmenian"] = 1370;
              t["apostrophemod"] = 700;
              t["apple"] = 63743;
              t["approaches"] = 8784;
              t["approxequal"] = 8776;
              t["approxequalorimage"] = 8786;
              t["approximatelyequal"] = 8773;
              t["araeaekorean"] = 12686;
              t["araeakorean"] = 12685;
              t["arc"] = 8978;
              t["arighthalfring"] = 7834;
              t["aring"] = 229;
              t["aringacute"] = 507;
              t["aringbelow"] = 7681;
              t["arrowboth"] = 8596;
              t["arrowdashdown"] = 8675;
              t["arrowdashleft"] = 8672;
              t["arrowdashright"] = 8674;
              t["arrowdashup"] = 8673;
              t["arrowdblboth"] = 8660;
              t["arrowdbldown"] = 8659;
              t["arrowdblleft"] = 8656;
              t["arrowdblright"] = 8658;
              t["arrowdblup"] = 8657;
              t["arrowdown"] = 8595;
              t["arrowdownleft"] = 8601;
              t["arrowdownright"] = 8600;
              t["arrowdownwhite"] = 8681;
              t["arrowheaddownmod"] = 709;
              t["arrowheadleftmod"] = 706;
              t["arrowheadrightmod"] = 707;
              t["arrowheadupmod"] = 708;
              t["arrowhorizex"] = 63719;
              t["arrowleft"] = 8592;
              t["arrowleftdbl"] = 8656;
              t["arrowleftdblstroke"] = 8653;
              t["arrowleftoverright"] = 8646;
              t["arrowleftwhite"] = 8678;
              t["arrowright"] = 8594;
              t["arrowrightdblstroke"] = 8655;
              t["arrowrightheavy"] = 10142;
              t["arrowrightoverleft"] = 8644;
              t["arrowrightwhite"] = 8680;
              t["arrowtableft"] = 8676;
              t["arrowtabright"] = 8677;
              t["arrowup"] = 8593;
              t["arrowupdn"] = 8597;
              t["arrowupdnbse"] = 8616;
              t["arrowupdownbase"] = 8616;
              t["arrowupleft"] = 8598;
              t["arrowupleftofdown"] = 8645;
              t["arrowupright"] = 8599;
              t["arrowupwhite"] = 8679;
              t["arrowvertex"] = 63718;
              t["asciicircum"] = 94;
              t["asciicircummonospace"] = 65342;
              t["asciitilde"] = 126;
              t["asciitildemonospace"] = 65374;
              t["ascript"] = 593;
              t["ascriptturned"] = 594;
              t["asmallhiragana"] = 12353;
              t["asmallkatakana"] = 12449;
              t["asmallkatakanahalfwidth"] = 65383;
              t["asterisk"] = 42;
              t["asteriskaltonearabic"] = 1645;
              t["asteriskarabic"] = 1645;
              t["asteriskmath"] = 8727;
              t["asteriskmonospace"] = 65290;
              t["asterisksmall"] = 65121;
              t["asterism"] = 8258;
              t["asuperior"] = 63209;
              t["asymptoticallyequal"] = 8771;
              t["at"] = 64;
              t["atilde"] = 227;
              t["atmonospace"] = 65312;
              t["atsmall"] = 65131;
              t["aturned"] = 592;
              t["aubengali"] = 2452;
              t["aubopomofo"] = 12576;
              t["audeva"] = 2324;
              t["augujarati"] = 2708;
              t["augurmukhi"] = 2580;
              t["aulengthmarkbengali"] = 2519;
              t["aumatragurmukhi"] = 2636;
              t["auvowelsignbengali"] = 2508;
              t["auvowelsigndeva"] = 2380;
              t["auvowelsigngujarati"] = 2764;
              t["avagrahadeva"] = 2365;
              t["aybarmenian"] = 1377;
              t["ayin"] = 1506;
              t["ayinaltonehebrew"] = 64288;
              t["ayinhebrew"] = 1506;
              t["b"] = 98;
              t["babengali"] = 2476;
              t["backslash"] = 92;
              t["backslashmonospace"] = 65340;
              t["badeva"] = 2348;
              t["bagujarati"] = 2732;
              t["bagurmukhi"] = 2604;
              t["bahiragana"] = 12400;
              t["bahtthai"] = 3647;
              t["bakatakana"] = 12496;
              t["bar"] = 124;
              t["barmonospace"] = 65372;
              t["bbopomofo"] = 12549;
              t["bcircle"] = 9425;
              t["bdotaccent"] = 7683;
              t["bdotbelow"] = 7685;
              t["beamedsixteenthnotes"] = 9836;
              t["because"] = 8757;
              t["becyrillic"] = 1073;
              t["beharabic"] = 1576;
              t["behfinalarabic"] = 65168;
              t["behinitialarabic"] = 65169;
              t["behiragana"] = 12409;
              t["behmedialarabic"] = 65170;
              t["behmeeminitialarabic"] = 64671;
              t["behmeemisolatedarabic"] = 64520;
              t["behnoonfinalarabic"] = 64621;
              t["bekatakana"] = 12505;
              t["benarmenian"] = 1378;
              t["bet"] = 1489;
              t["beta"] = 946;
              t["betasymbolgreek"] = 976;
              t["betdagesh"] = 64305;
              t["betdageshhebrew"] = 64305;
              t["bethebrew"] = 1489;
              t["betrafehebrew"] = 64332;
              t["bhabengali"] = 2477;
              t["bhadeva"] = 2349;
              t["bhagujarati"] = 2733;
              t["bhagurmukhi"] = 2605;
              t["bhook"] = 595;
              t["bihiragana"] = 12403;
              t["bikatakana"] = 12499;
              t["bilabialclick"] = 664;
              t["bindigurmukhi"] = 2562;
              t["birusquare"] = 13105;
              t["blackcircle"] = 9679;
              t["blackdiamond"] = 9670;
              t["blackdownpointingtriangle"] = 9660;
              t["blackleftpointingpointer"] = 9668;
              t["blackleftpointingtriangle"] = 9664;
              t["blacklenticularbracketleft"] = 12304;
              t["blacklenticularbracketleftvertical"] = 65083;
              t["blacklenticularbracketright"] = 12305;
              t["blacklenticularbracketrightvertical"] = 65084;
              t["blacklowerlefttriangle"] = 9699;
              t["blacklowerrighttriangle"] = 9698;
              t["blackrectangle"] = 9644;
              t["blackrightpointingpointer"] = 9658;
              t["blackrightpointingtriangle"] = 9654;
              t["blacksmallsquare"] = 9642;
              t["blacksmilingface"] = 9787;
              t["blacksquare"] = 9632;
              t["blackstar"] = 9733;
              t["blackupperlefttriangle"] = 9700;
              t["blackupperrighttriangle"] = 9701;
              t["blackuppointingsmalltriangle"] = 9652;
              t["blackuppointingtriangle"] = 9650;
              t["blank"] = 9251;
              t["blinebelow"] = 7687;
              t["block"] = 9608;
              t["bmonospace"] = 65346;
              t["bobaimaithai"] = 3610;
              t["bohiragana"] = 12412;
              t["bokatakana"] = 12508;
              t["bparen"] = 9373;
              t["bqsquare"] = 13251;
              t["braceex"] = 63732;
              t["braceleft"] = 123;
              t["braceleftbt"] = 63731;
              t["braceleftmid"] = 63730;
              t["braceleftmonospace"] = 65371;
              t["braceleftsmall"] = 65115;
              t["bracelefttp"] = 63729;
              t["braceleftvertical"] = 65079;
              t["braceright"] = 125;
              t["bracerightbt"] = 63742;
              t["bracerightmid"] = 63741;
              t["bracerightmonospace"] = 65373;
              t["bracerightsmall"] = 65116;
              t["bracerighttp"] = 63740;
              t["bracerightvertical"] = 65080;
              t["bracketleft"] = 91;
              t["bracketleftbt"] = 63728;
              t["bracketleftex"] = 63727;
              t["bracketleftmonospace"] = 65339;
              t["bracketlefttp"] = 63726;
              t["bracketright"] = 93;
              t["bracketrightbt"] = 63739;
              t["bracketrightex"] = 63738;
              t["bracketrightmonospace"] = 65341;
              t["bracketrighttp"] = 63737;
              t["breve"] = 728;
              t["brevebelowcmb"] = 814;
              t["brevecmb"] = 774;
              t["breveinvertedbelowcmb"] = 815;
              t["breveinvertedcmb"] = 785;
              t["breveinverteddoublecmb"] = 865;
              t["bridgebelowcmb"] = 810;
              t["bridgeinvertedbelowcmb"] = 826;
              t["brokenbar"] = 166;
              t["bstroke"] = 384;
              t["bsuperior"] = 63210;
              t["btopbar"] = 387;
              t["buhiragana"] = 12406;
              t["bukatakana"] = 12502;
              t["bullet"] = 8226;
              t["bulletinverse"] = 9688;
              t["bulletoperator"] = 8729;
              t["bullseye"] = 9678;
              t["c"] = 99;
              t["caarmenian"] = 1390;
              t["cabengali"] = 2458;
              t["cacute"] = 263;
              t["cadeva"] = 2330;
              t["cagujarati"] = 2714;
              t["cagurmukhi"] = 2586;
              t["calsquare"] = 13192;
              t["candrabindubengali"] = 2433;
              t["candrabinducmb"] = 784;
              t["candrabindudeva"] = 2305;
              t["candrabindugujarati"] = 2689;
              t["capslock"] = 8682;
              t["careof"] = 8453;
              t["caron"] = 711;
              t["caronbelowcmb"] = 812;
              t["caroncmb"] = 780;
              t["carriagereturn"] = 8629;
              t["cbopomofo"] = 12568;
              t["ccaron"] = 269;
              t["ccedilla"] = 231;
              t["ccedillaacute"] = 7689;
              t["ccircle"] = 9426;
              t["ccircumflex"] = 265;
              t["ccurl"] = 597;
              t["cdot"] = 267;
              t["cdotaccent"] = 267;
              t["cdsquare"] = 13253;
              t["cedilla"] = 184;
              t["cedillacmb"] = 807;
              t["cent"] = 162;
              t["centigrade"] = 8451;
              t["centinferior"] = 63199;
              t["centmonospace"] = 65504;
              t["centoldstyle"] = 63394;
              t["centsuperior"] = 63200;
              t["chaarmenian"] = 1401;
              t["chabengali"] = 2459;
              t["chadeva"] = 2331;
              t["chagujarati"] = 2715;
              t["chagurmukhi"] = 2587;
              t["chbopomofo"] = 12564;
              t["cheabkhasiancyrillic"] = 1213;
              t["checkmark"] = 10003;
              t["checyrillic"] = 1095;
              t["chedescenderabkhasiancyrillic"] = 1215;
              t["chedescendercyrillic"] = 1207;
              t["chedieresiscyrillic"] = 1269;
              t["cheharmenian"] = 1395;
              t["chekhakassiancyrillic"] = 1228;
              t["cheverticalstrokecyrillic"] = 1209;
              t["chi"] = 967;
              t["chieuchacirclekorean"] = 12919;
              t["chieuchaparenkorean"] = 12823;
              t["chieuchcirclekorean"] = 12905;
              t["chieuchkorean"] = 12618;
              t["chieuchparenkorean"] = 12809;
              t["chochangthai"] = 3594;
              t["chochanthai"] = 3592;
              t["chochingthai"] = 3593;
              t["chochoethai"] = 3596;
              t["chook"] = 392;
              t["cieucacirclekorean"] = 12918;
              t["cieucaparenkorean"] = 12822;
              t["cieuccirclekorean"] = 12904;
              t["cieuckorean"] = 12616;
              t["cieucparenkorean"] = 12808;
              t["cieucuparenkorean"] = 12828;
              t["circle"] = 9675;
              t["circlecopyrt"] = 169;
              t["circlemultiply"] = 8855;
              t["circleot"] = 8857;
              t["circleplus"] = 8853;
              t["circlepostalmark"] = 12342;
              t["circlewithlefthalfblack"] = 9680;
              t["circlewithrighthalfblack"] = 9681;
              t["circumflex"] = 710;
              t["circumflexbelowcmb"] = 813;
              t["circumflexcmb"] = 770;
              t["clear"] = 8999;
              t["clickalveolar"] = 450;
              t["clickdental"] = 448;
              t["clicklateral"] = 449;
              t["clickretroflex"] = 451;
              t["club"] = 9827;
              t["clubsuitblack"] = 9827;
              t["clubsuitwhite"] = 9831;
              t["cmcubedsquare"] = 13220;
              t["cmonospace"] = 65347;
              t["cmsquaredsquare"] = 13216;
              t["coarmenian"] = 1409;
              t["colon"] = 58;
              t["colonmonetary"] = 8353;
              t["colonmonospace"] = 65306;
              t["colonsign"] = 8353;
              t["colonsmall"] = 65109;
              t["colontriangularhalfmod"] = 721;
              t["colontriangularmod"] = 720;
              t["comma"] = 44;
              t["commaabovecmb"] = 787;
              t["commaaboverightcmb"] = 789;
              t["commaaccent"] = 63171;
              t["commaarabic"] = 1548;
              t["commaarmenian"] = 1373;
              t["commainferior"] = 63201;
              t["commamonospace"] = 65292;
              t["commareversedabovecmb"] = 788;
              t["commareversedmod"] = 701;
              t["commasmall"] = 65104;
              t["commasuperior"] = 63202;
              t["commaturnedabovecmb"] = 786;
              t["commaturnedmod"] = 699;
              t["compass"] = 9788;
              t["congruent"] = 8773;
              t["contourintegral"] = 8750;
              t["control"] = 8963;
              t["controlACK"] = 6;
              t["controlBEL"] = 7;
              t["controlBS"] = 8;
              t["controlCAN"] = 24;
              t["controlCR"] = 13;
              t["controlDC1"] = 17;
              t["controlDC2"] = 18;
              t["controlDC3"] = 19;
              t["controlDC4"] = 20;
              t["controlDEL"] = 127;
              t["controlDLE"] = 16;
              t["controlEM"] = 25;
              t["controlENQ"] = 5;
              t["controlEOT"] = 4;
              t["controlESC"] = 27;
              t["controlETB"] = 23;
              t["controlETX"] = 3;
              t["controlFF"] = 12;
              t["controlFS"] = 28;
              t["controlGS"] = 29;
              t["controlHT"] = 9;
              t["controlLF"] = 10;
              t["controlNAK"] = 21;
              t["controlNULL"] = 0;
              t["controlRS"] = 30;
              t["controlSI"] = 15;
              t["controlSO"] = 14;
              t["controlSOT"] = 2;
              t["controlSTX"] = 1;
              t["controlSUB"] = 26;
              t["controlSYN"] = 22;
              t["controlUS"] = 31;
              t["controlVT"] = 11;
              t["copyright"] = 169;
              t["copyrightsans"] = 63721;
              t["copyrightserif"] = 63193;
              t["cornerbracketleft"] = 12300;
              t["cornerbracketlefthalfwidth"] = 65378;
              t["cornerbracketleftvertical"] = 65089;
              t["cornerbracketright"] = 12301;
              t["cornerbracketrighthalfwidth"] = 65379;
              t["cornerbracketrightvertical"] = 65090;
              t["corporationsquare"] = 13183;
              t["cosquare"] = 13255;
              t["coverkgsquare"] = 13254;
              t["cparen"] = 9374;
              t["cruzeiro"] = 8354;
              t["cstretched"] = 663;
              t["curlyand"] = 8911;
              t["curlyor"] = 8910;
              t["currency"] = 164;
              t["cyrBreve"] = 63185;
              t["cyrFlex"] = 63186;
              t["cyrbreve"] = 63188;
              t["cyrflex"] = 63189;
              t["d"] = 100;
              t["daarmenian"] = 1380;
              t["dabengali"] = 2470;
              t["dadarabic"] = 1590;
              t["dadeva"] = 2342;
              t["dadfinalarabic"] = 65214;
              t["dadinitialarabic"] = 65215;
              t["dadmedialarabic"] = 65216;
              t["dagesh"] = 1468;
              t["dageshhebrew"] = 1468;
              t["dagger"] = 8224;
              t["daggerdbl"] = 8225;
              t["dagujarati"] = 2726;
              t["dagurmukhi"] = 2598;
              t["dahiragana"] = 12384;
              t["dakatakana"] = 12480;
              t["dalarabic"] = 1583;
              t["dalet"] = 1491;
              t["daletdagesh"] = 64307;
              t["daletdageshhebrew"] = 64307;
              t["dalethebrew"] = 1491;
              t["dalfinalarabic"] = 65194;
              t["dammaarabic"] = 1615;
              t["dammalowarabic"] = 1615;
              t["dammatanaltonearabic"] = 1612;
              t["dammatanarabic"] = 1612;
              t["danda"] = 2404;
              t["dargahebrew"] = 1447;
              t["dargalefthebrew"] = 1447;
              t["dasiapneumatacyrilliccmb"] = 1157;
              t["dblGrave"] = 63187;
              t["dblanglebracketleft"] = 12298;
              t["dblanglebracketleftvertical"] = 65085;
              t["dblanglebracketright"] = 12299;
              t["dblanglebracketrightvertical"] = 65086;
              t["dblarchinvertedbelowcmb"] = 811;
              t["dblarrowleft"] = 8660;
              t["dblarrowright"] = 8658;
              t["dbldanda"] = 2405;
              t["dblgrave"] = 63190;
              t["dblgravecmb"] = 783;
              t["dblintegral"] = 8748;
              t["dbllowline"] = 8215;
              t["dbllowlinecmb"] = 819;
              t["dbloverlinecmb"] = 831;
              t["dblprimemod"] = 698;
              t["dblverticalbar"] = 8214;
              t["dblverticallineabovecmb"] = 782;
              t["dbopomofo"] = 12553;
              t["dbsquare"] = 13256;
              t["dcaron"] = 271;
              t["dcedilla"] = 7697;
              t["dcircle"] = 9427;
              t["dcircumflexbelow"] = 7699;
              t["dcroat"] = 273;
              t["ddabengali"] = 2465;
              t["ddadeva"] = 2337;
              t["ddagujarati"] = 2721;
              t["ddagurmukhi"] = 2593;
              t["ddalarabic"] = 1672;
              t["ddalfinalarabic"] = 64393;
              t["dddhadeva"] = 2396;
              t["ddhabengali"] = 2466;
              t["ddhadeva"] = 2338;
              t["ddhagujarati"] = 2722;
              t["ddhagurmukhi"] = 2594;
              t["ddotaccent"] = 7691;
              t["ddotbelow"] = 7693;
              t["decimalseparatorarabic"] = 1643;
              t["decimalseparatorpersian"] = 1643;
              t["decyrillic"] = 1076;
              t["degree"] = 176;
              t["dehihebrew"] = 1453;
              t["dehiragana"] = 12391;
              t["deicoptic"] = 1007;
              t["dekatakana"] = 12487;
              t["deleteleft"] = 9003;
              t["deleteright"] = 8998;
              t["delta"] = 948;
              t["deltaturned"] = 397;
              t["denominatorminusonenumeratorbengali"] = 2552;
              t["dezh"] = 676;
              t["dhabengali"] = 2471;
              t["dhadeva"] = 2343;
              t["dhagujarati"] = 2727;
              t["dhagurmukhi"] = 2599;
              t["dhook"] = 599;
              t["dialytikatonos"] = 901;
              t["dialytikatonoscmb"] = 836;
              t["diamond"] = 9830;
              t["diamondsuitwhite"] = 9826;
              t["dieresis"] = 168;
              t["dieresisacute"] = 63191;
              t["dieresisbelowcmb"] = 804;
              t["dieresiscmb"] = 776;
              t["dieresisgrave"] = 63192;
              t["dieresistonos"] = 901;
              t["dihiragana"] = 12386;
              t["dikatakana"] = 12482;
              t["dittomark"] = 12291;
              t["divide"] = 247;
              t["divides"] = 8739;
              t["divisionslash"] = 8725;
              t["djecyrillic"] = 1106;
              t["dkshade"] = 9619;
              t["dlinebelow"] = 7695;
              t["dlsquare"] = 13207;
              t["dmacron"] = 273;
              t["dmonospace"] = 65348;
              t["dnblock"] = 9604;
              t["dochadathai"] = 3598;
              t["dodekthai"] = 3604;
              t["dohiragana"] = 12393;
              t["dokatakana"] = 12489;
              t["dollar"] = 36;
              t["dollarinferior"] = 63203;
              t["dollarmonospace"] = 65284;
              t["dollaroldstyle"] = 63268;
              t["dollarsmall"] = 65129;
              t["dollarsuperior"] = 63204;
              t["dong"] = 8363;
              t["dorusquare"] = 13094;
              t["dotaccent"] = 729;
              t["dotaccentcmb"] = 775;
              t["dotbelowcmb"] = 803;
              t["dotbelowcomb"] = 803;
              t["dotkatakana"] = 12539;
              t["dotlessi"] = 305;
              t["dotlessj"] = 63166;
              t["dotlessjstrokehook"] = 644;
              t["dotmath"] = 8901;
              t["dottedcircle"] = 9676;
              t["doubleyodpatah"] = 64287;
              t["doubleyodpatahhebrew"] = 64287;
              t["downtackbelowcmb"] = 798;
              t["downtackmod"] = 725;
              t["dparen"] = 9375;
              t["dsuperior"] = 63211;
              t["dtail"] = 598;
              t["dtopbar"] = 396;
              t["duhiragana"] = 12389;
              t["dukatakana"] = 12485;
              t["dz"] = 499;
              t["dzaltone"] = 675;
              t["dzcaron"] = 454;
              t["dzcurl"] = 677;
              t["dzeabkhasiancyrillic"] = 1249;
              t["dzecyrillic"] = 1109;
              t["dzhecyrillic"] = 1119;
              t["e"] = 101;
              t["eacute"] = 233;
              t["earth"] = 9793;
              t["ebengali"] = 2447;
              t["ebopomofo"] = 12572;
              t["ebreve"] = 277;
              t["ecandradeva"] = 2317;
              t["ecandragujarati"] = 2701;
              t["ecandravowelsigndeva"] = 2373;
              t["ecandravowelsigngujarati"] = 2757;
              t["ecaron"] = 283;
              t["ecedillabreve"] = 7709;
              t["echarmenian"] = 1381;
              t["echyiwnarmenian"] = 1415;
              t["ecircle"] = 9428;
              t["ecircumflex"] = 234;
              t["ecircumflexacute"] = 7871;
              t["ecircumflexbelow"] = 7705;
              t["ecircumflexdotbelow"] = 7879;
              t["ecircumflexgrave"] = 7873;
              t["ecircumflexhookabove"] = 7875;
              t["ecircumflextilde"] = 7877;
              t["ecyrillic"] = 1108;
              t["edblgrave"] = 517;
              t["edeva"] = 2319;
              t["edieresis"] = 235;
              t["edot"] = 279;
              t["edotaccent"] = 279;
              t["edotbelow"] = 7865;
              t["eegurmukhi"] = 2575;
              t["eematragurmukhi"] = 2631;
              t["efcyrillic"] = 1092;
              t["egrave"] = 232;
              t["egujarati"] = 2703;
              t["eharmenian"] = 1383;
              t["ehbopomofo"] = 12573;
              t["ehiragana"] = 12360;
              t["ehookabove"] = 7867;
              t["eibopomofo"] = 12575;
              t["eight"] = 56;
              t["eightarabic"] = 1640;
              t["eightbengali"] = 2542;
              t["eightcircle"] = 9319;
              t["eightcircleinversesansserif"] = 10129;
              t["eightdeva"] = 2414;
              t["eighteencircle"] = 9329;
              t["eighteenparen"] = 9349;
              t["eighteenperiod"] = 9369;
              t["eightgujarati"] = 2798;
              t["eightgurmukhi"] = 2670;
              t["eighthackarabic"] = 1640;
              t["eighthangzhou"] = 12328;
              t["eighthnotebeamed"] = 9835;
              t["eightideographicparen"] = 12839;
              t["eightinferior"] = 8328;
              t["eightmonospace"] = 65304;
              t["eightoldstyle"] = 63288;
              t["eightparen"] = 9339;
              t["eightperiod"] = 9359;
              t["eightpersian"] = 1784;
              t["eightroman"] = 8567;
              t["eightsuperior"] = 8312;
              t["eightthai"] = 3672;
              t["einvertedbreve"] = 519;
              t["eiotifiedcyrillic"] = 1125;
              t["ekatakana"] = 12456;
              t["ekatakanahalfwidth"] = 65396;
              t["ekonkargurmukhi"] = 2676;
              t["ekorean"] = 12628;
              t["elcyrillic"] = 1083;
              t["element"] = 8712;
              t["elevencircle"] = 9322;
              t["elevenparen"] = 9342;
              t["elevenperiod"] = 9362;
              t["elevenroman"] = 8570;
              t["ellipsis"] = 8230;
              t["ellipsisvertical"] = 8942;
              t["emacron"] = 275;
              t["emacronacute"] = 7703;
              t["emacrongrave"] = 7701;
              t["emcyrillic"] = 1084;
              t["emdash"] = 8212;
              t["emdashvertical"] = 65073;
              t["emonospace"] = 65349;
              t["emphasismarkarmenian"] = 1371;
              t["emptyset"] = 8709;
              t["enbopomofo"] = 12579;
              t["encyrillic"] = 1085;
              t["endash"] = 8211;
              t["endashvertical"] = 65074;
              t["endescendercyrillic"] = 1187;
              t["eng"] = 331;
              t["engbopomofo"] = 12581;
              t["enghecyrillic"] = 1189;
              t["enhookcyrillic"] = 1224;
              t["enspace"] = 8194;
              t["eogonek"] = 281;
              t["eokorean"] = 12627;
              t["eopen"] = 603;
              t["eopenclosed"] = 666;
              t["eopenreversed"] = 604;
              t["eopenreversedclosed"] = 606;
              t["eopenreversedhook"] = 605;
              t["eparen"] = 9376;
              t["epsilon"] = 949;
              t["epsilontonos"] = 941;
              t["equal"] = 61;
              t["equalmonospace"] = 65309;
              t["equalsmall"] = 65126;
              t["equalsuperior"] = 8316;
              t["equivalence"] = 8801;
              t["erbopomofo"] = 12582;
              t["ercyrillic"] = 1088;
              t["ereversed"] = 600;
              t["ereversedcyrillic"] = 1101;
              t["escyrillic"] = 1089;
              t["esdescendercyrillic"] = 1195;
              t["esh"] = 643;
              t["eshcurl"] = 646;
              t["eshortdeva"] = 2318;
              t["eshortvowelsigndeva"] = 2374;
              t["eshreversedloop"] = 426;
              t["eshsquatreversed"] = 645;
              t["esmallhiragana"] = 12359;
              t["esmallkatakana"] = 12455;
              t["esmallkatakanahalfwidth"] = 65386;
              t["estimated"] = 8494;
              t["esuperior"] = 63212;
              t["eta"] = 951;
              t["etarmenian"] = 1384;
              t["etatonos"] = 942;
              t["eth"] = 240;
              t["etilde"] = 7869;
              t["etildebelow"] = 7707;
              t["etnahtafoukhhebrew"] = 1425;
              t["etnahtafoukhlefthebrew"] = 1425;
              t["etnahtahebrew"] = 1425;
              t["etnahtalefthebrew"] = 1425;
              t["eturned"] = 477;
              t["eukorean"] = 12641;
              t["euro"] = 8364;
              t["evowelsignbengali"] = 2503;
              t["evowelsigndeva"] = 2375;
              t["evowelsigngujarati"] = 2759;
              t["exclam"] = 33;
              t["exclamarmenian"] = 1372;
              t["exclamdbl"] = 8252;
              t["exclamdown"] = 161;
              t["exclamdownsmall"] = 63393;
              t["exclammonospace"] = 65281;
              t["exclamsmall"] = 63265;
              t["existential"] = 8707;
              t["ezh"] = 658;
              t["ezhcaron"] = 495;
              t["ezhcurl"] = 659;
              t["ezhreversed"] = 441;
              t["ezhtail"] = 442;
              t["f"] = 102;
              t["fadeva"] = 2398;
              t["fagurmukhi"] = 2654;
              t["fahrenheit"] = 8457;
              t["fathaarabic"] = 1614;
              t["fathalowarabic"] = 1614;
              t["fathatanarabic"] = 1611;
              t["fbopomofo"] = 12552;
              t["fcircle"] = 9429;
              t["fdotaccent"] = 7711;
              t["feharabic"] = 1601;
              t["feharmenian"] = 1414;
              t["fehfinalarabic"] = 65234;
              t["fehinitialarabic"] = 65235;
              t["fehmedialarabic"] = 65236;
              t["feicoptic"] = 997;
              t["female"] = 9792;
              t["ff"] = 64256;
              t["ffi"] = 64259;
              t["ffl"] = 64260;
              t["fi"] = 64257;
              t["fifteencircle"] = 9326;
              t["fifteenparen"] = 9346;
              t["fifteenperiod"] = 9366;
              t["figuredash"] = 8210;
              t["filledbox"] = 9632;
              t["filledrect"] = 9644;
              t["finalkaf"] = 1498;
              t["finalkafdagesh"] = 64314;
              t["finalkafdageshhebrew"] = 64314;
              t["finalkafhebrew"] = 1498;
              t["finalmem"] = 1501;
              t["finalmemhebrew"] = 1501;
              t["finalnun"] = 1503;
              t["finalnunhebrew"] = 1503;
              t["finalpe"] = 1507;
              t["finalpehebrew"] = 1507;
              t["finaltsadi"] = 1509;
              t["finaltsadihebrew"] = 1509;
              t["firsttonechinese"] = 713;
              t["fisheye"] = 9673;
              t["fitacyrillic"] = 1139;
              t["five"] = 53;
              t["fivearabic"] = 1637;
              t["fivebengali"] = 2539;
              t["fivecircle"] = 9316;
              t["fivecircleinversesansserif"] = 10126;
              t["fivedeva"] = 2411;
              t["fiveeighths"] = 8541;
              t["fivegujarati"] = 2795;
              t["fivegurmukhi"] = 2667;
              t["fivehackarabic"] = 1637;
              t["fivehangzhou"] = 12325;
              t["fiveideographicparen"] = 12836;
              t["fiveinferior"] = 8325;
              t["fivemonospace"] = 65301;
              t["fiveoldstyle"] = 63285;
              t["fiveparen"] = 9336;
              t["fiveperiod"] = 9356;
              t["fivepersian"] = 1781;
              t["fiveroman"] = 8564;
              t["fivesuperior"] = 8309;
              t["fivethai"] = 3669;
              t["fl"] = 64258;
              t["florin"] = 402;
              t["fmonospace"] = 65350;
              t["fmsquare"] = 13209;
              t["fofanthai"] = 3615;
              t["fofathai"] = 3613;
              t["fongmanthai"] = 3663;
              t["forall"] = 8704;
              t["four"] = 52;
              t["fourarabic"] = 1636;
              t["fourbengali"] = 2538;
              t["fourcircle"] = 9315;
              t["fourcircleinversesansserif"] = 10125;
              t["fourdeva"] = 2410;
              t["fourgujarati"] = 2794;
              t["fourgurmukhi"] = 2666;
              t["fourhackarabic"] = 1636;
              t["fourhangzhou"] = 12324;
              t["fourideographicparen"] = 12835;
              t["fourinferior"] = 8324;
              t["fourmonospace"] = 65300;
              t["fournumeratorbengali"] = 2551;
              t["fouroldstyle"] = 63284;
              t["fourparen"] = 9335;
              t["fourperiod"] = 9355;
              t["fourpersian"] = 1780;
              t["fourroman"] = 8563;
              t["foursuperior"] = 8308;
              t["fourteencircle"] = 9325;
              t["fourteenparen"] = 9345;
              t["fourteenperiod"] = 9365;
              t["fourthai"] = 3668;
              t["fourthtonechinese"] = 715;
              t["fparen"] = 9377;
              t["fraction"] = 8260;
              t["franc"] = 8355;
              t["g"] = 103;
              t["gabengali"] = 2455;
              t["gacute"] = 501;
              t["gadeva"] = 2327;
              t["gafarabic"] = 1711;
              t["gaffinalarabic"] = 64403;
              t["gafinitialarabic"] = 64404;
              t["gafmedialarabic"] = 64405;
              t["gagujarati"] = 2711;
              t["gagurmukhi"] = 2583;
              t["gahiragana"] = 12364;
              t["gakatakana"] = 12460;
              t["gamma"] = 947;
              t["gammalatinsmall"] = 611;
              t["gammasuperior"] = 736;
              t["gangiacoptic"] = 1003;
              t["gbopomofo"] = 12557;
              t["gbreve"] = 287;
              t["gcaron"] = 487;
              t["gcedilla"] = 291;
              t["gcircle"] = 9430;
              t["gcircumflex"] = 285;
              t["gcommaaccent"] = 291;
              t["gdot"] = 289;
              t["gdotaccent"] = 289;
              t["gecyrillic"] = 1075;
              t["gehiragana"] = 12370;
              t["gekatakana"] = 12466;
              t["geometricallyequal"] = 8785;
              t["gereshaccenthebrew"] = 1436;
              t["gereshhebrew"] = 1523;
              t["gereshmuqdamhebrew"] = 1437;
              t["germandbls"] = 223;
              t["gershayimaccenthebrew"] = 1438;
              t["gershayimhebrew"] = 1524;
              t["getamark"] = 12307;
              t["ghabengali"] = 2456;
              t["ghadarmenian"] = 1394;
              t["ghadeva"] = 2328;
              t["ghagujarati"] = 2712;
              t["ghagurmukhi"] = 2584;
              t["ghainarabic"] = 1594;
              t["ghainfinalarabic"] = 65230;
              t["ghaininitialarabic"] = 65231;
              t["ghainmedialarabic"] = 65232;
              t["ghemiddlehookcyrillic"] = 1173;
              t["ghestrokecyrillic"] = 1171;
              t["gheupturncyrillic"] = 1169;
              t["ghhadeva"] = 2394;
              t["ghhagurmukhi"] = 2650;
              t["ghook"] = 608;
              t["ghzsquare"] = 13203;
              t["gihiragana"] = 12366;
              t["gikatakana"] = 12462;
              t["gimarmenian"] = 1379;
              t["gimel"] = 1490;
              t["gimeldagesh"] = 64306;
              t["gimeldageshhebrew"] = 64306;
              t["gimelhebrew"] = 1490;
              t["gjecyrillic"] = 1107;
              t["glottalinvertedstroke"] = 446;
              t["glottalstop"] = 660;
              t["glottalstopinverted"] = 662;
              t["glottalstopmod"] = 704;
              t["glottalstopreversed"] = 661;
              t["glottalstopreversedmod"] = 705;
              t["glottalstopreversedsuperior"] = 740;
              t["glottalstopstroke"] = 673;
              t["glottalstopstrokereversed"] = 674;
              t["gmacron"] = 7713;
              t["gmonospace"] = 65351;
              t["gohiragana"] = 12372;
              t["gokatakana"] = 12468;
              t["gparen"] = 9378;
              t["gpasquare"] = 13228;
              t["gradient"] = 8711;
              t["grave"] = 96;
              t["gravebelowcmb"] = 790;
              t["gravecmb"] = 768;
              t["gravecomb"] = 768;
              t["gravedeva"] = 2387;
              t["gravelowmod"] = 718;
              t["gravemonospace"] = 65344;
              t["gravetonecmb"] = 832;
              t["greater"] = 62;
              t["greaterequal"] = 8805;
              t["greaterequalorless"] = 8923;
              t["greatermonospace"] = 65310;
              t["greaterorequivalent"] = 8819;
              t["greaterorless"] = 8823;
              t["greateroverequal"] = 8807;
              t["greatersmall"] = 65125;
              t["gscript"] = 609;
              t["gstroke"] = 485;
              t["guhiragana"] = 12368;
              t["guillemotleft"] = 171;
              t["guillemotright"] = 187;
              t["guilsinglleft"] = 8249;
              t["guilsinglright"] = 8250;
              t["gukatakana"] = 12464;
              t["guramusquare"] = 13080;
              t["gysquare"] = 13257;
              t["h"] = 104;
              t["haabkhasiancyrillic"] = 1193;
              t["haaltonearabic"] = 1729;
              t["habengali"] = 2489;
              t["hadescendercyrillic"] = 1203;
              t["hadeva"] = 2361;
              t["hagujarati"] = 2745;
              t["hagurmukhi"] = 2617;
              t["haharabic"] = 1581;
              t["hahfinalarabic"] = 65186;
              t["hahinitialarabic"] = 65187;
              t["hahiragana"] = 12399;
              t["hahmedialarabic"] = 65188;
              t["haitusquare"] = 13098;
              t["hakatakana"] = 12495;
              t["hakatakanahalfwidth"] = 65418;
              t["halantgurmukhi"] = 2637;
              t["hamzaarabic"] = 1569;
              t["hamzalowarabic"] = 1569;
              t["hangulfiller"] = 12644;
              t["hardsigncyrillic"] = 1098;
              t["harpoonleftbarbup"] = 8636;
              t["harpoonrightbarbup"] = 8640;
              t["hasquare"] = 13258;
              t["hatafpatah"] = 1458;
              t["hatafpatah16"] = 1458;
              t["hatafpatah23"] = 1458;
              t["hatafpatah2f"] = 1458;
              t["hatafpatahhebrew"] = 1458;
              t["hatafpatahnarrowhebrew"] = 1458;
              t["hatafpatahquarterhebrew"] = 1458;
              t["hatafpatahwidehebrew"] = 1458;
              t["hatafqamats"] = 1459;
              t["hatafqamats1b"] = 1459;
              t["hatafqamats28"] = 1459;
              t["hatafqamats34"] = 1459;
              t["hatafqamatshebrew"] = 1459;
              t["hatafqamatsnarrowhebrew"] = 1459;
              t["hatafqamatsquarterhebrew"] = 1459;
              t["hatafqamatswidehebrew"] = 1459;
              t["hatafsegol"] = 1457;
              t["hatafsegol17"] = 1457;
              t["hatafsegol24"] = 1457;
              t["hatafsegol30"] = 1457;
              t["hatafsegolhebrew"] = 1457;
              t["hatafsegolnarrowhebrew"] = 1457;
              t["hatafsegolquarterhebrew"] = 1457;
              t["hatafsegolwidehebrew"] = 1457;
              t["hbar"] = 295;
              t["hbopomofo"] = 12559;
              t["hbrevebelow"] = 7723;
              t["hcedilla"] = 7721;
              t["hcircle"] = 9431;
              t["hcircumflex"] = 293;
              t["hdieresis"] = 7719;
              t["hdotaccent"] = 7715;
              t["hdotbelow"] = 7717;
              t["he"] = 1492;
              t["heart"] = 9829;
              t["heartsuitblack"] = 9829;
              t["heartsuitwhite"] = 9825;
              t["hedagesh"] = 64308;
              t["hedageshhebrew"] = 64308;
              t["hehaltonearabic"] = 1729;
              t["heharabic"] = 1607;
              t["hehebrew"] = 1492;
              t["hehfinalaltonearabic"] = 64423;
              t["hehfinalalttwoarabic"] = 65258;
              t["hehfinalarabic"] = 65258;
              t["hehhamzaabovefinalarabic"] = 64421;
              t["hehhamzaaboveisolatedarabic"] = 64420;
              t["hehinitialaltonearabic"] = 64424;
              t["hehinitialarabic"] = 65259;
              t["hehiragana"] = 12408;
              t["hehmedialaltonearabic"] = 64425;
              t["hehmedialarabic"] = 65260;
              t["heiseierasquare"] = 13179;
              t["hekatakana"] = 12504;
              t["hekatakanahalfwidth"] = 65421;
              t["hekutaarusquare"] = 13110;
              t["henghook"] = 615;
              t["herutusquare"] = 13113;
              t["het"] = 1495;
              t["hethebrew"] = 1495;
              t["hhook"] = 614;
              t["hhooksuperior"] = 689;
              t["hieuhacirclekorean"] = 12923;
              t["hieuhaparenkorean"] = 12827;
              t["hieuhcirclekorean"] = 12909;
              t["hieuhkorean"] = 12622;
              t["hieuhparenkorean"] = 12813;
              t["hihiragana"] = 12402;
              t["hikatakana"] = 12498;
              t["hikatakanahalfwidth"] = 65419;
              t["hiriq"] = 1460;
              t["hiriq14"] = 1460;
              t["hiriq21"] = 1460;
              t["hiriq2d"] = 1460;
              t["hiriqhebrew"] = 1460;
              t["hiriqnarrowhebrew"] = 1460;
              t["hiriqquarterhebrew"] = 1460;
              t["hiriqwidehebrew"] = 1460;
              t["hlinebelow"] = 7830;
              t["hmonospace"] = 65352;
              t["hoarmenian"] = 1392;
              t["hohipthai"] = 3627;
              t["hohiragana"] = 12411;
              t["hokatakana"] = 12507;
              t["hokatakanahalfwidth"] = 65422;
              t["holam"] = 1465;
              t["holam19"] = 1465;
              t["holam26"] = 1465;
              t["holam32"] = 1465;
              t["holamhebrew"] = 1465;
              t["holamnarrowhebrew"] = 1465;
              t["holamquarterhebrew"] = 1465;
              t["holamwidehebrew"] = 1465;
              t["honokhukthai"] = 3630;
              t["hookabovecomb"] = 777;
              t["hookcmb"] = 777;
              t["hookpalatalizedbelowcmb"] = 801;
              t["hookretroflexbelowcmb"] = 802;
              t["hoonsquare"] = 13122;
              t["horicoptic"] = 1001;
              t["horizontalbar"] = 8213;
              t["horncmb"] = 795;
              t["hotsprings"] = 9832;
              t["house"] = 8962;
              t["hparen"] = 9379;
              t["hsuperior"] = 688;
              t["hturned"] = 613;
              t["huhiragana"] = 12405;
              t["huiitosquare"] = 13107;
              t["hukatakana"] = 12501;
              t["hukatakanahalfwidth"] = 65420;
              t["hungarumlaut"] = 733;
              t["hungarumlautcmb"] = 779;
              t["hv"] = 405;
              t["hyphen"] = 45;
              t["hypheninferior"] = 63205;
              t["hyphenmonospace"] = 65293;
              t["hyphensmall"] = 65123;
              t["hyphensuperior"] = 63206;
              t["hyphentwo"] = 8208;
              t["i"] = 105;
              t["iacute"] = 237;
              t["iacyrillic"] = 1103;
              t["ibengali"] = 2439;
              t["ibopomofo"] = 12583;
              t["ibreve"] = 301;
              t["icaron"] = 464;
              t["icircle"] = 9432;
              t["icircumflex"] = 238;
              t["icyrillic"] = 1110;
              t["idblgrave"] = 521;
              t["ideographearthcircle"] = 12943;
              t["ideographfirecircle"] = 12939;
              t["ideographicallianceparen"] = 12863;
              t["ideographiccallparen"] = 12858;
              t["ideographiccentrecircle"] = 12965;
              t["ideographicclose"] = 12294;
              t["ideographiccomma"] = 12289;
              t["ideographiccommaleft"] = 65380;
              t["ideographiccongratulationparen"] = 12855;
              t["ideographiccorrectcircle"] = 12963;
              t["ideographicearthparen"] = 12847;
              t["ideographicenterpriseparen"] = 12861;
              t["ideographicexcellentcircle"] = 12957;
              t["ideographicfestivalparen"] = 12864;
              t["ideographicfinancialcircle"] = 12950;
              t["ideographicfinancialparen"] = 12854;
              t["ideographicfireparen"] = 12843;
              t["ideographichaveparen"] = 12850;
              t["ideographichighcircle"] = 12964;
              t["ideographiciterationmark"] = 12293;
              t["ideographiclaborcircle"] = 12952;
              t["ideographiclaborparen"] = 12856;
              t["ideographicleftcircle"] = 12967;
              t["ideographiclowcircle"] = 12966;
              t["ideographicmedicinecircle"] = 12969;
              t["ideographicmetalparen"] = 12846;
              t["ideographicmoonparen"] = 12842;
              t["ideographicnameparen"] = 12852;
              t["ideographicperiod"] = 12290;
              t["ideographicprintcircle"] = 12958;
              t["ideographicreachparen"] = 12867;
              t["ideographicrepresentparen"] = 12857;
              t["ideographicresourceparen"] = 12862;
              t["ideographicrightcircle"] = 12968;
              t["ideographicsecretcircle"] = 12953;
              t["ideographicselfparen"] = 12866;
              t["ideographicsocietyparen"] = 12851;
              t["ideographicspace"] = 12288;
              t["ideographicspecialparen"] = 12853;
              t["ideographicstockparen"] = 12849;
              t["ideographicstudyparen"] = 12859;
              t["ideographicsunparen"] = 12848;
              t["ideographicsuperviseparen"] = 12860;
              t["ideographicwaterparen"] = 12844;
              t["ideographicwoodparen"] = 12845;
              t["ideographiczero"] = 12295;
              t["ideographmetalcircle"] = 12942;
              t["ideographmooncircle"] = 12938;
              t["ideographnamecircle"] = 12948;
              t["ideographsuncircle"] = 12944;
              t["ideographwatercircle"] = 12940;
              t["ideographwoodcircle"] = 12941;
              t["ideva"] = 2311;
              t["idieresis"] = 239;
              t["idieresisacute"] = 7727;
              t["idieresiscyrillic"] = 1253;
              t["idotbelow"] = 7883;
              t["iebrevecyrillic"] = 1239;
              t["iecyrillic"] = 1077;
              t["ieungacirclekorean"] = 12917;
              t["ieungaparenkorean"] = 12821;
              t["ieungcirclekorean"] = 12903;
              t["ieungkorean"] = 12615;
              t["ieungparenkorean"] = 12807;
              t["igrave"] = 236;
              t["igujarati"] = 2695;
              t["igurmukhi"] = 2567;
              t["ihiragana"] = 12356;
              t["ihookabove"] = 7881;
              t["iibengali"] = 2440;
              t["iicyrillic"] = 1080;
              t["iideva"] = 2312;
              t["iigujarati"] = 2696;
              t["iigurmukhi"] = 2568;
              t["iimatragurmukhi"] = 2624;
              t["iinvertedbreve"] = 523;
              t["iishortcyrillic"] = 1081;
              t["iivowelsignbengali"] = 2496;
              t["iivowelsigndeva"] = 2368;
              t["iivowelsigngujarati"] = 2752;
              t["ij"] = 307;
              t["ikatakana"] = 12452;
              t["ikatakanahalfwidth"] = 65394;
              t["ikorean"] = 12643;
              t["ilde"] = 732;
              t["iluyhebrew"] = 1452;
              t["imacron"] = 299;
              t["imacroncyrillic"] = 1251;
              t["imageorapproximatelyequal"] = 8787;
              t["imatragurmukhi"] = 2623;
              t["imonospace"] = 65353;
              t["increment"] = 8710;
              t["infinity"] = 8734;
              t["iniarmenian"] = 1387;
              t["integral"] = 8747;
              t["integralbottom"] = 8993;
              t["integralbt"] = 8993;
              t["integralex"] = 63733;
              t["integraltop"] = 8992;
              t["integraltp"] = 8992;
              t["intersection"] = 8745;
              t["intisquare"] = 13061;
              t["invbullet"] = 9688;
              t["invcircle"] = 9689;
              t["invsmileface"] = 9787;
              t["iocyrillic"] = 1105;
              t["iogonek"] = 303;
              t["iota"] = 953;
              t["iotadieresis"] = 970;
              t["iotadieresistonos"] = 912;
              t["iotalatin"] = 617;
              t["iotatonos"] = 943;
              t["iparen"] = 9380;
              t["irigurmukhi"] = 2674;
              t["ismallhiragana"] = 12355;
              t["ismallkatakana"] = 12451;
              t["ismallkatakanahalfwidth"] = 65384;
              t["issharbengali"] = 2554;
              t["istroke"] = 616;
              t["isuperior"] = 63213;
              t["iterationhiragana"] = 12445;
              t["iterationkatakana"] = 12541;
              t["itilde"] = 297;
              t["itildebelow"] = 7725;
              t["iubopomofo"] = 12585;
              t["iucyrillic"] = 1102;
              t["ivowelsignbengali"] = 2495;
              t["ivowelsigndeva"] = 2367;
              t["ivowelsigngujarati"] = 2751;
              t["izhitsacyrillic"] = 1141;
              t["izhitsadblgravecyrillic"] = 1143;
              t["j"] = 106;
              t["jaarmenian"] = 1393;
              t["jabengali"] = 2460;
              t["jadeva"] = 2332;
              t["jagujarati"] = 2716;
              t["jagurmukhi"] = 2588;
              t["jbopomofo"] = 12560;
              t["jcaron"] = 496;
              t["jcircle"] = 9433;
              t["jcircumflex"] = 309;
              t["jcrossedtail"] = 669;
              t["jdotlessstroke"] = 607;
              t["jecyrillic"] = 1112;
              t["jeemarabic"] = 1580;
              t["jeemfinalarabic"] = 65182;
              t["jeeminitialarabic"] = 65183;
              t["jeemmedialarabic"] = 65184;
              t["jeharabic"] = 1688;
              t["jehfinalarabic"] = 64395;
              t["jhabengali"] = 2461;
              t["jhadeva"] = 2333;
              t["jhagujarati"] = 2717;
              t["jhagurmukhi"] = 2589;
              t["jheharmenian"] = 1403;
              t["jis"] = 12292;
              t["jmonospace"] = 65354;
              t["jparen"] = 9381;
              t["jsuperior"] = 690;
              t["k"] = 107;
              t["kabashkircyrillic"] = 1185;
              t["kabengali"] = 2453;
              t["kacute"] = 7729;
              t["kacyrillic"] = 1082;
              t["kadescendercyrillic"] = 1179;
              t["kadeva"] = 2325;
              t["kaf"] = 1499;
              t["kafarabic"] = 1603;
              t["kafdagesh"] = 64315;
              t["kafdageshhebrew"] = 64315;
              t["kaffinalarabic"] = 65242;
              t["kafhebrew"] = 1499;
              t["kafinitialarabic"] = 65243;
              t["kafmedialarabic"] = 65244;
              t["kafrafehebrew"] = 64333;
              t["kagujarati"] = 2709;
              t["kagurmukhi"] = 2581;
              t["kahiragana"] = 12363;
              t["kahookcyrillic"] = 1220;
              t["kakatakana"] = 12459;
              t["kakatakanahalfwidth"] = 65398;
              t["kappa"] = 954;
              t["kappasymbolgreek"] = 1008;
              t["kapyeounmieumkorean"] = 12657;
              t["kapyeounphieuphkorean"] = 12676;
              t["kapyeounpieupkorean"] = 12664;
              t["kapyeounssangpieupkorean"] = 12665;
              t["karoriisquare"] = 13069;
              t["kashidaautoarabic"] = 1600;
              t["kashidaautonosidebearingarabic"] = 1600;
              t["kasmallkatakana"] = 12533;
              t["kasquare"] = 13188;
              t["kasraarabic"] = 1616;
              t["kasratanarabic"] = 1613;
              t["kastrokecyrillic"] = 1183;
              t["katahiraprolongmarkhalfwidth"] = 65392;
              t["kaverticalstrokecyrillic"] = 1181;
              t["kbopomofo"] = 12558;
              t["kcalsquare"] = 13193;
              t["kcaron"] = 489;
              t["kcedilla"] = 311;
              t["kcircle"] = 9434;
              t["kcommaaccent"] = 311;
              t["kdotbelow"] = 7731;
              t["keharmenian"] = 1412;
              t["kehiragana"] = 12369;
              t["kekatakana"] = 12465;
              t["kekatakanahalfwidth"] = 65401;
              t["kenarmenian"] = 1391;
              t["kesmallkatakana"] = 12534;
              t["kgreenlandic"] = 312;
              t["khabengali"] = 2454;
              t["khacyrillic"] = 1093;
              t["khadeva"] = 2326;
              t["khagujarati"] = 2710;
              t["khagurmukhi"] = 2582;
              t["khaharabic"] = 1582;
              t["khahfinalarabic"] = 65190;
              t["khahinitialarabic"] = 65191;
              t["khahmedialarabic"] = 65192;
              t["kheicoptic"] = 999;
              t["khhadeva"] = 2393;
              t["khhagurmukhi"] = 2649;
              t["khieukhacirclekorean"] = 12920;
              t["khieukhaparenkorean"] = 12824;
              t["khieukhcirclekorean"] = 12906;
              t["khieukhkorean"] = 12619;
              t["khieukhparenkorean"] = 12810;
              t["khokhaithai"] = 3586;
              t["khokhonthai"] = 3589;
              t["khokhuatthai"] = 3587;
              t["khokhwaithai"] = 3588;
              t["khomutthai"] = 3675;
              t["khook"] = 409;
              t["khorakhangthai"] = 3590;
              t["khzsquare"] = 13201;
              t["kihiragana"] = 12365;
              t["kikatakana"] = 12461;
              t["kikatakanahalfwidth"] = 65399;
              t["kiroguramusquare"] = 13077;
              t["kiromeetorusquare"] = 13078;
              t["kirosquare"] = 13076;
              t["kiyeokacirclekorean"] = 12910;
              t["kiyeokaparenkorean"] = 12814;
              t["kiyeokcirclekorean"] = 12896;
              t["kiyeokkorean"] = 12593;
              t["kiyeokparenkorean"] = 12800;
              t["kiyeoksioskorean"] = 12595;
              t["kjecyrillic"] = 1116;
              t["klinebelow"] = 7733;
              t["klsquare"] = 13208;
              t["kmcubedsquare"] = 13222;
              t["kmonospace"] = 65355;
              t["kmsquaredsquare"] = 13218;
              t["kohiragana"] = 12371;
              t["kohmsquare"] = 13248;
              t["kokaithai"] = 3585;
              t["kokatakana"] = 12467;
              t["kokatakanahalfwidth"] = 65402;
              t["kooposquare"] = 13086;
              t["koppacyrillic"] = 1153;
              t["koreanstandardsymbol"] = 12927;
              t["koroniscmb"] = 835;
              t["kparen"] = 9382;
              t["kpasquare"] = 13226;
              t["ksicyrillic"] = 1135;
              t["ktsquare"] = 13263;
              t["kturned"] = 670;
              t["kuhiragana"] = 12367;
              t["kukatakana"] = 12463;
              t["kukatakanahalfwidth"] = 65400;
              t["kvsquare"] = 13240;
              t["kwsquare"] = 13246;
              t["l"] = 108;
              t["labengali"] = 2482;
              t["lacute"] = 314;
              t["ladeva"] = 2354;
              t["lagujarati"] = 2738;
              t["lagurmukhi"] = 2610;
              t["lakkhangyaothai"] = 3653;
              t["lamaleffinalarabic"] = 65276;
              t["lamalefhamzaabovefinalarabic"] = 65272;
              t["lamalefhamzaaboveisolatedarabic"] = 65271;
              t["lamalefhamzabelowfinalarabic"] = 65274;
              t["lamalefhamzabelowisolatedarabic"] = 65273;
              t["lamalefisolatedarabic"] = 65275;
              t["lamalefmaddaabovefinalarabic"] = 65270;
              t["lamalefmaddaaboveisolatedarabic"] = 65269;
              t["lamarabic"] = 1604;
              t["lambda"] = 955;
              t["lambdastroke"] = 411;
              t["lamed"] = 1500;
              t["lameddagesh"] = 64316;
              t["lameddageshhebrew"] = 64316;
              t["lamedhebrew"] = 1500;
              t["lamfinalarabic"] = 65246;
              t["lamhahinitialarabic"] = 64714;
              t["laminitialarabic"] = 65247;
              t["lamjeeminitialarabic"] = 64713;
              t["lamkhahinitialarabic"] = 64715;
              t["lamlamhehisolatedarabic"] = 65010;
              t["lammedialarabic"] = 65248;
              t["lammeemhahinitialarabic"] = 64904;
              t["lammeeminitialarabic"] = 64716;
              t["largecircle"] = 9711;
              t["lbar"] = 410;
              t["lbelt"] = 620;
              t["lbopomofo"] = 12556;
              t["lcaron"] = 318;
              t["lcedilla"] = 316;
              t["lcircle"] = 9435;
              t["lcircumflexbelow"] = 7741;
              t["lcommaaccent"] = 316;
              t["ldot"] = 320;
              t["ldotaccent"] = 320;
              t["ldotbelow"] = 7735;
              t["ldotbelowmacron"] = 7737;
              t["leftangleabovecmb"] = 794;
              t["lefttackbelowcmb"] = 792;
              t["less"] = 60;
              t["lessequal"] = 8804;
              t["lessequalorgreater"] = 8922;
              t["lessmonospace"] = 65308;
              t["lessorequivalent"] = 8818;
              t["lessorgreater"] = 8822;
              t["lessoverequal"] = 8806;
              t["lesssmall"] = 65124;
              t["lezh"] = 622;
              t["lfblock"] = 9612;
              t["lhookretroflex"] = 621;
              t["lira"] = 8356;
              t["liwnarmenian"] = 1388;
              t["lj"] = 457;
              t["ljecyrillic"] = 1113;
              t["ll"] = 63168;
              t["lladeva"] = 2355;
              t["llagujarati"] = 2739;
              t["llinebelow"] = 7739;
              t["llladeva"] = 2356;
              t["llvocalicbengali"] = 2529;
              t["llvocalicdeva"] = 2401;
              t["llvocalicvowelsignbengali"] = 2531;
              t["llvocalicvowelsigndeva"] = 2403;
              t["lmiddletilde"] = 619;
              t["lmonospace"] = 65356;
              t["lmsquare"] = 13264;
              t["lochulathai"] = 3628;
              t["logicaland"] = 8743;
              t["logicalnot"] = 172;
              t["logicalnotreversed"] = 8976;
              t["logicalor"] = 8744;
              t["lolingthai"] = 3621;
              t["longs"] = 383;
              t["lowlinecenterline"] = 65102;
              t["lowlinecmb"] = 818;
              t["lowlinedashed"] = 65101;
              t["lozenge"] = 9674;
              t["lparen"] = 9383;
              t["lslash"] = 322;
              t["lsquare"] = 8467;
              t["lsuperior"] = 63214;
              t["ltshade"] = 9617;
              t["luthai"] = 3622;
              t["lvocalicbengali"] = 2444;
              t["lvocalicdeva"] = 2316;
              t["lvocalicvowelsignbengali"] = 2530;
              t["lvocalicvowelsigndeva"] = 2402;
              t["lxsquare"] = 13267;
              t["m"] = 109;
              t["mabengali"] = 2478;
              t["macron"] = 175;
              t["macronbelowcmb"] = 817;
              t["macroncmb"] = 772;
              t["macronlowmod"] = 717;
              t["macronmonospace"] = 65507;
              t["macute"] = 7743;
              t["madeva"] = 2350;
              t["magujarati"] = 2734;
              t["magurmukhi"] = 2606;
              t["mahapakhhebrew"] = 1444;
              t["mahapakhlefthebrew"] = 1444;
              t["mahiragana"] = 12414;
              t["maichattawalowleftthai"] = 63637;
              t["maichattawalowrightthai"] = 63636;
              t["maichattawathai"] = 3659;
              t["maichattawaupperleftthai"] = 63635;
              t["maieklowleftthai"] = 63628;
              t["maieklowrightthai"] = 63627;
              t["maiekthai"] = 3656;
              t["maiekupperleftthai"] = 63626;
              t["maihanakatleftthai"] = 63620;
              t["maihanakatthai"] = 3633;
              t["maitaikhuleftthai"] = 63625;
              t["maitaikhuthai"] = 3655;
              t["maitholowleftthai"] = 63631;
              t["maitholowrightthai"] = 63630;
              t["maithothai"] = 3657;
              t["maithoupperleftthai"] = 63629;
              t["maitrilowleftthai"] = 63634;
              t["maitrilowrightthai"] = 63633;
              t["maitrithai"] = 3658;
              t["maitriupperleftthai"] = 63632;
              t["maiyamokthai"] = 3654;
              t["makatakana"] = 12510;
              t["makatakanahalfwidth"] = 65423;
              t["male"] = 9794;
              t["mansyonsquare"] = 13127;
              t["maqafhebrew"] = 1470;
              t["mars"] = 9794;
              t["masoracirclehebrew"] = 1455;
              t["masquare"] = 13187;
              t["mbopomofo"] = 12551;
              t["mbsquare"] = 13268;
              t["mcircle"] = 9436;
              t["mcubedsquare"] = 13221;
              t["mdotaccent"] = 7745;
              t["mdotbelow"] = 7747;
              t["meemarabic"] = 1605;
              t["meemfinalarabic"] = 65250;
              t["meeminitialarabic"] = 65251;
              t["meemmedialarabic"] = 65252;
              t["meemmeeminitialarabic"] = 64721;
              t["meemmeemisolatedarabic"] = 64584;
              t["meetorusquare"] = 13133;
              t["mehiragana"] = 12417;
              t["meizierasquare"] = 13182;
              t["mekatakana"] = 12513;
              t["mekatakanahalfwidth"] = 65426;
              t["mem"] = 1502;
              t["memdagesh"] = 64318;
              t["memdageshhebrew"] = 64318;
              t["memhebrew"] = 1502;
              t["menarmenian"] = 1396;
              t["merkhahebrew"] = 1445;
              t["merkhakefulahebrew"] = 1446;
              t["merkhakefulalefthebrew"] = 1446;
              t["merkhalefthebrew"] = 1445;
              t["mhook"] = 625;
              t["mhzsquare"] = 13202;
              t["middledotkatakanahalfwidth"] = 65381;
              t["middot"] = 183;
              t["mieumacirclekorean"] = 12914;
              t["mieumaparenkorean"] = 12818;
              t["mieumcirclekorean"] = 12900;
              t["mieumkorean"] = 12609;
              t["mieumpansioskorean"] = 12656;
              t["mieumparenkorean"] = 12804;
              t["mieumpieupkorean"] = 12654;
              t["mieumsioskorean"] = 12655;
              t["mihiragana"] = 12415;
              t["mikatakana"] = 12511;
              t["mikatakanahalfwidth"] = 65424;
              t["minus"] = 8722;
              t["minusbelowcmb"] = 800;
              t["minuscircle"] = 8854;
              t["minusmod"] = 727;
              t["minusplus"] = 8723;
              t["minute"] = 8242;
              t["miribaarusquare"] = 13130;
              t["mirisquare"] = 13129;
              t["mlonglegturned"] = 624;
              t["mlsquare"] = 13206;
              t["mmcubedsquare"] = 13219;
              t["mmonospace"] = 65357;
              t["mmsquaredsquare"] = 13215;
              t["mohiragana"] = 12418;
              t["mohmsquare"] = 13249;
              t["mokatakana"] = 12514;
              t["mokatakanahalfwidth"] = 65427;
              t["molsquare"] = 13270;
              t["momathai"] = 3617;
              t["moverssquare"] = 13223;
              t["moverssquaredsquare"] = 13224;
              t["mparen"] = 9384;
              t["mpasquare"] = 13227;
              t["mssquare"] = 13235;
              t["msuperior"] = 63215;
              t["mturned"] = 623;
              t["mu"] = 181;
              t["mu1"] = 181;
              t["muasquare"] = 13186;
              t["muchgreater"] = 8811;
              t["muchless"] = 8810;
              t["mufsquare"] = 13196;
              t["mugreek"] = 956;
              t["mugsquare"] = 13197;
              t["muhiragana"] = 12416;
              t["mukatakana"] = 12512;
              t["mukatakanahalfwidth"] = 65425;
              t["mulsquare"] = 13205;
              t["multiply"] = 215;
              t["mumsquare"] = 13211;
              t["munahhebrew"] = 1443;
              t["munahlefthebrew"] = 1443;
              t["musicalnote"] = 9834;
              t["musicalnotedbl"] = 9835;
              t["musicflatsign"] = 9837;
              t["musicsharpsign"] = 9839;
              t["mussquare"] = 13234;
              t["muvsquare"] = 13238;
              t["muwsquare"] = 13244;
              t["mvmegasquare"] = 13241;
              t["mvsquare"] = 13239;
              t["mwmegasquare"] = 13247;
              t["mwsquare"] = 13245;
              t["n"] = 110;
              t["nabengali"] = 2472;
              t["nabla"] = 8711;
              t["nacute"] = 324;
              t["nadeva"] = 2344;
              t["nagujarati"] = 2728;
              t["nagurmukhi"] = 2600;
              t["nahiragana"] = 12394;
              t["nakatakana"] = 12490;
              t["nakatakanahalfwidth"] = 65413;
              t["napostrophe"] = 329;
              t["nasquare"] = 13185;
              t["nbopomofo"] = 12555;
              t["nbspace"] = 160;
              t["ncaron"] = 328;
              t["ncedilla"] = 326;
              t["ncircle"] = 9437;
              t["ncircumflexbelow"] = 7755;
              t["ncommaaccent"] = 326;
              t["ndotaccent"] = 7749;
              t["ndotbelow"] = 7751;
              t["nehiragana"] = 12397;
              t["nekatakana"] = 12493;
              t["nekatakanahalfwidth"] = 65416;
              t["newsheqelsign"] = 8362;
              t["nfsquare"] = 13195;
              t["ngabengali"] = 2457;
              t["ngadeva"] = 2329;
              t["ngagujarati"] = 2713;
              t["ngagurmukhi"] = 2585;
              t["ngonguthai"] = 3591;
              t["nhiragana"] = 12435;
              t["nhookleft"] = 626;
              t["nhookretroflex"] = 627;
              t["nieunacirclekorean"] = 12911;
              t["nieunaparenkorean"] = 12815;
              t["nieuncieuckorean"] = 12597;
              t["nieuncirclekorean"] = 12897;
              t["nieunhieuhkorean"] = 12598;
              t["nieunkorean"] = 12596;
              t["nieunpansioskorean"] = 12648;
              t["nieunparenkorean"] = 12801;
              t["nieunsioskorean"] = 12647;
              t["nieuntikeutkorean"] = 12646;
              t["nihiragana"] = 12395;
              t["nikatakana"] = 12491;
              t["nikatakanahalfwidth"] = 65414;
              t["nikhahitleftthai"] = 63641;
              t["nikhahitthai"] = 3661;
              t["nine"] = 57;
              t["ninearabic"] = 1641;
              t["ninebengali"] = 2543;
              t["ninecircle"] = 9320;
              t["ninecircleinversesansserif"] = 10130;
              t["ninedeva"] = 2415;
              t["ninegujarati"] = 2799;
              t["ninegurmukhi"] = 2671;
              t["ninehackarabic"] = 1641;
              t["ninehangzhou"] = 12329;
              t["nineideographicparen"] = 12840;
              t["nineinferior"] = 8329;
              t["ninemonospace"] = 65305;
              t["nineoldstyle"] = 63289;
              t["nineparen"] = 9340;
              t["nineperiod"] = 9360;
              t["ninepersian"] = 1785;
              t["nineroman"] = 8568;
              t["ninesuperior"] = 8313;
              t["nineteencircle"] = 9330;
              t["nineteenparen"] = 9350;
              t["nineteenperiod"] = 9370;
              t["ninethai"] = 3673;
              t["nj"] = 460;
              t["njecyrillic"] = 1114;
              t["nkatakana"] = 12531;
              t["nkatakanahalfwidth"] = 65437;
              t["nlegrightlong"] = 414;
              t["nlinebelow"] = 7753;
              t["nmonospace"] = 65358;
              t["nmsquare"] = 13210;
              t["nnabengali"] = 2467;
              t["nnadeva"] = 2339;
              t["nnagujarati"] = 2723;
              t["nnagurmukhi"] = 2595;
              t["nnnadeva"] = 2345;
              t["nohiragana"] = 12398;
              t["nokatakana"] = 12494;
              t["nokatakanahalfwidth"] = 65417;
              t["nonbreakingspace"] = 160;
              t["nonenthai"] = 3603;
              t["nonuthai"] = 3609;
              t["noonarabic"] = 1606;
              t["noonfinalarabic"] = 65254;
              t["noonghunnaarabic"] = 1722;
              t["noonghunnafinalarabic"] = 64415;
              t["nooninitialarabic"] = 65255;
              t["noonjeeminitialarabic"] = 64722;
              t["noonjeemisolatedarabic"] = 64587;
              t["noonmedialarabic"] = 65256;
              t["noonmeeminitialarabic"] = 64725;
              t["noonmeemisolatedarabic"] = 64590;
              t["noonnoonfinalarabic"] = 64653;
              t["notcontains"] = 8716;
              t["notelement"] = 8713;
              t["notelementof"] = 8713;
              t["notequal"] = 8800;
              t["notgreater"] = 8815;
              t["notgreaternorequal"] = 8817;
              t["notgreaternorless"] = 8825;
              t["notidentical"] = 8802;
              t["notless"] = 8814;
              t["notlessnorequal"] = 8816;
              t["notparallel"] = 8742;
              t["notprecedes"] = 8832;
              t["notsubset"] = 8836;
              t["notsucceeds"] = 8833;
              t["notsuperset"] = 8837;
              t["nowarmenian"] = 1398;
              t["nparen"] = 9385;
              t["nssquare"] = 13233;
              t["nsuperior"] = 8319;
              t["ntilde"] = 241;
              t["nu"] = 957;
              t["nuhiragana"] = 12396;
              t["nukatakana"] = 12492;
              t["nukatakanahalfwidth"] = 65415;
              t["nuktabengali"] = 2492;
              t["nuktadeva"] = 2364;
              t["nuktagujarati"] = 2748;
              t["nuktagurmukhi"] = 2620;
              t["numbersign"] = 35;
              t["numbersignmonospace"] = 65283;
              t["numbersignsmall"] = 65119;
              t["numeralsigngreek"] = 884;
              t["numeralsignlowergreek"] = 885;
              t["numero"] = 8470;
              t["nun"] = 1504;
              t["nundagesh"] = 64320;
              t["nundageshhebrew"] = 64320;
              t["nunhebrew"] = 1504;
              t["nvsquare"] = 13237;
              t["nwsquare"] = 13243;
              t["nyabengali"] = 2462;
              t["nyadeva"] = 2334;
              t["nyagujarati"] = 2718;
              t["nyagurmukhi"] = 2590;
              t["o"] = 111;
              t["oacute"] = 243;
              t["oangthai"] = 3629;
              t["obarred"] = 629;
              t["obarredcyrillic"] = 1257;
              t["obarreddieresiscyrillic"] = 1259;
              t["obengali"] = 2451;
              t["obopomofo"] = 12571;
              t["obreve"] = 335;
              t["ocandradeva"] = 2321;
              t["ocandragujarati"] = 2705;
              t["ocandravowelsigndeva"] = 2377;
              t["ocandravowelsigngujarati"] = 2761;
              t["ocaron"] = 466;
              t["ocircle"] = 9438;
              t["ocircumflex"] = 244;
              t["ocircumflexacute"] = 7889;
              t["ocircumflexdotbelow"] = 7897;
              t["ocircumflexgrave"] = 7891;
              t["ocircumflexhookabove"] = 7893;
              t["ocircumflextilde"] = 7895;
              t["ocyrillic"] = 1086;
              t["odblacute"] = 337;
              t["odblgrave"] = 525;
              t["odeva"] = 2323;
              t["odieresis"] = 246;
              t["odieresiscyrillic"] = 1255;
              t["odotbelow"] = 7885;
              t["oe"] = 339;
              t["oekorean"] = 12634;
              t["ogonek"] = 731;
              t["ogonekcmb"] = 808;
              t["ograve"] = 242;
              t["ogujarati"] = 2707;
              t["oharmenian"] = 1413;
              t["ohiragana"] = 12362;
              t["ohookabove"] = 7887;
              t["ohorn"] = 417;
              t["ohornacute"] = 7899;
              t["ohorndotbelow"] = 7907;
              t["ohorngrave"] = 7901;
              t["ohornhookabove"] = 7903;
              t["ohorntilde"] = 7905;
              t["ohungarumlaut"] = 337;
              t["oi"] = 419;
              t["oinvertedbreve"] = 527;
              t["okatakana"] = 12458;
              t["okatakanahalfwidth"] = 65397;
              t["okorean"] = 12631;
              t["olehebrew"] = 1451;
              t["omacron"] = 333;
              t["omacronacute"] = 7763;
              t["omacrongrave"] = 7761;
              t["omdeva"] = 2384;
              t["omega"] = 969;
              t["omega1"] = 982;
              t["omegacyrillic"] = 1121;
              t["omegalatinclosed"] = 631;
              t["omegaroundcyrillic"] = 1147;
              t["omegatitlocyrillic"] = 1149;
              t["omegatonos"] = 974;
              t["omgujarati"] = 2768;
              t["omicron"] = 959;
              t["omicrontonos"] = 972;
              t["omonospace"] = 65359;
              t["one"] = 49;
              t["onearabic"] = 1633;
              t["onebengali"] = 2535;
              t["onecircle"] = 9312;
              t["onecircleinversesansserif"] = 10122;
              t["onedeva"] = 2407;
              t["onedotenleader"] = 8228;
              t["oneeighth"] = 8539;
              t["onefitted"] = 63196;
              t["onegujarati"] = 2791;
              t["onegurmukhi"] = 2663;
              t["onehackarabic"] = 1633;
              t["onehalf"] = 189;
              t["onehangzhou"] = 12321;
              t["oneideographicparen"] = 12832;
              t["oneinferior"] = 8321;
              t["onemonospace"] = 65297;
              t["onenumeratorbengali"] = 2548;
              t["oneoldstyle"] = 63281;
              t["oneparen"] = 9332;
              t["oneperiod"] = 9352;
              t["onepersian"] = 1777;
              t["onequarter"] = 188;
              t["oneroman"] = 8560;
              t["onesuperior"] = 185;
              t["onethai"] = 3665;
              t["onethird"] = 8531;
              t["oogonek"] = 491;
              t["oogonekmacron"] = 493;
              t["oogurmukhi"] = 2579;
              t["oomatragurmukhi"] = 2635;
              t["oopen"] = 596;
              t["oparen"] = 9386;
              t["openbullet"] = 9702;
              t["option"] = 8997;
              t["ordfeminine"] = 170;
              t["ordmasculine"] = 186;
              t["orthogonal"] = 8735;
              t["oshortdeva"] = 2322;
              t["oshortvowelsigndeva"] = 2378;
              t["oslash"] = 248;
              t["oslashacute"] = 511;
              t["osmallhiragana"] = 12361;
              t["osmallkatakana"] = 12457;
              t["osmallkatakanahalfwidth"] = 65387;
              t["ostrokeacute"] = 511;
              t["osuperior"] = 63216;
              t["otcyrillic"] = 1151;
              t["otilde"] = 245;
              t["otildeacute"] = 7757;
              t["otildedieresis"] = 7759;
              t["oubopomofo"] = 12577;
              t["overline"] = 8254;
              t["overlinecenterline"] = 65098;
              t["overlinecmb"] = 773;
              t["overlinedashed"] = 65097;
              t["overlinedblwavy"] = 65100;
              t["overlinewavy"] = 65099;
              t["overscore"] = 175;
              t["ovowelsignbengali"] = 2507;
              t["ovowelsigndeva"] = 2379;
              t["ovowelsigngujarati"] = 2763;
              t["p"] = 112;
              t["paampssquare"] = 13184;
              t["paasentosquare"] = 13099;
              t["pabengali"] = 2474;
              t["pacute"] = 7765;
              t["padeva"] = 2346;
              t["pagedown"] = 8671;
              t["pageup"] = 8670;
              t["pagujarati"] = 2730;
              t["pagurmukhi"] = 2602;
              t["pahiragana"] = 12401;
              t["paiyannoithai"] = 3631;
              t["pakatakana"] = 12497;
              t["palatalizationcyrilliccmb"] = 1156;
              t["palochkacyrillic"] = 1216;
              t["pansioskorean"] = 12671;
              t["paragraph"] = 182;
              t["parallel"] = 8741;
              t["parenleft"] = 40;
              t["parenleftaltonearabic"] = 64830;
              t["parenleftbt"] = 63725;
              t["parenleftex"] = 63724;
              t["parenleftinferior"] = 8333;
              t["parenleftmonospace"] = 65288;
              t["parenleftsmall"] = 65113;
              t["parenleftsuperior"] = 8317;
              t["parenlefttp"] = 63723;
              t["parenleftvertical"] = 65077;
              t["parenright"] = 41;
              t["parenrightaltonearabic"] = 64831;
              t["parenrightbt"] = 63736;
              t["parenrightex"] = 63735;
              t["parenrightinferior"] = 8334;
              t["parenrightmonospace"] = 65289;
              t["parenrightsmall"] = 65114;
              t["parenrightsuperior"] = 8318;
              t["parenrighttp"] = 63734;
              t["parenrightvertical"] = 65078;
              t["partialdiff"] = 8706;
              t["paseqhebrew"] = 1472;
              t["pashtahebrew"] = 1433;
              t["pasquare"] = 13225;
              t["patah"] = 1463;
              t["patah11"] = 1463;
              t["patah1d"] = 1463;
              t["patah2a"] = 1463;
              t["patahhebrew"] = 1463;
              t["patahnarrowhebrew"] = 1463;
              t["patahquarterhebrew"] = 1463;
              t["patahwidehebrew"] = 1463;
              t["pazerhebrew"] = 1441;
              t["pbopomofo"] = 12550;
              t["pcircle"] = 9439;
              t["pdotaccent"] = 7767;
              t["pe"] = 1508;
              t["pecyrillic"] = 1087;
              t["pedagesh"] = 64324;
              t["pedageshhebrew"] = 64324;
              t["peezisquare"] = 13115;
              t["pefinaldageshhebrew"] = 64323;
              t["peharabic"] = 1662;
              t["peharmenian"] = 1402;
              t["pehebrew"] = 1508;
              t["pehfinalarabic"] = 64343;
              t["pehinitialarabic"] = 64344;
              t["pehiragana"] = 12410;
              t["pehmedialarabic"] = 64345;
              t["pekatakana"] = 12506;
              t["pemiddlehookcyrillic"] = 1191;
              t["perafehebrew"] = 64334;
              t["percent"] = 37;
              t["percentarabic"] = 1642;
              t["percentmonospace"] = 65285;
              t["percentsmall"] = 65130;
              t["period"] = 46;
              t["periodarmenian"] = 1417;
              t["periodcentered"] = 183;
              t["periodhalfwidth"] = 65377;
              t["periodinferior"] = 63207;
              t["periodmonospace"] = 65294;
              t["periodsmall"] = 65106;
              t["periodsuperior"] = 63208;
              t["perispomenigreekcmb"] = 834;
              t["perpendicular"] = 8869;
              t["perthousand"] = 8240;
              t["peseta"] = 8359;
              t["pfsquare"] = 13194;
              t["phabengali"] = 2475;
              t["phadeva"] = 2347;
              t["phagujarati"] = 2731;
              t["phagurmukhi"] = 2603;
              t["phi"] = 966;
              t["phi1"] = 981;
              t["phieuphacirclekorean"] = 12922;
              t["phieuphaparenkorean"] = 12826;
              t["phieuphcirclekorean"] = 12908;
              t["phieuphkorean"] = 12621;
              t["phieuphparenkorean"] = 12812;
              t["philatin"] = 632;
              t["phinthuthai"] = 3642;
              t["phisymbolgreek"] = 981;
              t["phook"] = 421;
              t["phophanthai"] = 3614;
              t["phophungthai"] = 3612;
              t["phosamphaothai"] = 3616;
              t["pi"] = 960;
              t["pieupacirclekorean"] = 12915;
              t["pieupaparenkorean"] = 12819;
              t["pieupcieuckorean"] = 12662;
              t["pieupcirclekorean"] = 12901;
              t["pieupkiyeokkorean"] = 12658;
              t["pieupkorean"] = 12610;
              t["pieupparenkorean"] = 12805;
              t["pieupsioskiyeokkorean"] = 12660;
              t["pieupsioskorean"] = 12612;
              t["pieupsiostikeutkorean"] = 12661;
              t["pieupthieuthkorean"] = 12663;
              t["pieuptikeutkorean"] = 12659;
              t["pihiragana"] = 12404;
              t["pikatakana"] = 12500;
              t["pisymbolgreek"] = 982;
              t["piwrarmenian"] = 1411;
              t["plus"] = 43;
              t["plusbelowcmb"] = 799;
              t["pluscircle"] = 8853;
              t["plusminus"] = 177;
              t["plusmod"] = 726;
              t["plusmonospace"] = 65291;
              t["plussmall"] = 65122;
              t["plussuperior"] = 8314;
              t["pmonospace"] = 65360;
              t["pmsquare"] = 13272;
              t["pohiragana"] = 12413;
              t["pointingindexdownwhite"] = 9759;
              t["pointingindexleftwhite"] = 9756;
              t["pointingindexrightwhite"] = 9758;
              t["pointingindexupwhite"] = 9757;
              t["pokatakana"] = 12509;
              t["poplathai"] = 3611;
              t["postalmark"] = 12306;
              t["postalmarkface"] = 12320;
              t["pparen"] = 9387;
              t["precedes"] = 8826;
              t["prescription"] = 8478;
              t["primemod"] = 697;
              t["primereversed"] = 8245;
              t["product"] = 8719;
              t["projective"] = 8965;
              t["prolongedkana"] = 12540;
              t["propellor"] = 8984;
              t["propersubset"] = 8834;
              t["propersuperset"] = 8835;
              t["proportion"] = 8759;
              t["proportional"] = 8733;
              t["psi"] = 968;
              t["psicyrillic"] = 1137;
              t["psilipneumatacyrilliccmb"] = 1158;
              t["pssquare"] = 13232;
              t["puhiragana"] = 12407;
              t["pukatakana"] = 12503;
              t["pvsquare"] = 13236;
              t["pwsquare"] = 13242;
              t["q"] = 113;
              t["qadeva"] = 2392;
              t["qadmahebrew"] = 1448;
              t["qafarabic"] = 1602;
              t["qaffinalarabic"] = 65238;
              t["qafinitialarabic"] = 65239;
              t["qafmedialarabic"] = 65240;
              t["qamats"] = 1464;
              t["qamats10"] = 1464;
              t["qamats1a"] = 1464;
              t["qamats1c"] = 1464;
              t["qamats27"] = 1464;
              t["qamats29"] = 1464;
              t["qamats33"] = 1464;
              t["qamatsde"] = 1464;
              t["qamatshebrew"] = 1464;
              t["qamatsnarrowhebrew"] = 1464;
              t["qamatsqatanhebrew"] = 1464;
              t["qamatsqatannarrowhebrew"] = 1464;
              t["qamatsqatanquarterhebrew"] = 1464;
              t["qamatsqatanwidehebrew"] = 1464;
              t["qamatsquarterhebrew"] = 1464;
              t["qamatswidehebrew"] = 1464;
              t["qarneyparahebrew"] = 1439;
              t["qbopomofo"] = 12561;
              t["qcircle"] = 9440;
              t["qhook"] = 672;
              t["qmonospace"] = 65361;
              t["qof"] = 1511;
              t["qofdagesh"] = 64327;
              t["qofdageshhebrew"] = 64327;
              t["qofhebrew"] = 1511;
              t["qparen"] = 9388;
              t["quarternote"] = 9833;
              t["qubuts"] = 1467;
              t["qubuts18"] = 1467;
              t["qubuts25"] = 1467;
              t["qubuts31"] = 1467;
              t["qubutshebrew"] = 1467;
              t["qubutsnarrowhebrew"] = 1467;
              t["qubutsquarterhebrew"] = 1467;
              t["qubutswidehebrew"] = 1467;
              t["question"] = 63;
              t["questionarabic"] = 1567;
              t["questionarmenian"] = 1374;
              t["questiondown"] = 191;
              t["questiondownsmall"] = 63423;
              t["questiongreek"] = 894;
              t["questionmonospace"] = 65311;
              t["questionsmall"] = 63295;
              t["quotedbl"] = 34;
              t["quotedblbase"] = 8222;
              t["quotedblleft"] = 8220;
              t["quotedblmonospace"] = 65282;
              t["quotedblprime"] = 12318;
              t["quotedblprimereversed"] = 12317;
              t["quotedblright"] = 8221;
              t["quoteleft"] = 8216;
              t["quoteleftreversed"] = 8219;
              t["quotereversed"] = 8219;
              t["quoteright"] = 8217;
              t["quoterightn"] = 329;
              t["quotesinglbase"] = 8218;
              t["quotesingle"] = 39;
              t["quotesinglemonospace"] = 65287;
              t["r"] = 114;
              t["raarmenian"] = 1404;
              t["rabengali"] = 2480;
              t["racute"] = 341;
              t["radeva"] = 2352;
              t["radical"] = 8730;
              t["radicalex"] = 63717;
              t["radoverssquare"] = 13230;
              t["radoverssquaredsquare"] = 13231;
              t["radsquare"] = 13229;
              t["rafe"] = 1471;
              t["rafehebrew"] = 1471;
              t["ragujarati"] = 2736;
              t["ragurmukhi"] = 2608;
              t["rahiragana"] = 12425;
              t["rakatakana"] = 12521;
              t["rakatakanahalfwidth"] = 65431;
              t["ralowerdiagonalbengali"] = 2545;
              t["ramiddlediagonalbengali"] = 2544;
              t["ramshorn"] = 612;
              t["ratio"] = 8758;
              t["rbopomofo"] = 12566;
              t["rcaron"] = 345;
              t["rcedilla"] = 343;
              t["rcircle"] = 9441;
              t["rcommaaccent"] = 343;
              t["rdblgrave"] = 529;
              t["rdotaccent"] = 7769;
              t["rdotbelow"] = 7771;
              t["rdotbelowmacron"] = 7773;
              t["referencemark"] = 8251;
              t["reflexsubset"] = 8838;
              t["reflexsuperset"] = 8839;
              t["registered"] = 174;
              t["registersans"] = 63720;
              t["registerserif"] = 63194;
              t["reharabic"] = 1585;
              t["reharmenian"] = 1408;
              t["rehfinalarabic"] = 65198;
              t["rehiragana"] = 12428;
              t["rekatakana"] = 12524;
              t["rekatakanahalfwidth"] = 65434;
              t["resh"] = 1512;
              t["reshdageshhebrew"] = 64328;
              t["reshhebrew"] = 1512;
              t["reversedtilde"] = 8765;
              t["reviahebrew"] = 1431;
              t["reviamugrashhebrew"] = 1431;
              t["revlogicalnot"] = 8976;
              t["rfishhook"] = 638;
              t["rfishhookreversed"] = 639;
              t["rhabengali"] = 2525;
              t["rhadeva"] = 2397;
              t["rho"] = 961;
              t["rhook"] = 637;
              t["rhookturned"] = 635;
              t["rhookturnedsuperior"] = 693;
              t["rhosymbolgreek"] = 1009;
              t["rhotichookmod"] = 734;
              t["rieulacirclekorean"] = 12913;
              t["rieulaparenkorean"] = 12817;
              t["rieulcirclekorean"] = 12899;
              t["rieulhieuhkorean"] = 12608;
              t["rieulkiyeokkorean"] = 12602;
              t["rieulkiyeoksioskorean"] = 12649;
              t["rieulkorean"] = 12601;
              t["rieulmieumkorean"] = 12603;
              t["rieulpansioskorean"] = 12652;
              t["rieulparenkorean"] = 12803;
              t["rieulphieuphkorean"] = 12607;
              t["rieulpieupkorean"] = 12604;
              t["rieulpieupsioskorean"] = 12651;
              t["rieulsioskorean"] = 12605;
              t["rieulthieuthkorean"] = 12606;
              t["rieultikeutkorean"] = 12650;
              t["rieulyeorinhieuhkorean"] = 12653;
              t["rightangle"] = 8735;
              t["righttackbelowcmb"] = 793;
              t["righttriangle"] = 8895;
              t["rihiragana"] = 12426;
              t["rikatakana"] = 12522;
              t["rikatakanahalfwidth"] = 65432;
              t["ring"] = 730;
              t["ringbelowcmb"] = 805;
              t["ringcmb"] = 778;
              t["ringhalfleft"] = 703;
              t["ringhalfleftarmenian"] = 1369;
              t["ringhalfleftbelowcmb"] = 796;
              t["ringhalfleftcentered"] = 723;
              t["ringhalfright"] = 702;
              t["ringhalfrightbelowcmb"] = 825;
              t["ringhalfrightcentered"] = 722;
              t["rinvertedbreve"] = 531;
              t["rittorusquare"] = 13137;
              t["rlinebelow"] = 7775;
              t["rlongleg"] = 636;
              t["rlonglegturned"] = 634;
              t["rmonospace"] = 65362;
              t["rohiragana"] = 12429;
              t["rokatakana"] = 12525;
              t["rokatakanahalfwidth"] = 65435;
              t["roruathai"] = 3619;
              t["rparen"] = 9389;
              t["rrabengali"] = 2524;
              t["rradeva"] = 2353;
              t["rragurmukhi"] = 2652;
              t["rreharabic"] = 1681;
              t["rrehfinalarabic"] = 64397;
              t["rrvocalicbengali"] = 2528;
              t["rrvocalicdeva"] = 2400;
              t["rrvocalicgujarati"] = 2784;
              t["rrvocalicvowelsignbengali"] = 2500;
              t["rrvocalicvowelsigndeva"] = 2372;
              t["rrvocalicvowelsigngujarati"] = 2756;
              t["rsuperior"] = 63217;
              t["rtblock"] = 9616;
              t["rturned"] = 633;
              t["rturnedsuperior"] = 692;
              t["ruhiragana"] = 12427;
              t["rukatakana"] = 12523;
              t["rukatakanahalfwidth"] = 65433;
              t["rupeemarkbengali"] = 2546;
              t["rupeesignbengali"] = 2547;
              t["rupiah"] = 63197;
              t["ruthai"] = 3620;
              t["rvocalicbengali"] = 2443;
              t["rvocalicdeva"] = 2315;
              t["rvocalicgujarati"] = 2699;
              t["rvocalicvowelsignbengali"] = 2499;
              t["rvocalicvowelsigndeva"] = 2371;
              t["rvocalicvowelsigngujarati"] = 2755;
              t["s"] = 115;
              t["sabengali"] = 2488;
              t["sacute"] = 347;
              t["sacutedotaccent"] = 7781;
              t["sadarabic"] = 1589;
              t["sadeva"] = 2360;
              t["sadfinalarabic"] = 65210;
              t["sadinitialarabic"] = 65211;
              t["sadmedialarabic"] = 65212;
              t["sagujarati"] = 2744;
              t["sagurmukhi"] = 2616;
              t["sahiragana"] = 12373;
              t["sakatakana"] = 12469;
              t["sakatakanahalfwidth"] = 65403;
              t["sallallahoualayhewasallamarabic"] = 65018;
              t["samekh"] = 1505;
              t["samekhdagesh"] = 64321;
              t["samekhdageshhebrew"] = 64321;
              t["samekhhebrew"] = 1505;
              t["saraaathai"] = 3634;
              t["saraaethai"] = 3649;
              t["saraaimaimalaithai"] = 3652;
              t["saraaimaimuanthai"] = 3651;
              t["saraamthai"] = 3635;
              t["saraathai"] = 3632;
              t["saraethai"] = 3648;
              t["saraiileftthai"] = 63622;
              t["saraiithai"] = 3637;
              t["saraileftthai"] = 63621;
              t["saraithai"] = 3636;
              t["saraothai"] = 3650;
              t["saraueeleftthai"] = 63624;
              t["saraueethai"] = 3639;
              t["saraueleftthai"] = 63623;
              t["sarauethai"] = 3638;
              t["sarauthai"] = 3640;
              t["sarauuthai"] = 3641;
              t["sbopomofo"] = 12569;
              t["scaron"] = 353;
              t["scarondotaccent"] = 7783;
              t["scedilla"] = 351;
              t["schwa"] = 601;
              t["schwacyrillic"] = 1241;
              t["schwadieresiscyrillic"] = 1243;
              t["schwahook"] = 602;
              t["scircle"] = 9442;
              t["scircumflex"] = 349;
              t["scommaaccent"] = 537;
              t["sdotaccent"] = 7777;
              t["sdotbelow"] = 7779;
              t["sdotbelowdotaccent"] = 7785;
              t["seagullbelowcmb"] = 828;
              t["second"] = 8243;
              t["secondtonechinese"] = 714;
              t["section"] = 167;
              t["seenarabic"] = 1587;
              t["seenfinalarabic"] = 65202;
              t["seeninitialarabic"] = 65203;
              t["seenmedialarabic"] = 65204;
              t["segol"] = 1462;
              t["segol13"] = 1462;
              t["segol1f"] = 1462;
              t["segol2c"] = 1462;
              t["segolhebrew"] = 1462;
              t["segolnarrowhebrew"] = 1462;
              t["segolquarterhebrew"] = 1462;
              t["segoltahebrew"] = 1426;
              t["segolwidehebrew"] = 1462;
              t["seharmenian"] = 1405;
              t["sehiragana"] = 12379;
              t["sekatakana"] = 12475;
              t["sekatakanahalfwidth"] = 65406;
              t["semicolon"] = 59;
              t["semicolonarabic"] = 1563;
              t["semicolonmonospace"] = 65307;
              t["semicolonsmall"] = 65108;
              t["semivoicedmarkkana"] = 12444;
              t["semivoicedmarkkanahalfwidth"] = 65439;
              t["sentisquare"] = 13090;
              t["sentosquare"] = 13091;
              t["seven"] = 55;
              t["sevenarabic"] = 1639;
              t["sevenbengali"] = 2541;
              t["sevencircle"] = 9318;
              t["sevencircleinversesansserif"] = 10128;
              t["sevendeva"] = 2413;
              t["seveneighths"] = 8542;
              t["sevengujarati"] = 2797;
              t["sevengurmukhi"] = 2669;
              t["sevenhackarabic"] = 1639;
              t["sevenhangzhou"] = 12327;
              t["sevenideographicparen"] = 12838;
              t["seveninferior"] = 8327;
              t["sevenmonospace"] = 65303;
              t["sevenoldstyle"] = 63287;
              t["sevenparen"] = 9338;
              t["sevenperiod"] = 9358;
              t["sevenpersian"] = 1783;
              t["sevenroman"] = 8566;
              t["sevensuperior"] = 8311;
              t["seventeencircle"] = 9328;
              t["seventeenparen"] = 9348;
              t["seventeenperiod"] = 9368;
              t["seventhai"] = 3671;
              t["sfthyphen"] = 173;
              t["shaarmenian"] = 1399;
              t["shabengali"] = 2486;
              t["shacyrillic"] = 1096;
              t["shaddaarabic"] = 1617;
              t["shaddadammaarabic"] = 64609;
              t["shaddadammatanarabic"] = 64606;
              t["shaddafathaarabic"] = 64608;
              t["shaddakasraarabic"] = 64610;
              t["shaddakasratanarabic"] = 64607;
              t["shade"] = 9618;
              t["shadedark"] = 9619;
              t["shadelight"] = 9617;
              t["shademedium"] = 9618;
              t["shadeva"] = 2358;
              t["shagujarati"] = 2742;
              t["shagurmukhi"] = 2614;
              t["shalshelethebrew"] = 1427;
              t["shbopomofo"] = 12565;
              t["shchacyrillic"] = 1097;
              t["sheenarabic"] = 1588;
              t["sheenfinalarabic"] = 65206;
              t["sheeninitialarabic"] = 65207;
              t["sheenmedialarabic"] = 65208;
              t["sheicoptic"] = 995;
              t["sheqel"] = 8362;
              t["sheqelhebrew"] = 8362;
              t["sheva"] = 1456;
              t["sheva115"] = 1456;
              t["sheva15"] = 1456;
              t["sheva22"] = 1456;
              t["sheva2e"] = 1456;
              t["shevahebrew"] = 1456;
              t["shevanarrowhebrew"] = 1456;
              t["shevaquarterhebrew"] = 1456;
              t["shevawidehebrew"] = 1456;
              t["shhacyrillic"] = 1211;
              t["shimacoptic"] = 1005;
              t["shin"] = 1513;
              t["shindagesh"] = 64329;
              t["shindageshhebrew"] = 64329;
              t["shindageshshindot"] = 64300;
              t["shindageshshindothebrew"] = 64300;
              t["shindageshsindot"] = 64301;
              t["shindageshsindothebrew"] = 64301;
              t["shindothebrew"] = 1473;
              t["shinhebrew"] = 1513;
              t["shinshindot"] = 64298;
              t["shinshindothebrew"] = 64298;
              t["shinsindot"] = 64299;
              t["shinsindothebrew"] = 64299;
              t["shook"] = 642;
              t["sigma"] = 963;
              t["sigma1"] = 962;
              t["sigmafinal"] = 962;
              t["sigmalunatesymbolgreek"] = 1010;
              t["sihiragana"] = 12375;
              t["sikatakana"] = 12471;
              t["sikatakanahalfwidth"] = 65404;
              t["siluqhebrew"] = 1469;
              t["siluqlefthebrew"] = 1469;
              t["similar"] = 8764;
              t["sindothebrew"] = 1474;
              t["siosacirclekorean"] = 12916;
              t["siosaparenkorean"] = 12820;
              t["sioscieuckorean"] = 12670;
              t["sioscirclekorean"] = 12902;
              t["sioskiyeokkorean"] = 12666;
              t["sioskorean"] = 12613;
              t["siosnieunkorean"] = 12667;
              t["siosparenkorean"] = 12806;
              t["siospieupkorean"] = 12669;
              t["siostikeutkorean"] = 12668;
              t["six"] = 54;
              t["sixarabic"] = 1638;
              t["sixbengali"] = 2540;
              t["sixcircle"] = 9317;
              t["sixcircleinversesansserif"] = 10127;
              t["sixdeva"] = 2412;
              t["sixgujarati"] = 2796;
              t["sixgurmukhi"] = 2668;
              t["sixhackarabic"] = 1638;
              t["sixhangzhou"] = 12326;
              t["sixideographicparen"] = 12837;
              t["sixinferior"] = 8326;
              t["sixmonospace"] = 65302;
              t["sixoldstyle"] = 63286;
              t["sixparen"] = 9337;
              t["sixperiod"] = 9357;
              t["sixpersian"] = 1782;
              t["sixroman"] = 8565;
              t["sixsuperior"] = 8310;
              t["sixteencircle"] = 9327;
              t["sixteencurrencydenominatorbengali"] = 2553;
              t["sixteenparen"] = 9347;
              t["sixteenperiod"] = 9367;
              t["sixthai"] = 3670;
              t["slash"] = 47;
              t["slashmonospace"] = 65295;
              t["slong"] = 383;
              t["slongdotaccent"] = 7835;
              t["smileface"] = 9786;
              t["smonospace"] = 65363;
              t["sofpasuqhebrew"] = 1475;
              t["softhyphen"] = 173;
              t["softsigncyrillic"] = 1100;
              t["sohiragana"] = 12381;
              t["sokatakana"] = 12477;
              t["sokatakanahalfwidth"] = 65407;
              t["soliduslongoverlaycmb"] = 824;
              t["solidusshortoverlaycmb"] = 823;
              t["sorusithai"] = 3625;
              t["sosalathai"] = 3624;
              t["sosothai"] = 3595;
              t["sosuathai"] = 3626;
              t["space"] = 32;
              t["spacehackarabic"] = 32;
              t["spade"] = 9824;
              t["spadesuitblack"] = 9824;
              t["spadesuitwhite"] = 9828;
              t["sparen"] = 9390;
              t["squarebelowcmb"] = 827;
              t["squarecc"] = 13252;
              t["squarecm"] = 13213;
              t["squarediagonalcrosshatchfill"] = 9641;
              t["squarehorizontalfill"] = 9636;
              t["squarekg"] = 13199;
              t["squarekm"] = 13214;
              t["squarekmcapital"] = 13262;
              t["squareln"] = 13265;
              t["squarelog"] = 13266;
              t["squaremg"] = 13198;
              t["squaremil"] = 13269;
              t["squaremm"] = 13212;
              t["squaremsquared"] = 13217;
              t["squareorthogonalcrosshatchfill"] = 9638;
              t["squareupperlefttolowerrightfill"] = 9639;
              t["squareupperrighttolowerleftfill"] = 9640;
              t["squareverticalfill"] = 9637;
              t["squarewhitewithsmallblack"] = 9635;
              t["srsquare"] = 13275;
              t["ssabengali"] = 2487;
              t["ssadeva"] = 2359;
              t["ssagujarati"] = 2743;
              t["ssangcieuckorean"] = 12617;
              t["ssanghieuhkorean"] = 12677;
              t["ssangieungkorean"] = 12672;
              t["ssangkiyeokkorean"] = 12594;
              t["ssangnieunkorean"] = 12645;
              t["ssangpieupkorean"] = 12611;
              t["ssangsioskorean"] = 12614;
              t["ssangtikeutkorean"] = 12600;
              t["ssuperior"] = 63218;
              t["sterling"] = 163;
              t["sterlingmonospace"] = 65505;
              t["strokelongoverlaycmb"] = 822;
              t["strokeshortoverlaycmb"] = 821;
              t["subset"] = 8834;
              t["subsetnotequal"] = 8842;
              t["subsetorequal"] = 8838;
              t["succeeds"] = 8827;
              t["suchthat"] = 8715;
              t["suhiragana"] = 12377;
              t["sukatakana"] = 12473;
              t["sukatakanahalfwidth"] = 65405;
              t["sukunarabic"] = 1618;
              t["summation"] = 8721;
              t["sun"] = 9788;
              t["superset"] = 8835;
              t["supersetnotequal"] = 8843;
              t["supersetorequal"] = 8839;
              t["svsquare"] = 13276;
              t["syouwaerasquare"] = 13180;
              t["t"] = 116;
              t["tabengali"] = 2468;
              t["tackdown"] = 8868;
              t["tackleft"] = 8867;
              t["tadeva"] = 2340;
              t["tagujarati"] = 2724;
              t["tagurmukhi"] = 2596;
              t["taharabic"] = 1591;
              t["tahfinalarabic"] = 65218;
              t["tahinitialarabic"] = 65219;
              t["tahiragana"] = 12383;
              t["tahmedialarabic"] = 65220;
              t["taisyouerasquare"] = 13181;
              t["takatakana"] = 12479;
              t["takatakanahalfwidth"] = 65408;
              t["tatweelarabic"] = 1600;
              t["tau"] = 964;
              t["tav"] = 1514;
              t["tavdages"] = 64330;
              t["tavdagesh"] = 64330;
              t["tavdageshhebrew"] = 64330;
              t["tavhebrew"] = 1514;
              t["tbar"] = 359;
              t["tbopomofo"] = 12554;
              t["tcaron"] = 357;
              t["tccurl"] = 680;
              t["tcedilla"] = 355;
              t["tcheharabic"] = 1670;
              t["tchehfinalarabic"] = 64379;
              t["tchehinitialarabic"] = 64380;
              t["tchehmedialarabic"] = 64381;
              t["tcircle"] = 9443;
              t["tcircumflexbelow"] = 7793;
              t["tcommaaccent"] = 355;
              t["tdieresis"] = 7831;
              t["tdotaccent"] = 7787;
              t["tdotbelow"] = 7789;
              t["tecyrillic"] = 1090;
              t["tedescendercyrillic"] = 1197;
              t["teharabic"] = 1578;
              t["tehfinalarabic"] = 65174;
              t["tehhahinitialarabic"] = 64674;
              t["tehhahisolatedarabic"] = 64524;
              t["tehinitialarabic"] = 65175;
              t["tehiragana"] = 12390;
              t["tehjeeminitialarabic"] = 64673;
              t["tehjeemisolatedarabic"] = 64523;
              t["tehmarbutaarabic"] = 1577;
              t["tehmarbutafinalarabic"] = 65172;
              t["tehmedialarabic"] = 65176;
              t["tehmeeminitialarabic"] = 64676;
              t["tehmeemisolatedarabic"] = 64526;
              t["tehnoonfinalarabic"] = 64627;
              t["tekatakana"] = 12486;
              t["tekatakanahalfwidth"] = 65411;
              t["telephone"] = 8481;
              t["telephoneblack"] = 9742;
              t["telishagedolahebrew"] = 1440;
              t["telishaqetanahebrew"] = 1449;
              t["tencircle"] = 9321;
              t["tenideographicparen"] = 12841;
              t["tenparen"] = 9341;
              t["tenperiod"] = 9361;
              t["tenroman"] = 8569;
              t["tesh"] = 679;
              t["tet"] = 1496;
              t["tetdagesh"] = 64312;
              t["tetdageshhebrew"] = 64312;
              t["tethebrew"] = 1496;
              t["tetsecyrillic"] = 1205;
              t["tevirhebrew"] = 1435;
              t["tevirlefthebrew"] = 1435;
              t["thabengali"] = 2469;
              t["thadeva"] = 2341;
              t["thagujarati"] = 2725;
              t["thagurmukhi"] = 2597;
              t["thalarabic"] = 1584;
              t["thalfinalarabic"] = 65196;
              t["thanthakhatlowleftthai"] = 63640;
              t["thanthakhatlowrightthai"] = 63639;
              t["thanthakhatthai"] = 3660;
              t["thanthakhatupperleftthai"] = 63638;
              t["theharabic"] = 1579;
              t["thehfinalarabic"] = 65178;
              t["thehinitialarabic"] = 65179;
              t["thehmedialarabic"] = 65180;
              t["thereexists"] = 8707;
              t["therefore"] = 8756;
              t["theta"] = 952;
              t["theta1"] = 977;
              t["thetasymbolgreek"] = 977;
              t["thieuthacirclekorean"] = 12921;
              t["thieuthaparenkorean"] = 12825;
              t["thieuthcirclekorean"] = 12907;
              t["thieuthkorean"] = 12620;
              t["thieuthparenkorean"] = 12811;
              t["thirteencircle"] = 9324;
              t["thirteenparen"] = 9344;
              t["thirteenperiod"] = 9364;
              t["thonangmonthothai"] = 3601;
              t["thook"] = 429;
              t["thophuthaothai"] = 3602;
              t["thorn"] = 254;
              t["thothahanthai"] = 3607;
              t["thothanthai"] = 3600;
              t["thothongthai"] = 3608;
              t["thothungthai"] = 3606;
              t["thousandcyrillic"] = 1154;
              t["thousandsseparatorarabic"] = 1644;
              t["thousandsseparatorpersian"] = 1644;
              t["three"] = 51;
              t["threearabic"] = 1635;
              t["threebengali"] = 2537;
              t["threecircle"] = 9314;
              t["threecircleinversesansserif"] = 10124;
              t["threedeva"] = 2409;
              t["threeeighths"] = 8540;
              t["threegujarati"] = 2793;
              t["threegurmukhi"] = 2665;
              t["threehackarabic"] = 1635;
              t["threehangzhou"] = 12323;
              t["threeideographicparen"] = 12834;
              t["threeinferior"] = 8323;
              t["threemonospace"] = 65299;
              t["threenumeratorbengali"] = 2550;
              t["threeoldstyle"] = 63283;
              t["threeparen"] = 9334;
              t["threeperiod"] = 9354;
              t["threepersian"] = 1779;
              t["threequarters"] = 190;
              t["threequartersemdash"] = 63198;
              t["threeroman"] = 8562;
              t["threesuperior"] = 179;
              t["threethai"] = 3667;
              t["thzsquare"] = 13204;
              t["tihiragana"] = 12385;
              t["tikatakana"] = 12481;
              t["tikatakanahalfwidth"] = 65409;
              t["tikeutacirclekorean"] = 12912;
              t["tikeutaparenkorean"] = 12816;
              t["tikeutcirclekorean"] = 12898;
              t["tikeutkorean"] = 12599;
              t["tikeutparenkorean"] = 12802;
              t["tilde"] = 732;
              t["tildebelowcmb"] = 816;
              t["tildecmb"] = 771;
              t["tildecomb"] = 771;
              t["tildedoublecmb"] = 864;
              t["tildeoperator"] = 8764;
              t["tildeoverlaycmb"] = 820;
              t["tildeverticalcmb"] = 830;
              t["timescircle"] = 8855;
              t["tipehahebrew"] = 1430;
              t["tipehalefthebrew"] = 1430;
              t["tippigurmukhi"] = 2672;
              t["titlocyrilliccmb"] = 1155;
              t["tiwnarmenian"] = 1407;
              t["tlinebelow"] = 7791;
              t["tmonospace"] = 65364;
              t["toarmenian"] = 1385;
              t["tohiragana"] = 12392;
              t["tokatakana"] = 12488;
              t["tokatakanahalfwidth"] = 65412;
              t["tonebarextrahighmod"] = 741;
              t["tonebarextralowmod"] = 745;
              t["tonebarhighmod"] = 742;
              t["tonebarlowmod"] = 744;
              t["tonebarmidmod"] = 743;
              t["tonefive"] = 445;
              t["tonesix"] = 389;
              t["tonetwo"] = 424;
              t["tonos"] = 900;
              t["tonsquare"] = 13095;
              t["topatakthai"] = 3599;
              t["tortoiseshellbracketleft"] = 12308;
              t["tortoiseshellbracketleftsmall"] = 65117;
              t["tortoiseshellbracketleftvertical"] = 65081;
              t["tortoiseshellbracketright"] = 12309;
              t["tortoiseshellbracketrightsmall"] = 65118;
              t["tortoiseshellbracketrightvertical"] = 65082;
              t["totaothai"] = 3605;
              t["tpalatalhook"] = 427;
              t["tparen"] = 9391;
              t["trademark"] = 8482;
              t["trademarksans"] = 63722;
              t["trademarkserif"] = 63195;
              t["tretroflexhook"] = 648;
              t["triagdn"] = 9660;
              t["triaglf"] = 9668;
              t["triagrt"] = 9658;
              t["triagup"] = 9650;
              t["ts"] = 678;
              t["tsadi"] = 1510;
              t["tsadidagesh"] = 64326;
              t["tsadidageshhebrew"] = 64326;
              t["tsadihebrew"] = 1510;
              t["tsecyrillic"] = 1094;
              t["tsere"] = 1461;
              t["tsere12"] = 1461;
              t["tsere1e"] = 1461;
              t["tsere2b"] = 1461;
              t["tserehebrew"] = 1461;
              t["tserenarrowhebrew"] = 1461;
              t["tserequarterhebrew"] = 1461;
              t["tserewidehebrew"] = 1461;
              t["tshecyrillic"] = 1115;
              t["tsuperior"] = 63219;
              t["ttabengali"] = 2463;
              t["ttadeva"] = 2335;
              t["ttagujarati"] = 2719;
              t["ttagurmukhi"] = 2591;
              t["tteharabic"] = 1657;
              t["ttehfinalarabic"] = 64359;
              t["ttehinitialarabic"] = 64360;
              t["ttehmedialarabic"] = 64361;
              t["tthabengali"] = 2464;
              t["tthadeva"] = 2336;
              t["tthagujarati"] = 2720;
              t["tthagurmukhi"] = 2592;
              t["tturned"] = 647;
              t["tuhiragana"] = 12388;
              t["tukatakana"] = 12484;
              t["tukatakanahalfwidth"] = 65410;
              t["tusmallhiragana"] = 12387;
              t["tusmallkatakana"] = 12483;
              t["tusmallkatakanahalfwidth"] = 65391;
              t["twelvecircle"] = 9323;
              t["twelveparen"] = 9343;
              t["twelveperiod"] = 9363;
              t["twelveroman"] = 8571;
              t["twentycircle"] = 9331;
              t["twentyhangzhou"] = 21316;
              t["twentyparen"] = 9351;
              t["twentyperiod"] = 9371;
              t["two"] = 50;
              t["twoarabic"] = 1634;
              t["twobengali"] = 2536;
              t["twocircle"] = 9313;
              t["twocircleinversesansserif"] = 10123;
              t["twodeva"] = 2408;
              t["twodotenleader"] = 8229;
              t["twodotleader"] = 8229;
              t["twodotleadervertical"] = 65072;
              t["twogujarati"] = 2792;
              t["twogurmukhi"] = 2664;
              t["twohackarabic"] = 1634;
              t["twohangzhou"] = 12322;
              t["twoideographicparen"] = 12833;
              t["twoinferior"] = 8322;
              t["twomonospace"] = 65298;
              t["twonumeratorbengali"] = 2549;
              t["twooldstyle"] = 63282;
              t["twoparen"] = 9333;
              t["twoperiod"] = 9353;
              t["twopersian"] = 1778;
              t["tworoman"] = 8561;
              t["twostroke"] = 443;
              t["twosuperior"] = 178;
              t["twothai"] = 3666;
              t["twothirds"] = 8532;
              t["u"] = 117;
              t["uacute"] = 250;
              t["ubar"] = 649;
              t["ubengali"] = 2441;
              t["ubopomofo"] = 12584;
              t["ubreve"] = 365;
              t["ucaron"] = 468;
              t["ucircle"] = 9444;
              t["ucircumflex"] = 251;
              t["ucircumflexbelow"] = 7799;
              t["ucyrillic"] = 1091;
              t["udattadeva"] = 2385;
              t["udblacute"] = 369;
              t["udblgrave"] = 533;
              t["udeva"] = 2313;
              t["udieresis"] = 252;
              t["udieresisacute"] = 472;
              t["udieresisbelow"] = 7795;
              t["udieresiscaron"] = 474;
              t["udieresiscyrillic"] = 1265;
              t["udieresisgrave"] = 476;
              t["udieresismacron"] = 470;
              t["udotbelow"] = 7909;
              t["ugrave"] = 249;
              t["ugujarati"] = 2697;
              t["ugurmukhi"] = 2569;
              t["uhiragana"] = 12358;
              t["uhookabove"] = 7911;
              t["uhorn"] = 432;
              t["uhornacute"] = 7913;
              t["uhorndotbelow"] = 7921;
              t["uhorngrave"] = 7915;
              t["uhornhookabove"] = 7917;
              t["uhorntilde"] = 7919;
              t["uhungarumlaut"] = 369;
              t["uhungarumlautcyrillic"] = 1267;
              t["uinvertedbreve"] = 535;
              t["ukatakana"] = 12454;
              t["ukatakanahalfwidth"] = 65395;
              t["ukcyrillic"] = 1145;
              t["ukorean"] = 12636;
              t["umacron"] = 363;
              t["umacroncyrillic"] = 1263;
              t["umacrondieresis"] = 7803;
              t["umatragurmukhi"] = 2625;
              t["umonospace"] = 65365;
              t["underscore"] = 95;
              t["underscoredbl"] = 8215;
              t["underscoremonospace"] = 65343;
              t["underscorevertical"] = 65075;
              t["underscorewavy"] = 65103;
              t["union"] = 8746;
              t["universal"] = 8704;
              t["uogonek"] = 371;
              t["uparen"] = 9392;
              t["upblock"] = 9600;
              t["upperdothebrew"] = 1476;
              t["upsilon"] = 965;
              t["upsilondieresis"] = 971;
              t["upsilondieresistonos"] = 944;
              t["upsilonlatin"] = 650;
              t["upsilontonos"] = 973;
              t["uptackbelowcmb"] = 797;
              t["uptackmod"] = 724;
              t["uragurmukhi"] = 2675;
              t["uring"] = 367;
              t["ushortcyrillic"] = 1118;
              t["usmallhiragana"] = 12357;
              t["usmallkatakana"] = 12453;
              t["usmallkatakanahalfwidth"] = 65385;
              t["ustraightcyrillic"] = 1199;
              t["ustraightstrokecyrillic"] = 1201;
              t["utilde"] = 361;
              t["utildeacute"] = 7801;
              t["utildebelow"] = 7797;
              t["uubengali"] = 2442;
              t["uudeva"] = 2314;
              t["uugujarati"] = 2698;
              t["uugurmukhi"] = 2570;
              t["uumatragurmukhi"] = 2626;
              t["uuvowelsignbengali"] = 2498;
              t["uuvowelsigndeva"] = 2370;
              t["uuvowelsigngujarati"] = 2754;
              t["uvowelsignbengali"] = 2497;
              t["uvowelsigndeva"] = 2369;
              t["uvowelsigngujarati"] = 2753;
              t["v"] = 118;
              t["vadeva"] = 2357;
              t["vagujarati"] = 2741;
              t["vagurmukhi"] = 2613;
              t["vakatakana"] = 12535;
              t["vav"] = 1493;
              t["vavdagesh"] = 64309;
              t["vavdagesh65"] = 64309;
              t["vavdageshhebrew"] = 64309;
              t["vavhebrew"] = 1493;
              t["vavholam"] = 64331;
              t["vavholamhebrew"] = 64331;
              t["vavvavhebrew"] = 1520;
              t["vavyodhebrew"] = 1521;
              t["vcircle"] = 9445;
              t["vdotbelow"] = 7807;
              t["vecyrillic"] = 1074;
              t["veharabic"] = 1700;
              t["vehfinalarabic"] = 64363;
              t["vehinitialarabic"] = 64364;
              t["vehmedialarabic"] = 64365;
              t["vekatakana"] = 12537;
              t["venus"] = 9792;
              t["verticalbar"] = 124;
              t["verticallineabovecmb"] = 781;
              t["verticallinebelowcmb"] = 809;
              t["verticallinelowmod"] = 716;
              t["verticallinemod"] = 712;
              t["vewarmenian"] = 1406;
              t["vhook"] = 651;
              t["vikatakana"] = 12536;
              t["viramabengali"] = 2509;
              t["viramadeva"] = 2381;
              t["viramagujarati"] = 2765;
              t["visargabengali"] = 2435;
              t["visargadeva"] = 2307;
              t["visargagujarati"] = 2691;
              t["vmonospace"] = 65366;
              t["voarmenian"] = 1400;
              t["voicediterationhiragana"] = 12446;
              t["voicediterationkatakana"] = 12542;
              t["voicedmarkkana"] = 12443;
              t["voicedmarkkanahalfwidth"] = 65438;
              t["vokatakana"] = 12538;
              t["vparen"] = 9393;
              t["vtilde"] = 7805;
              t["vturned"] = 652;
              t["vuhiragana"] = 12436;
              t["vukatakana"] = 12532;
              t["w"] = 119;
              t["wacute"] = 7811;
              t["waekorean"] = 12633;
              t["wahiragana"] = 12431;
              t["wakatakana"] = 12527;
              t["wakatakanahalfwidth"] = 65436;
              t["wakorean"] = 12632;
              t["wasmallhiragana"] = 12430;
              t["wasmallkatakana"] = 12526;
              t["wattosquare"] = 13143;
              t["wavedash"] = 12316;
              t["wavyunderscorevertical"] = 65076;
              t["wawarabic"] = 1608;
              t["wawfinalarabic"] = 65262;
              t["wawhamzaabovearabic"] = 1572;
              t["wawhamzaabovefinalarabic"] = 65158;
              t["wbsquare"] = 13277;
              t["wcircle"] = 9446;
              t["wcircumflex"] = 373;
              t["wdieresis"] = 7813;
              t["wdotaccent"] = 7815;
              t["wdotbelow"] = 7817;
              t["wehiragana"] = 12433;
              t["weierstrass"] = 8472;
              t["wekatakana"] = 12529;
              t["wekorean"] = 12638;
              t["weokorean"] = 12637;
              t["wgrave"] = 7809;
              t["whitebullet"] = 9702;
              t["whitecircle"] = 9675;
              t["whitecircleinverse"] = 9689;
              t["whitecornerbracketleft"] = 12302;
              t["whitecornerbracketleftvertical"] = 65091;
              t["whitecornerbracketright"] = 12303;
              t["whitecornerbracketrightvertical"] = 65092;
              t["whitediamond"] = 9671;
              t["whitediamondcontainingblacksmalldiamond"] = 9672;
              t["whitedownpointingsmalltriangle"] = 9663;
              t["whitedownpointingtriangle"] = 9661;
              t["whiteleftpointingsmalltriangle"] = 9667;
              t["whiteleftpointingtriangle"] = 9665;
              t["whitelenticularbracketleft"] = 12310;
              t["whitelenticularbracketright"] = 12311;
              t["whiterightpointingsmalltriangle"] = 9657;
              t["whiterightpointingtriangle"] = 9655;
              t["whitesmallsquare"] = 9643;
              t["whitesmilingface"] = 9786;
              t["whitesquare"] = 9633;
              t["whitestar"] = 9734;
              t["whitetelephone"] = 9743;
              t["whitetortoiseshellbracketleft"] = 12312;
              t["whitetortoiseshellbracketright"] = 12313;
              t["whiteuppointingsmalltriangle"] = 9653;
              t["whiteuppointingtriangle"] = 9651;
              t["wihiragana"] = 12432;
              t["wikatakana"] = 12528;
              t["wikorean"] = 12639;
              t["wmonospace"] = 65367;
              t["wohiragana"] = 12434;
              t["wokatakana"] = 12530;
              t["wokatakanahalfwidth"] = 65382;
              t["won"] = 8361;
              t["wonmonospace"] = 65510;
              t["wowaenthai"] = 3623;
              t["wparen"] = 9394;
              t["wring"] = 7832;
              t["wsuperior"] = 695;
              t["wturned"] = 653;
              t["wynn"] = 447;
              t["x"] = 120;
              t["xabovecmb"] = 829;
              t["xbopomofo"] = 12562;
              t["xcircle"] = 9447;
              t["xdieresis"] = 7821;
              t["xdotaccent"] = 7819;
              t["xeharmenian"] = 1389;
              t["xi"] = 958;
              t["xmonospace"] = 65368;
              t["xparen"] = 9395;
              t["xsuperior"] = 739;
              t["y"] = 121;
              t["yaadosquare"] = 13134;
              t["yabengali"] = 2479;
              t["yacute"] = 253;
              t["yadeva"] = 2351;
              t["yaekorean"] = 12626;
              t["yagujarati"] = 2735;
              t["yagurmukhi"] = 2607;
              t["yahiragana"] = 12420;
              t["yakatakana"] = 12516;
              t["yakatakanahalfwidth"] = 65428;
              t["yakorean"] = 12625;
              t["yamakkanthai"] = 3662;
              t["yasmallhiragana"] = 12419;
              t["yasmallkatakana"] = 12515;
              t["yasmallkatakanahalfwidth"] = 65388;
              t["yatcyrillic"] = 1123;
              t["ycircle"] = 9448;
              t["ycircumflex"] = 375;
              t["ydieresis"] = 255;
              t["ydotaccent"] = 7823;
              t["ydotbelow"] = 7925;
              t["yeharabic"] = 1610;
              t["yehbarreearabic"] = 1746;
              t["yehbarreefinalarabic"] = 64431;
              t["yehfinalarabic"] = 65266;
              t["yehhamzaabovearabic"] = 1574;
              t["yehhamzaabovefinalarabic"] = 65162;
              t["yehhamzaaboveinitialarabic"] = 65163;
              t["yehhamzaabovemedialarabic"] = 65164;
              t["yehinitialarabic"] = 65267;
              t["yehmedialarabic"] = 65268;
              t["yehmeeminitialarabic"] = 64733;
              t["yehmeemisolatedarabic"] = 64600;
              t["yehnoonfinalarabic"] = 64660;
              t["yehthreedotsbelowarabic"] = 1745;
              t["yekorean"] = 12630;
              t["yen"] = 165;
              t["yenmonospace"] = 65509;
              t["yeokorean"] = 12629;
              t["yeorinhieuhkorean"] = 12678;
              t["yerahbenyomohebrew"] = 1450;
              t["yerahbenyomolefthebrew"] = 1450;
              t["yericyrillic"] = 1099;
              t["yerudieresiscyrillic"] = 1273;
              t["yesieungkorean"] = 12673;
              t["yesieungpansioskorean"] = 12675;
              t["yesieungsioskorean"] = 12674;
              t["yetivhebrew"] = 1434;
              t["ygrave"] = 7923;
              t["yhook"] = 436;
              t["yhookabove"] = 7927;
              t["yiarmenian"] = 1397;
              t["yicyrillic"] = 1111;
              t["yikorean"] = 12642;
              t["yinyang"] = 9775;
              t["yiwnarmenian"] = 1410;
              t["ymonospace"] = 65369;
              t["yod"] = 1497;
              t["yoddagesh"] = 64313;
              t["yoddageshhebrew"] = 64313;
              t["yodhebrew"] = 1497;
              t["yodyodhebrew"] = 1522;
              t["yodyodpatahhebrew"] = 64287;
              t["yohiragana"] = 12424;
              t["yoikorean"] = 12681;
              t["yokatakana"] = 12520;
              t["yokatakanahalfwidth"] = 65430;
              t["yokorean"] = 12635;
              t["yosmallhiragana"] = 12423;
              t["yosmallkatakana"] = 12519;
              t["yosmallkatakanahalfwidth"] = 65390;
              t["yotgreek"] = 1011;
              t["yoyaekorean"] = 12680;
              t["yoyakorean"] = 12679;
              t["yoyakthai"] = 3618;
              t["yoyingthai"] = 3597;
              t["yparen"] = 9396;
              t["ypogegrammeni"] = 890;
              t["ypogegrammenigreekcmb"] = 837;
              t["yr"] = 422;
              t["yring"] = 7833;
              t["ysuperior"] = 696;
              t["ytilde"] = 7929;
              t["yturned"] = 654;
              t["yuhiragana"] = 12422;
              t["yuikorean"] = 12684;
              t["yukatakana"] = 12518;
              t["yukatakanahalfwidth"] = 65429;
              t["yukorean"] = 12640;
              t["yusbigcyrillic"] = 1131;
              t["yusbigiotifiedcyrillic"] = 1133;
              t["yuslittlecyrillic"] = 1127;
              t["yuslittleiotifiedcyrillic"] = 1129;
              t["yusmallhiragana"] = 12421;
              t["yusmallkatakana"] = 12517;
              t["yusmallkatakanahalfwidth"] = 65389;
              t["yuyekorean"] = 12683;
              t["yuyeokorean"] = 12682;
              t["yyabengali"] = 2527;
              t["yyadeva"] = 2399;
              t["z"] = 122;
              t["zaarmenian"] = 1382;
              t["zacute"] = 378;
              t["zadeva"] = 2395;
              t["zagurmukhi"] = 2651;
              t["zaharabic"] = 1592;
              t["zahfinalarabic"] = 65222;
              t["zahinitialarabic"] = 65223;
              t["zahiragana"] = 12374;
              t["zahmedialarabic"] = 65224;
              t["zainarabic"] = 1586;
              t["zainfinalarabic"] = 65200;
              t["zakatakana"] = 12470;
              t["zaqefgadolhebrew"] = 1429;
              t["zaqefqatanhebrew"] = 1428;
              t["zarqahebrew"] = 1432;
              t["zayin"] = 1494;
              t["zayindagesh"] = 64310;
              t["zayindageshhebrew"] = 64310;
              t["zayinhebrew"] = 1494;
              t["zbopomofo"] = 12567;
              t["zcaron"] = 382;
              t["zcircle"] = 9449;
              t["zcircumflex"] = 7825;
              t["zcurl"] = 657;
              t["zdot"] = 380;
              t["zdotaccent"] = 380;
              t["zdotbelow"] = 7827;
              t["zecyrillic"] = 1079;
              t["zedescendercyrillic"] = 1177;
              t["zedieresiscyrillic"] = 1247;
              t["zehiragana"] = 12380;
              t["zekatakana"] = 12476;
              t["zero"] = 48;
              t["zeroarabic"] = 1632;
              t["zerobengali"] = 2534;
              t["zerodeva"] = 2406;
              t["zerogujarati"] = 2790;
              t["zerogurmukhi"] = 2662;
              t["zerohackarabic"] = 1632;
              t["zeroinferior"] = 8320;
              t["zeromonospace"] = 65296;
              t["zerooldstyle"] = 63280;
              t["zeropersian"] = 1776;
              t["zerosuperior"] = 8304;
              t["zerothai"] = 3664;
              t["zerowidthjoiner"] = 65279;
              t["zerowidthnonjoiner"] = 8204;
              t["zerowidthspace"] = 8203;
              t["zeta"] = 950;
              t["zhbopomofo"] = 12563;
              t["zhearmenian"] = 1386;
              t["zhebrevecyrillic"] = 1218;
              t["zhecyrillic"] = 1078;
              t["zhedescendercyrillic"] = 1175;
              t["zhedieresiscyrillic"] = 1245;
              t["zihiragana"] = 12376;
              t["zikatakana"] = 12472;
              t["zinorhebrew"] = 1454;
              t["zlinebelow"] = 7829;
              t["zmonospace"] = 65370;
              t["zohiragana"] = 12382;
              t["zokatakana"] = 12478;
              t["zparen"] = 9397;
              t["zretroflexhook"] = 656;
              t["zstroke"] = 438;
              t["zuhiragana"] = 12378;
              t["zukatakana"] = 12474;
              t[".notdef"] = 0;
              t["angbracketleftbig"] = 9001;
              t["angbracketleftBig"] = 9001;
              t["angbracketleftbigg"] = 9001;
              t["angbracketleftBigg"] = 9001;
              t["angbracketrightBig"] = 9002;
              t["angbracketrightbig"] = 9002;
              t["angbracketrightBigg"] = 9002;
              t["angbracketrightbigg"] = 9002;
              t["arrowhookleft"] = 8618;
              t["arrowhookright"] = 8617;
              t["arrowlefttophalf"] = 8636;
              t["arrowleftbothalf"] = 8637;
              t["arrownortheast"] = 8599;
              t["arrownorthwest"] = 8598;
              t["arrowrighttophalf"] = 8640;
              t["arrowrightbothalf"] = 8641;
              t["arrowsoutheast"] = 8600;
              t["arrowsouthwest"] = 8601;
              t["backslashbig"] = 8726;
              t["backslashBig"] = 8726;
              t["backslashBigg"] = 8726;
              t["backslashbigg"] = 8726;
              t["bardbl"] = 8214;
              t["bracehtipdownleft"] = 65079;
              t["bracehtipdownright"] = 65079;
              t["bracehtipupleft"] = 65080;
              t["bracehtipupright"] = 65080;
              t["braceleftBig"] = 123;
              t["braceleftbig"] = 123;
              t["braceleftbigg"] = 123;
              t["braceleftBigg"] = 123;
              t["bracerightBig"] = 125;
              t["bracerightbig"] = 125;
              t["bracerightbigg"] = 125;
              t["bracerightBigg"] = 125;
              t["bracketleftbig"] = 91;
              t["bracketleftBig"] = 91;
              t["bracketleftbigg"] = 91;
              t["bracketleftBigg"] = 91;
              t["bracketrightBig"] = 93;
              t["bracketrightbig"] = 93;
              t["bracketrightbigg"] = 93;
              t["bracketrightBigg"] = 93;
              t["ceilingleftbig"] = 8968;
              t["ceilingleftBig"] = 8968;
              t["ceilingleftBigg"] = 8968;
              t["ceilingleftbigg"] = 8968;
              t["ceilingrightbig"] = 8969;
              t["ceilingrightBig"] = 8969;
              t["ceilingrightbigg"] = 8969;
              t["ceilingrightBigg"] = 8969;
              t["circledotdisplay"] = 8857;
              t["circledottext"] = 8857;
              t["circlemultiplydisplay"] = 8855;
              t["circlemultiplytext"] = 8855;
              t["circleplusdisplay"] = 8853;
              t["circleplustext"] = 8853;
              t["contintegraldisplay"] = 8750;
              t["contintegraltext"] = 8750;
              t["coproductdisplay"] = 8720;
              t["coproducttext"] = 8720;
              t["floorleftBig"] = 8970;
              t["floorleftbig"] = 8970;
              t["floorleftbigg"] = 8970;
              t["floorleftBigg"] = 8970;
              t["floorrightbig"] = 8971;
              t["floorrightBig"] = 8971;
              t["floorrightBigg"] = 8971;
              t["floorrightbigg"] = 8971;
              t["hatwide"] = 770;
              t["hatwider"] = 770;
              t["hatwidest"] = 770;
              t["intercal"] = 7488;
              t["integraldisplay"] = 8747;
              t["integraltext"] = 8747;
              t["intersectiondisplay"] = 8898;
              t["intersectiontext"] = 8898;
              t["logicalanddisplay"] = 8743;
              t["logicalandtext"] = 8743;
              t["logicalordisplay"] = 8744;
              t["logicalortext"] = 8744;
              t["parenleftBig"] = 40;
              t["parenleftbig"] = 40;
              t["parenleftBigg"] = 40;
              t["parenleftbigg"] = 40;
              t["parenrightBig"] = 41;
              t["parenrightbig"] = 41;
              t["parenrightBigg"] = 41;
              t["parenrightbigg"] = 41;
              t["prime"] = 8242;
              t["productdisplay"] = 8719;
              t["producttext"] = 8719;
              t["radicalbig"] = 8730;
              t["radicalBig"] = 8730;
              t["radicalBigg"] = 8730;
              t["radicalbigg"] = 8730;
              t["radicalbt"] = 8730;
              t["radicaltp"] = 8730;
              t["radicalvertex"] = 8730;
              t["slashbig"] = 47;
              t["slashBig"] = 47;
              t["slashBigg"] = 47;
              t["slashbigg"] = 47;
              t["summationdisplay"] = 8721;
              t["summationtext"] = 8721;
              t["tildewide"] = 732;
              t["tildewider"] = 732;
              t["tildewidest"] = 732;
              t["uniondisplay"] = 8899;
              t["unionmultidisplay"] = 8846;
              t["unionmultitext"] = 8846;
              t["unionsqdisplay"] = 8852;
              t["unionsqtext"] = 8852;
              t["uniontext"] = 8899;
              t["vextenddouble"] = 8741;
              t["vextendsingle"] = 8739;
            });
            var getDingbatsGlyphsUnicode = getLookupTableFactory(function(t) {
              t["space"] = 32;
              t["a1"] = 9985;
              t["a2"] = 9986;
              t["a202"] = 9987;
              t["a3"] = 9988;
              t["a4"] = 9742;
              t["a5"] = 9990;
              t["a119"] = 9991;
              t["a118"] = 9992;
              t["a117"] = 9993;
              t["a11"] = 9755;
              t["a12"] = 9758;
              t["a13"] = 9996;
              t["a14"] = 9997;
              t["a15"] = 9998;
              t["a16"] = 9999;
              t["a105"] = 1e4;
              t["a17"] = 10001;
              t["a18"] = 10002;
              t["a19"] = 10003;
              t["a20"] = 10004;
              t["a21"] = 10005;
              t["a22"] = 10006;
              t["a23"] = 10007;
              t["a24"] = 10008;
              t["a25"] = 10009;
              t["a26"] = 10010;
              t["a27"] = 10011;
              t["a28"] = 10012;
              t["a6"] = 10013;
              t["a7"] = 10014;
              t["a8"] = 10015;
              t["a9"] = 10016;
              t["a10"] = 10017;
              t["a29"] = 10018;
              t["a30"] = 10019;
              t["a31"] = 10020;
              t["a32"] = 10021;
              t["a33"] = 10022;
              t["a34"] = 10023;
              t["a35"] = 9733;
              t["a36"] = 10025;
              t["a37"] = 10026;
              t["a38"] = 10027;
              t["a39"] = 10028;
              t["a40"] = 10029;
              t["a41"] = 10030;
              t["a42"] = 10031;
              t["a43"] = 10032;
              t["a44"] = 10033;
              t["a45"] = 10034;
              t["a46"] = 10035;
              t["a47"] = 10036;
              t["a48"] = 10037;
              t["a49"] = 10038;
              t["a50"] = 10039;
              t["a51"] = 10040;
              t["a52"] = 10041;
              t["a53"] = 10042;
              t["a54"] = 10043;
              t["a55"] = 10044;
              t["a56"] = 10045;
              t["a57"] = 10046;
              t["a58"] = 10047;
              t["a59"] = 10048;
              t["a60"] = 10049;
              t["a61"] = 10050;
              t["a62"] = 10051;
              t["a63"] = 10052;
              t["a64"] = 10053;
              t["a65"] = 10054;
              t["a66"] = 10055;
              t["a67"] = 10056;
              t["a68"] = 10057;
              t["a69"] = 10058;
              t["a70"] = 10059;
              t["a71"] = 9679;
              t["a72"] = 10061;
              t["a73"] = 9632;
              t["a74"] = 10063;
              t["a203"] = 10064;
              t["a75"] = 10065;
              t["a204"] = 10066;
              t["a76"] = 9650;
              t["a77"] = 9660;
              t["a78"] = 9670;
              t["a79"] = 10070;
              t["a81"] = 9687;
              t["a82"] = 10072;
              t["a83"] = 10073;
              t["a84"] = 10074;
              t["a97"] = 10075;
              t["a98"] = 10076;
              t["a99"] = 10077;
              t["a100"] = 10078;
              t["a101"] = 10081;
              t["a102"] = 10082;
              t["a103"] = 10083;
              t["a104"] = 10084;
              t["a106"] = 10085;
              t["a107"] = 10086;
              t["a108"] = 10087;
              t["a112"] = 9827;
              t["a111"] = 9830;
              t["a110"] = 9829;
              t["a109"] = 9824;
              t["a120"] = 9312;
              t["a121"] = 9313;
              t["a122"] = 9314;
              t["a123"] = 9315;
              t["a124"] = 9316;
              t["a125"] = 9317;
              t["a126"] = 9318;
              t["a127"] = 9319;
              t["a128"] = 9320;
              t["a129"] = 9321;
              t["a130"] = 10102;
              t["a131"] = 10103;
              t["a132"] = 10104;
              t["a133"] = 10105;
              t["a134"] = 10106;
              t["a135"] = 10107;
              t["a136"] = 10108;
              t["a137"] = 10109;
              t["a138"] = 10110;
              t["a139"] = 10111;
              t["a140"] = 10112;
              t["a141"] = 10113;
              t["a142"] = 10114;
              t["a143"] = 10115;
              t["a144"] = 10116;
              t["a145"] = 10117;
              t["a146"] = 10118;
              t["a147"] = 10119;
              t["a148"] = 10120;
              t["a149"] = 10121;
              t["a150"] = 10122;
              t["a151"] = 10123;
              t["a152"] = 10124;
              t["a153"] = 10125;
              t["a154"] = 10126;
              t["a155"] = 10127;
              t["a156"] = 10128;
              t["a157"] = 10129;
              t["a158"] = 10130;
              t["a159"] = 10131;
              t["a160"] = 10132;
              t["a161"] = 8594;
              t["a163"] = 8596;
              t["a164"] = 8597;
              t["a196"] = 10136;
              t["a165"] = 10137;
              t["a192"] = 10138;
              t["a166"] = 10139;
              t["a167"] = 10140;
              t["a168"] = 10141;
              t["a169"] = 10142;
              t["a170"] = 10143;
              t["a171"] = 10144;
              t["a172"] = 10145;
              t["a173"] = 10146;
              t["a162"] = 10147;
              t["a174"] = 10148;
              t["a175"] = 10149;
              t["a176"] = 10150;
              t["a177"] = 10151;
              t["a178"] = 10152;
              t["a179"] = 10153;
              t["a193"] = 10154;
              t["a180"] = 10155;
              t["a199"] = 10156;
              t["a181"] = 10157;
              t["a200"] = 10158;
              t["a182"] = 10159;
              t["a201"] = 10161;
              t["a183"] = 10162;
              t["a184"] = 10163;
              t["a197"] = 10164;
              t["a185"] = 10165;
              t["a194"] = 10166;
              t["a198"] = 10167;
              t["a186"] = 10168;
              t["a195"] = 10169;
              t["a187"] = 10170;
              t["a188"] = 10171;
              t["a189"] = 10172;
              t["a190"] = 10173;
              t["a191"] = 10174;
              t["a89"] = 10088;
              t["a90"] = 10089;
              t["a93"] = 10090;
              t["a94"] = 10091;
              t["a91"] = 10092;
              t["a92"] = 10093;
              t["a205"] = 10094;
              t["a85"] = 10095;
              t["a206"] = 10096;
              t["a86"] = 10097;
              t["a87"] = 10098;
              t["a88"] = 10099;
              t["a95"] = 10100;
              t["a96"] = 10101;
              t[".notdef"] = 0;
            });
            exports2.getGlyphsUnicode = getGlyphsUnicode;
            exports2.getDingbatsGlyphsUnicode = getDingbatsGlyphsUnicode;
          },
          /* 48 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = !__w_pdfjs_require__(10) && !__w_pdfjs_require__(11)(function() {
              return Object.defineProperty(__w_pdfjs_require__(35)("div"), "a", {
                get: function get() {
                  return 7;
                }
              }).a != 7;
            });
          },
          /* 49 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(1);
            var hide = __w_pdfjs_require__(8);
            var uid = __w_pdfjs_require__(17);
            var TYPED = uid("typed_array");
            var VIEW = uid("view");
            var ABV = !!(global2.ArrayBuffer && global2.DataView);
            var CONSTR = ABV;
            var i = 0;
            var l = 9;
            var Typed;
            var TypedArrayConstructors = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");
            while (i < l) {
              if (Typed = global2[TypedArrayConstructors[i++]]) {
                hide(Typed.prototype, TYPED, true);
                hide(Typed.prototype, VIEW, true);
              } else CONSTR = false;
            }
            module2.exports = {
              ABV,
              CONSTR,
              TYPED,
              VIEW
            };
          },
          /* 50 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var toInteger = __w_pdfjs_require__(18);
            var toLength = __w_pdfjs_require__(14);
            module2.exports = function(it) {
              if (it === void 0) return 0;
              var number = toInteger(it);
              var length = toLength(number);
              if (number !== length) throw RangeError("Wrong length!");
              return length;
            };
          },
          /* 51 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var $keys = __w_pdfjs_require__(52);
            var hiddenKeys = __w_pdfjs_require__(40).concat("length", "prototype");
            exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
              return $keys(O, hiddenKeys);
            };
          },
          /* 52 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var has = __w_pdfjs_require__(12);
            var toIObject = __w_pdfjs_require__(30);
            var arrayIndexOf = __w_pdfjs_require__(53)(false);
            var IE_PROTO = __w_pdfjs_require__(39)("IE_PROTO");
            module2.exports = function(object, names) {
              var O = toIObject(object);
              var i = 0;
              var result = [];
              var key;
              for (key in O) {
                if (key != IE_PROTO) has(O, key) && result.push(key);
              }
              while (names.length > i) {
                if (has(O, key = names[i++])) {
                  ~arrayIndexOf(result, key) || result.push(key);
                }
              }
              return result;
            };
          },
          /* 53 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var toIObject = __w_pdfjs_require__(30);
            var toLength = __w_pdfjs_require__(14);
            var toAbsoluteIndex = __w_pdfjs_require__(31);
            module2.exports = function(IS_INCLUDES) {
              return function($this, el, fromIndex) {
                var O = toIObject($this);
                var length = toLength(O.length);
                var index = toAbsoluteIndex(fromIndex, length);
                var value;
                if (IS_INCLUDES && el != el) while (length > index) {
                  value = O[index++];
                  if (value != value) return true;
                }
                else for (; length > index; index++) {
                  if (IS_INCLUDES || index in O) {
                    if (O[index] === el) return IS_INCLUDES || index || 0;
                  }
                }
                return !IS_INCLUDES && -1;
              };
            };
          },
          /* 54 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var core = __w_pdfjs_require__(6);
            var global2 = __w_pdfjs_require__(1);
            var SHARED = "__core-js_shared__";
            var store = global2[SHARED] || (global2[SHARED] = {});
            (module2.exports = function(key, value) {
              return store[key] || (store[key] = value !== void 0 ? value : {});
            })("versions", []).push({
              version: core.version,
              mode: __w_pdfjs_require__(21) ? "pure" : "global",
              copyright: "© 2018 Denis Pushkarev (zloirock.ru)"
            });
          },
          /* 55 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var toObject = __w_pdfjs_require__(19);
            var toAbsoluteIndex = __w_pdfjs_require__(31);
            var toLength = __w_pdfjs_require__(14);
            module2.exports = function fill(value) {
              var O = toObject(this);
              var length = toLength(O.length);
              var aLen = arguments.length;
              var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : void 0, length);
              var end = aLen > 2 ? arguments[2] : void 0;
              var endPos = end === void 0 ? length : toAbsoluteIndex(end, length);
              while (endPos > index) {
                O[index++] = value;
              }
              return O;
            };
          },
          /* 56 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var Iterators = __w_pdfjs_require__(20);
            var ITERATOR = __w_pdfjs_require__(4)("iterator");
            var ArrayProto = Array.prototype;
            module2.exports = function(it) {
              return it !== void 0 && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
            };
          },
          /* 57 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var anObject = __w_pdfjs_require__(9);
            var dPs = __w_pdfjs_require__(90);
            var enumBugKeys = __w_pdfjs_require__(40);
            var IE_PROTO = __w_pdfjs_require__(39)("IE_PROTO");
            var Empty = function Empty2() {
            };
            var PROTOTYPE = "prototype";
            var _createDict = function createDict() {
              var iframe = __w_pdfjs_require__(35)("iframe");
              var i = enumBugKeys.length;
              var lt = "<";
              var gt = ">";
              var iframeDocument;
              iframe.style.display = "none";
              __w_pdfjs_require__(58).appendChild(iframe);
              iframe.src = "javascript:";
              iframeDocument = iframe.contentWindow.document;
              iframeDocument.open();
              iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
              iframeDocument.close();
              _createDict = iframeDocument.F;
              while (i--) {
                delete _createDict[PROTOTYPE][enumBugKeys[i]];
              }
              return _createDict();
            };
            module2.exports = Object.create || function create(O, Properties) {
              var result;
              if (O !== null) {
                Empty[PROTOTYPE] = anObject(O);
                result = new Empty();
                Empty[PROTOTYPE] = null;
                result[IE_PROTO] = O;
              } else result = _createDict();
              return Properties === void 0 ? result : dPs(result, Properties);
            };
          },
          /* 58 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var document2 = __w_pdfjs_require__(1).document;
            module2.exports = document2 && document2.documentElement;
          },
          /* 59 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var has = __w_pdfjs_require__(12);
            var toObject = __w_pdfjs_require__(19);
            var IE_PROTO = __w_pdfjs_require__(39)("IE_PROTO");
            var ObjectProto = Object.prototype;
            module2.exports = Object.getPrototypeOf || function(O) {
              O = toObject(O);
              if (has(O, IE_PROTO)) return O[IE_PROTO];
              if (typeof O.constructor == "function" && O instanceof O.constructor) {
                return O.constructor.prototype;
              }
              return O instanceof Object ? ObjectProto : null;
            };
          },
          /* 60 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var classof = __w_pdfjs_require__(32);
            var ITERATOR = __w_pdfjs_require__(4)("iterator");
            var Iterators = __w_pdfjs_require__(20);
            module2.exports = __w_pdfjs_require__(6).getIteratorMethod = function(it) {
              if (it != void 0) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
            };
          },
          /* 61 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var addToUnscopables = __w_pdfjs_require__(94);
            var step = __w_pdfjs_require__(95);
            var Iterators = __w_pdfjs_require__(20);
            var toIObject = __w_pdfjs_require__(30);
            module2.exports = __w_pdfjs_require__(62)(Array, "Array", function(iterated, kind) {
              this._t = toIObject(iterated);
              this._i = 0;
              this._k = kind;
            }, function() {
              var O = this._t;
              var kind = this._k;
              var index = this._i++;
              if (!O || index >= O.length) {
                this._t = void 0;
                return step(1);
              }
              if (kind == "keys") return step(0, index);
              if (kind == "values") return step(0, O[index]);
              return step(0, [index, O[index]]);
            }, "values");
            Iterators.Arguments = Iterators.Array;
            addToUnscopables("keys");
            addToUnscopables("values");
            addToUnscopables("entries");
          },
          /* 62 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var LIBRARY = __w_pdfjs_require__(21);
            var $export = __w_pdfjs_require__(7);
            var redefine = __w_pdfjs_require__(16);
            var hide = __w_pdfjs_require__(8);
            var Iterators = __w_pdfjs_require__(20);
            var $iterCreate = __w_pdfjs_require__(96);
            var setToStringTag = __w_pdfjs_require__(26);
            var getPrototypeOf = __w_pdfjs_require__(59);
            var ITERATOR = __w_pdfjs_require__(4)("iterator");
            var BUGGY = !([].keys && "next" in [].keys());
            var FF_ITERATOR = "@@iterator";
            var KEYS = "keys";
            var VALUES = "values";
            var returnThis = function returnThis2() {
              return this;
            };
            module2.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
              $iterCreate(Constructor, NAME, next);
              var getMethod = function getMethod2(kind) {
                if (!BUGGY && kind in proto) return proto[kind];
                switch (kind) {
                  case KEYS:
                    return function keys() {
                      return new Constructor(this, kind);
                    };
                  case VALUES:
                    return function values() {
                      return new Constructor(this, kind);
                    };
                }
                return function entries() {
                  return new Constructor(this, kind);
                };
              };
              var TAG = NAME + " Iterator";
              var DEF_VALUES = DEFAULT == VALUES;
              var VALUES_BUG = false;
              var proto = Base.prototype;
              var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
              var $default = $native || getMethod(DEFAULT);
              var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
              var $anyNative = NAME == "Array" ? proto.entries || $native : $native;
              var methods, key, IteratorPrototype;
              if ($anyNative) {
                IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
                if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
                  setToStringTag(IteratorPrototype, TAG, true);
                  if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != "function") hide(IteratorPrototype, ITERATOR, returnThis);
                }
              }
              if (DEF_VALUES && $native && $native.name !== VALUES) {
                VALUES_BUG = true;
                $default = function values() {
                  return $native.call(this);
                };
              }
              if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
                hide(proto, ITERATOR, $default);
              }
              Iterators[NAME] = $default;
              Iterators[TAG] = returnThis;
              if (DEFAULT) {
                methods = {
                  values: DEF_VALUES ? $default : getMethod(VALUES),
                  keys: IS_SET ? $default : getMethod(KEYS),
                  entries: $entries
                };
                if (FORCED) for (key in methods) {
                  if (!(key in proto)) redefine(proto, key, methods[key]);
                }
                else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
              }
              return methods;
            };
          },
          /* 63 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(1);
            var dP = __w_pdfjs_require__(15);
            var DESCRIPTORS = __w_pdfjs_require__(10);
            var SPECIES = __w_pdfjs_require__(4)("species");
            module2.exports = function(KEY) {
              var C = global2[KEY];
              if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
                configurable: true,
                get: function get() {
                  return this;
                }
              });
            };
          },
          /* 64 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var pIE = __w_pdfjs_require__(65);
            var createDesc = __w_pdfjs_require__(29);
            var toIObject = __w_pdfjs_require__(30);
            var toPrimitive = __w_pdfjs_require__(36);
            var has = __w_pdfjs_require__(12);
            var IE8_DOM_DEFINE = __w_pdfjs_require__(48);
            var gOPD = Object.getOwnPropertyDescriptor;
            exports2.f = __w_pdfjs_require__(10) ? gOPD : function getOwnPropertyDescriptor(O, P) {
              O = toIObject(O);
              P = toPrimitive(P, true);
              if (IE8_DOM_DEFINE) try {
                return gOPD(O, P);
              } catch (e) {
              }
              if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
            };
          },
          /* 65 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            exports2.f = {}.propertyIsEnumerable;
          },
          /* 66 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var classof = __w_pdfjs_require__(32);
            var test = {};
            test[__w_pdfjs_require__(4)("toStringTag")] = "z";
            if (test + "" != "[object z]") {
              __w_pdfjs_require__(16)(Object.prototype, "toString", function toString() {
                return "[object " + classof(this) + "]";
              }, true);
            }
          },
          /* 67 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var $iterators = __w_pdfjs_require__(61);
            var getKeys = __w_pdfjs_require__(41);
            var redefine = __w_pdfjs_require__(16);
            var global2 = __w_pdfjs_require__(1);
            var hide = __w_pdfjs_require__(8);
            var Iterators = __w_pdfjs_require__(20);
            var wks = __w_pdfjs_require__(4);
            var ITERATOR = wks("iterator");
            var TO_STRING_TAG = wks("toStringTag");
            var ArrayValues = Iterators.Array;
            var DOMIterables = {
              CSSRuleList: true,
              CSSStyleDeclaration: false,
              CSSValueList: false,
              ClientRectList: false,
              DOMRectList: false,
              DOMStringList: false,
              DOMTokenList: true,
              DataTransferItemList: false,
              FileList: false,
              HTMLAllCollection: false,
              HTMLCollection: false,
              HTMLFormElement: false,
              HTMLSelectElement: false,
              MediaList: true,
              MimeTypeArray: false,
              NamedNodeMap: false,
              NodeList: true,
              PaintRequestList: false,
              Plugin: false,
              PluginArray: false,
              SVGLengthList: false,
              SVGNumberList: false,
              SVGPathSegList: false,
              SVGPointList: false,
              SVGStringList: false,
              SVGTransformList: false,
              SourceBufferList: false,
              StyleSheetList: true,
              TextTrackCueList: false,
              TextTrackList: false,
              TouchList: false
            };
            for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
              var NAME = collections[i];
              var explicit = DOMIterables[NAME];
              var Collection = global2[NAME];
              var proto = Collection && Collection.prototype;
              var key;
              if (proto) {
                if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
                if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
                Iterators[NAME] = ArrayValues;
                if (explicit) for (key in $iterators) {
                  if (!proto[key]) redefine(proto, key, $iterators[key], true);
                }
              }
            }
          },
          /* 68 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var ctx = __w_pdfjs_require__(13);
            var invoke = __w_pdfjs_require__(108);
            var html = __w_pdfjs_require__(58);
            var cel = __w_pdfjs_require__(35);
            var global2 = __w_pdfjs_require__(1);
            var process2 = global2.process;
            var setTask = global2.setImmediate;
            var clearTask = global2.clearImmediate;
            var MessageChannel = global2.MessageChannel;
            var Dispatch = global2.Dispatch;
            var counter = 0;
            var queue = {};
            var ONREADYSTATECHANGE = "onreadystatechange";
            var defer, channel, port;
            var run = function run2() {
              var id = +this;
              if (queue.hasOwnProperty(id)) {
                var fn = queue[id];
                delete queue[id];
                fn();
              }
            };
            var listener = function listener2(event) {
              run.call(event.data);
            };
            if (!setTask || !clearTask) {
              setTask = function setImmediate(fn) {
                var args = [];
                var i = 1;
                while (arguments.length > i) {
                  args.push(arguments[i++]);
                }
                queue[++counter] = function() {
                  invoke(typeof fn == "function" ? fn : Function(fn), args);
                };
                defer(counter);
                return counter;
              };
              clearTask = function clearImmediate(id) {
                delete queue[id];
              };
              if (__w_pdfjs_require__(25)(process2) == "process") {
                defer = function defer2(id) {
                  process2.nextTick(ctx(run, id, 1));
                };
              } else if (Dispatch && Dispatch.now) {
                defer = function defer2(id) {
                  Dispatch.now(ctx(run, id, 1));
                };
              } else if (MessageChannel) {
                channel = new MessageChannel();
                port = channel.port2;
                channel.port1.onmessage = listener;
                defer = ctx(port.postMessage, port, 1);
              } else if (global2.addEventListener && typeof postMessage == "function" && !global2.importScripts) {
                defer = function defer2(id) {
                  global2.postMessage(id + "", "*");
                };
                global2.addEventListener("message", listener, false);
              } else if (ONREADYSTATECHANGE in cel("script")) {
                defer = function defer2(id) {
                  html.appendChild(cel("script"))[ONREADYSTATECHANGE] = function() {
                    html.removeChild(this);
                    run.call(id);
                  };
                };
              } else {
                defer = function defer2(id) {
                  setTimeout(ctx(run, id, 1), 0);
                };
              }
            }
            module2.exports = {
              set: setTask,
              clear: clearTask
            };
          },
          /* 69 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = function(exec) {
              try {
                return {
                  e: false,
                  v: exec()
                };
              } catch (e) {
                return {
                  e: true,
                  v: e
                };
              }
            };
          },
          /* 70 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var anObject = __w_pdfjs_require__(9);
            var isObject = __w_pdfjs_require__(3);
            var newPromiseCapability = __w_pdfjs_require__(45);
            module2.exports = function(C, x) {
              anObject(C);
              if (isObject(x) && x.constructor === C) return x;
              var promiseCapability = newPromiseCapability.f(C);
              var resolve = promiseCapability.resolve;
              resolve(x);
              return promiseCapability.promise;
            };
          },
          /* 71 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(3);
            module2.exports = function(it, TYPE) {
              if (!isObject(it) || it._t !== TYPE) throw TypeError("Incompatible receiver, " + TYPE + " required!");
              return it;
            };
          },
          /* 72 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.ChunkedStreamManager = exports2.ChunkedStream = void 0;
            var _util = __w_pdfjs_require__(0);
            var ChunkedStream = function ChunkedStreamClosure() {
              function ChunkedStream2(length, chunkSize, manager) {
                this.bytes = new Uint8Array(length);
                this.start = 0;
                this.pos = 0;
                this.end = length;
                this.chunkSize = chunkSize;
                this.loadedChunks = [];
                this.numChunksLoaded = 0;
                this.numChunks = Math.ceil(length / chunkSize);
                this.manager = manager;
                this.progressiveDataLength = 0;
                this.lastSuccessfulEnsureByteChunk = -1;
              }
              ChunkedStream2.prototype = {
                getMissingChunks: function ChunkedStream_getMissingChunks() {
                  var chunks = [];
                  for (var chunk = 0, n = this.numChunks; chunk < n; ++chunk) {
                    if (!this.loadedChunks[chunk]) {
                      chunks.push(chunk);
                    }
                  }
                  return chunks;
                },
                getBaseStreams: function ChunkedStream_getBaseStreams() {
                  return [this];
                },
                allChunksLoaded: function ChunkedStream_allChunksLoaded() {
                  return this.numChunksLoaded === this.numChunks;
                },
                onReceiveData: function ChunkedStream_onReceiveData(begin, chunk) {
                  var end = begin + chunk.byteLength;
                  if (begin % this.chunkSize !== 0) {
                    throw new Error("Bad begin offset: " + begin);
                  }
                  var length = this.bytes.length;
                  if (end % this.chunkSize !== 0 && end !== length) {
                    throw new Error("Bad end offset: " + end);
                  }
                  this.bytes.set(new Uint8Array(chunk), begin);
                  var chunkSize = this.chunkSize;
                  var beginChunk = Math.floor(begin / chunkSize);
                  var endChunk = Math.floor((end - 1) / chunkSize) + 1;
                  var curChunk;
                  for (curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
                    if (!this.loadedChunks[curChunk]) {
                      this.loadedChunks[curChunk] = true;
                      ++this.numChunksLoaded;
                    }
                  }
                },
                onReceiveProgressiveData: function ChunkedStream_onReceiveProgressiveData(data) {
                  var position = this.progressiveDataLength;
                  var beginChunk = Math.floor(position / this.chunkSize);
                  this.bytes.set(new Uint8Array(data), position);
                  position += data.byteLength;
                  this.progressiveDataLength = position;
                  var endChunk = position >= this.end ? this.numChunks : Math.floor(position / this.chunkSize);
                  var curChunk;
                  for (curChunk = beginChunk; curChunk < endChunk; ++curChunk) {
                    if (!this.loadedChunks[curChunk]) {
                      this.loadedChunks[curChunk] = true;
                      ++this.numChunksLoaded;
                    }
                  }
                },
                ensureByte: function ChunkedStream_ensureByte(pos) {
                  var chunk = Math.floor(pos / this.chunkSize);
                  if (chunk === this.lastSuccessfulEnsureByteChunk) {
                    return;
                  }
                  if (!this.loadedChunks[chunk]) {
                    throw new _util.MissingDataException(pos, pos + 1);
                  }
                  this.lastSuccessfulEnsureByteChunk = chunk;
                },
                ensureRange: function ChunkedStream_ensureRange(begin, end) {
                  if (begin >= end) {
                    return;
                  }
                  if (end <= this.progressiveDataLength) {
                    return;
                  }
                  var chunkSize = this.chunkSize;
                  var beginChunk = Math.floor(begin / chunkSize);
                  var endChunk = Math.floor((end - 1) / chunkSize) + 1;
                  for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                    if (!this.loadedChunks[chunk]) {
                      throw new _util.MissingDataException(begin, end);
                    }
                  }
                },
                nextEmptyChunk: function ChunkedStream_nextEmptyChunk(beginChunk) {
                  var chunk, numChunks = this.numChunks;
                  for (var i = 0; i < numChunks; ++i) {
                    chunk = (beginChunk + i) % numChunks;
                    if (!this.loadedChunks[chunk]) {
                      return chunk;
                    }
                  }
                  return null;
                },
                hasChunk: function ChunkedStream_hasChunk(chunk) {
                  return !!this.loadedChunks[chunk];
                },
                get length() {
                  return this.end - this.start;
                },
                get isEmpty() {
                  return this.length === 0;
                },
                getByte: function ChunkedStream_getByte() {
                  var pos = this.pos;
                  if (pos >= this.end) {
                    return -1;
                  }
                  this.ensureByte(pos);
                  return this.bytes[this.pos++];
                },
                getUint16: function ChunkedStream_getUint16() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  if (b0 === -1 || b1 === -1) {
                    return -1;
                  }
                  return (b0 << 8) + b1;
                },
                getInt32: function ChunkedStream_getInt32() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  var b2 = this.getByte();
                  var b3 = this.getByte();
                  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                },
                getBytes: function ChunkedStream_getBytes(length) {
                  var bytes = this.bytes;
                  var pos = this.pos;
                  var strEnd = this.end;
                  if (!length) {
                    this.ensureRange(pos, strEnd);
                    return bytes.subarray(pos, strEnd);
                  }
                  var end = pos + length;
                  if (end > strEnd) {
                    end = strEnd;
                  }
                  this.ensureRange(pos, end);
                  this.pos = end;
                  return bytes.subarray(pos, end);
                },
                peekByte: function ChunkedStream_peekByte() {
                  var peekedByte = this.getByte();
                  this.pos--;
                  return peekedByte;
                },
                peekBytes: function ChunkedStream_peekBytes(length) {
                  var bytes = this.getBytes(length);
                  this.pos -= bytes.length;
                  return bytes;
                },
                getByteRange: function ChunkedStream_getBytes(begin, end) {
                  this.ensureRange(begin, end);
                  return this.bytes.subarray(begin, end);
                },
                skip: function ChunkedStream_skip(n) {
                  if (!n) {
                    n = 1;
                  }
                  this.pos += n;
                },
                reset: function ChunkedStream_reset() {
                  this.pos = this.start;
                },
                moveStart: function ChunkedStream_moveStart() {
                  this.start = this.pos;
                },
                makeSubStream: function ChunkedStream_makeSubStream(start, length, dict) {
                  this.ensureRange(start, start + length);
                  function ChunkedStreamSubstream() {
                  }
                  ChunkedStreamSubstream.prototype = Object.create(this);
                  ChunkedStreamSubstream.prototype.getMissingChunks = function() {
                    var chunkSize = this.chunkSize;
                    var beginChunk = Math.floor(this.start / chunkSize);
                    var endChunk = Math.floor((this.end - 1) / chunkSize) + 1;
                    var missingChunks = [];
                    for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                      if (!this.loadedChunks[chunk]) {
                        missingChunks.push(chunk);
                      }
                    }
                    return missingChunks;
                  };
                  var subStream = new ChunkedStreamSubstream();
                  subStream.pos = subStream.start = start;
                  subStream.end = start + length || this.end;
                  subStream.dict = dict;
                  return subStream;
                }
              };
              return ChunkedStream2;
            }();
            var ChunkedStreamManager = function ChunkedStreamManagerClosure() {
              function ChunkedStreamManager2(pdfNetworkStream, args) {
                var chunkSize = args.rangeChunkSize;
                var length = args.length;
                this.stream = new ChunkedStream(length, chunkSize, this);
                this.length = length;
                this.chunkSize = chunkSize;
                this.pdfNetworkStream = pdfNetworkStream;
                this.url = args.url;
                this.disableAutoFetch = args.disableAutoFetch;
                this.msgHandler = args.msgHandler;
                this.currRequestId = 0;
                this.chunksNeededByRequest = /* @__PURE__ */ Object.create(null);
                this.requestsByChunk = /* @__PURE__ */ Object.create(null);
                this.promisesByRequest = /* @__PURE__ */ Object.create(null);
                this.progressiveDataLength = 0;
                this.aborted = false;
                this._loadedStreamCapability = (0, _util.createPromiseCapability)();
              }
              ChunkedStreamManager2.prototype = {
                onLoadedStream: function ChunkedStreamManager_getLoadedStream() {
                  return this._loadedStreamCapability.promise;
                },
                sendRequest: function ChunkedStreamManager_sendRequest(begin, end) {
                  var _this = this;
                  var rangeReader = this.pdfNetworkStream.getRangeReader(begin, end);
                  if (!rangeReader.isStreamingSupported) {
                    rangeReader.onProgress = this.onProgress.bind(this);
                  }
                  var chunks = [], loaded = 0;
                  var manager = this;
                  var promise = new Promise(function(resolve, reject) {
                    var readChunk = function readChunk2(chunk) {
                      try {
                        if (!chunk.done) {
                          var data = chunk.value;
                          chunks.push(data);
                          loaded += (0, _util.arrayByteLength)(data);
                          if (rangeReader.isStreamingSupported) {
                            manager.onProgress({ loaded });
                          }
                          rangeReader.read().then(readChunk2, reject);
                          return;
                        }
                        var chunkData = (0, _util.arraysToBytes)(chunks);
                        chunks = null;
                        resolve(chunkData);
                      } catch (e) {
                        reject(e);
                      }
                    };
                    rangeReader.read().then(readChunk, reject);
                  });
                  promise.then(function(data) {
                    if (_this.aborted) {
                      return;
                    }
                    _this.onReceiveData({
                      chunk: data,
                      begin
                    });
                  });
                },
                requestAllChunks: function ChunkedStreamManager_requestAllChunks() {
                  var missingChunks = this.stream.getMissingChunks();
                  this._requestChunks(missingChunks);
                  return this._loadedStreamCapability.promise;
                },
                _requestChunks: function ChunkedStreamManager_requestChunks(chunks) {
                  var requestId = this.currRequestId++;
                  var i, ii;
                  var chunksNeeded = /* @__PURE__ */ Object.create(null);
                  this.chunksNeededByRequest[requestId] = chunksNeeded;
                  for (i = 0, ii = chunks.length; i < ii; i++) {
                    if (!this.stream.hasChunk(chunks[i])) {
                      chunksNeeded[chunks[i]] = true;
                    }
                  }
                  if ((0, _util.isEmptyObj)(chunksNeeded)) {
                    return Promise.resolve();
                  }
                  var capability = (0, _util.createPromiseCapability)();
                  this.promisesByRequest[requestId] = capability;
                  var chunksToRequest = [];
                  for (var chunk in chunksNeeded) {
                    chunk = chunk | 0;
                    if (!(chunk in this.requestsByChunk)) {
                      this.requestsByChunk[chunk] = [];
                      chunksToRequest.push(chunk);
                    }
                    this.requestsByChunk[chunk].push(requestId);
                  }
                  if (!chunksToRequest.length) {
                    return capability.promise;
                  }
                  var groupedChunksToRequest = this.groupChunks(chunksToRequest);
                  for (i = 0; i < groupedChunksToRequest.length; ++i) {
                    var groupedChunk = groupedChunksToRequest[i];
                    var begin = groupedChunk.beginChunk * this.chunkSize;
                    var end = Math.min(groupedChunk.endChunk * this.chunkSize, this.length);
                    this.sendRequest(begin, end);
                  }
                  return capability.promise;
                },
                getStream: function ChunkedStreamManager_getStream() {
                  return this.stream;
                },
                requestRange: function ChunkedStreamManager_requestRange(begin, end) {
                  end = Math.min(end, this.length);
                  var beginChunk = this.getBeginChunk(begin);
                  var endChunk = this.getEndChunk(end);
                  var chunks = [];
                  for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                    chunks.push(chunk);
                  }
                  return this._requestChunks(chunks);
                },
                requestRanges: function ChunkedStreamManager_requestRanges(ranges) {
                  ranges = ranges || [];
                  var chunksToRequest = [];
                  for (var i = 0; i < ranges.length; i++) {
                    var beginChunk = this.getBeginChunk(ranges[i].begin);
                    var endChunk = this.getEndChunk(ranges[i].end);
                    for (var chunk = beginChunk; chunk < endChunk; ++chunk) {
                      if (chunksToRequest.indexOf(chunk) < 0) {
                        chunksToRequest.push(chunk);
                      }
                    }
                  }
                  chunksToRequest.sort(function(a, b) {
                    return a - b;
                  });
                  return this._requestChunks(chunksToRequest);
                },
                groupChunks: function ChunkedStreamManager_groupChunks(chunks) {
                  var groupedChunks = [];
                  var beginChunk = -1;
                  var prevChunk = -1;
                  for (var i = 0; i < chunks.length; ++i) {
                    var chunk = chunks[i];
                    if (beginChunk < 0) {
                      beginChunk = chunk;
                    }
                    if (prevChunk >= 0 && prevChunk + 1 !== chunk) {
                      groupedChunks.push({
                        beginChunk,
                        endChunk: prevChunk + 1
                      });
                      beginChunk = chunk;
                    }
                    if (i + 1 === chunks.length) {
                      groupedChunks.push({
                        beginChunk,
                        endChunk: chunk + 1
                      });
                    }
                    prevChunk = chunk;
                  }
                  return groupedChunks;
                },
                onProgress: function ChunkedStreamManager_onProgress(args) {
                  var bytesLoaded = this.stream.numChunksLoaded * this.chunkSize + args.loaded;
                  this.msgHandler.send("DocProgress", {
                    loaded: bytesLoaded,
                    total: this.length
                  });
                },
                onReceiveData: function ChunkedStreamManager_onReceiveData(args) {
                  var chunk = args.chunk;
                  var isProgressive = args.begin === void 0;
                  var begin = isProgressive ? this.progressiveDataLength : args.begin;
                  var end = begin + chunk.byteLength;
                  var beginChunk = Math.floor(begin / this.chunkSize);
                  var endChunk = end < this.length ? Math.floor(end / this.chunkSize) : Math.ceil(end / this.chunkSize);
                  if (isProgressive) {
                    this.stream.onReceiveProgressiveData(chunk);
                    this.progressiveDataLength = end;
                  } else {
                    this.stream.onReceiveData(begin, chunk);
                  }
                  if (this.stream.allChunksLoaded()) {
                    this._loadedStreamCapability.resolve(this.stream);
                  }
                  var loadedRequests = [];
                  var i, requestId;
                  for (chunk = beginChunk; chunk < endChunk; ++chunk) {
                    var requestIds = this.requestsByChunk[chunk] || [];
                    delete this.requestsByChunk[chunk];
                    for (i = 0; i < requestIds.length; ++i) {
                      requestId = requestIds[i];
                      var chunksNeeded = this.chunksNeededByRequest[requestId];
                      if (chunk in chunksNeeded) {
                        delete chunksNeeded[chunk];
                      }
                      if (!(0, _util.isEmptyObj)(chunksNeeded)) {
                        continue;
                      }
                      loadedRequests.push(requestId);
                    }
                  }
                  if (!this.disableAutoFetch && (0, _util.isEmptyObj)(this.requestsByChunk)) {
                    var nextEmptyChunk;
                    if (this.stream.numChunksLoaded === 1) {
                      var lastChunk = this.stream.numChunks - 1;
                      if (!this.stream.hasChunk(lastChunk)) {
                        nextEmptyChunk = lastChunk;
                      }
                    } else {
                      nextEmptyChunk = this.stream.nextEmptyChunk(endChunk);
                    }
                    if (Number.isInteger(nextEmptyChunk)) {
                      this._requestChunks([nextEmptyChunk]);
                    }
                  }
                  for (i = 0; i < loadedRequests.length; ++i) {
                    requestId = loadedRequests[i];
                    var capability = this.promisesByRequest[requestId];
                    delete this.promisesByRequest[requestId];
                    capability.resolve();
                  }
                  this.msgHandler.send("DocProgress", {
                    loaded: this.stream.numChunksLoaded * this.chunkSize,
                    total: this.length
                  });
                },
                onError: function ChunkedStreamManager_onError(err) {
                  this._loadedStreamCapability.reject(err);
                },
                getBeginChunk: function ChunkedStreamManager_getBeginChunk(begin) {
                  var chunk = Math.floor(begin / this.chunkSize);
                  return chunk;
                },
                getEndChunk: function ChunkedStreamManager_getEndChunk(end) {
                  var chunk = Math.floor((end - 1) / this.chunkSize) + 1;
                  return chunk;
                },
                abort: function ChunkedStreamManager_abort() {
                  this.aborted = true;
                  if (this.pdfNetworkStream) {
                    this.pdfNetworkStream.cancelAllRequests("abort");
                  }
                  for (var requestId in this.promisesByRequest) {
                    var capability = this.promisesByRequest[requestId];
                    capability.reject(new Error("Request was aborted"));
                  }
                }
              };
              return ChunkedStreamManager2;
            }();
            exports2.ChunkedStream = ChunkedStream;
            exports2.ChunkedStreamManager = ChunkedStreamManager;
          },
          /* 73 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.FileSpec = exports2.XRef = exports2.ObjectLoader = exports2.Catalog = void 0;
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var _slicedToArray = /* @__PURE__ */ function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = void 0;
                try {
                  for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i["return"]) _i["return"]();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
              };
            }();
            var _util = __w_pdfjs_require__(0);
            var _primitives = __w_pdfjs_require__(2);
            var _parser = __w_pdfjs_require__(34);
            var _chunked_stream = __w_pdfjs_require__(72);
            var _crypto = __w_pdfjs_require__(76);
            var _colorspace = __w_pdfjs_require__(27);
            var Catalog = function CatalogClosure() {
              function Catalog2(pdfManager, xref, pageFactory) {
                this.pdfManager = pdfManager;
                this.xref = xref;
                this.catDict = xref.getCatalogObj();
                if (!(0, _primitives.isDict)(this.catDict)) {
                  throw new _util.FormatError("catalog object is not a dictionary");
                }
                this.fontCache = new _primitives.RefSetCache();
                this.builtInCMapCache = /* @__PURE__ */ Object.create(null);
                this.pageKidsCountCache = new _primitives.RefSetCache();
                this.pageFactory = pageFactory;
                this.pagePromises = [];
              }
              Catalog2.prototype = {
                get metadata() {
                  var streamRef = this.catDict.getRaw("Metadata");
                  if (!(0, _primitives.isRef)(streamRef)) {
                    return (0, _util.shadow)(this, "metadata", null);
                  }
                  var encryptMetadata = !this.xref.encrypt ? false : this.xref.encrypt.encryptMetadata;
                  var stream = this.xref.fetch(streamRef, !encryptMetadata);
                  var metadata;
                  if (stream && (0, _primitives.isDict)(stream.dict)) {
                    var type = stream.dict.get("Type");
                    var subtype = stream.dict.get("Subtype");
                    if ((0, _primitives.isName)(type, "Metadata") && (0, _primitives.isName)(subtype, "XML")) {
                      try {
                        metadata = (0, _util.stringToUTF8String)((0, _util.bytesToString)(stream.getBytes()));
                      } catch (e) {
                        if (e instanceof _util.MissingDataException) {
                          throw e;
                        }
                        (0, _util.info)("Skipping invalid metadata.");
                      }
                    }
                  }
                  return (0, _util.shadow)(this, "metadata", metadata);
                },
                get toplevelPagesDict() {
                  var pagesObj = this.catDict.get("Pages");
                  if (!(0, _primitives.isDict)(pagesObj)) {
                    throw new _util.FormatError("invalid top-level pages dictionary");
                  }
                  return (0, _util.shadow)(this, "toplevelPagesDict", pagesObj);
                },
                get documentOutline() {
                  var obj = null;
                  try {
                    obj = this.readDocumentOutline();
                  } catch (ex) {
                    if (ex instanceof _util.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)("Unable to read document outline");
                  }
                  return (0, _util.shadow)(this, "documentOutline", obj);
                },
                readDocumentOutline: function Catalog_readDocumentOutline() {
                  var obj = this.catDict.get("Outlines");
                  if (!(0, _primitives.isDict)(obj)) {
                    return null;
                  }
                  obj = obj.getRaw("First");
                  if (!(0, _primitives.isRef)(obj)) {
                    return null;
                  }
                  var root = { items: [] };
                  var queue = [{
                    obj,
                    parent: root
                  }];
                  var processed = new _primitives.RefSet();
                  processed.put(obj);
                  var xref = this.xref, blackColor = new Uint8Array(3);
                  while (queue.length > 0) {
                    var i = queue.shift();
                    var outlineDict = xref.fetchIfRef(i.obj);
                    if (outlineDict === null) {
                      continue;
                    }
                    if (!outlineDict.has("Title")) {
                      throw new _util.FormatError("Invalid outline item");
                    }
                    var data = {
                      url: null,
                      dest: null
                    };
                    Catalog2.parseDestDictionary({
                      destDict: outlineDict,
                      resultObj: data,
                      docBaseUrl: this.pdfManager.docBaseUrl
                    });
                    var title = outlineDict.get("Title");
                    var flags = outlineDict.get("F") || 0;
                    var color = outlineDict.getArray("C"), rgbColor = blackColor;
                    if (Array.isArray(color) && color.length === 3 && (color[0] !== 0 || color[1] !== 0 || color[2] !== 0)) {
                      rgbColor = _colorspace.ColorSpace.singletons.rgb.getRgb(color, 0);
                    }
                    var outlineItem = {
                      dest: data.dest,
                      url: data.url,
                      unsafeUrl: data.unsafeUrl,
                      newWindow: data.newWindow,
                      title: (0, _util.stringToPDFString)(title),
                      color: rgbColor,
                      count: outlineDict.get("Count"),
                      bold: !!(flags & 2),
                      italic: !!(flags & 1),
                      items: []
                    };
                    i.parent.items.push(outlineItem);
                    obj = outlineDict.getRaw("First");
                    if ((0, _primitives.isRef)(obj) && !processed.has(obj)) {
                      queue.push({
                        obj,
                        parent: outlineItem
                      });
                      processed.put(obj);
                    }
                    obj = outlineDict.getRaw("Next");
                    if ((0, _primitives.isRef)(obj) && !processed.has(obj)) {
                      queue.push({
                        obj,
                        parent: i.parent
                      });
                      processed.put(obj);
                    }
                  }
                  return root.items.length > 0 ? root.items : null;
                },
                get numPages() {
                  var obj = this.toplevelPagesDict.get("Count");
                  if (!Number.isInteger(obj)) {
                    throw new _util.FormatError("page count in top level pages object is not an integer");
                  }
                  return (0, _util.shadow)(this, "numPages", obj);
                },
                get destinations() {
                  function fetchDestination(dest) {
                    return (0, _primitives.isDict)(dest) ? dest.get("D") : dest;
                  }
                  var xref = this.xref;
                  var dests = {}, nameTreeRef, nameDictionaryRef;
                  var obj = this.catDict.get("Names");
                  if (obj && obj.has("Dests")) {
                    nameTreeRef = obj.getRaw("Dests");
                  } else if (this.catDict.has("Dests")) {
                    nameDictionaryRef = this.catDict.get("Dests");
                  }
                  if (nameDictionaryRef) {
                    obj = nameDictionaryRef;
                    obj.forEach(function catalogForEach(key, value) {
                      if (!value) {
                        return;
                      }
                      dests[key] = fetchDestination(value);
                    });
                  }
                  if (nameTreeRef) {
                    var nameTree = new NameTree(nameTreeRef, xref);
                    var names = nameTree.getAll();
                    for (var name in names) {
                      dests[name] = fetchDestination(names[name]);
                    }
                  }
                  return (0, _util.shadow)(this, "destinations", dests);
                },
                getDestination: function Catalog_getDestination(destinationId) {
                  function fetchDestination(dest2) {
                    return (0, _primitives.isDict)(dest2) ? dest2.get("D") : dest2;
                  }
                  var xref = this.xref;
                  var dest = null, nameTreeRef, nameDictionaryRef;
                  var obj = this.catDict.get("Names");
                  if (obj && obj.has("Dests")) {
                    nameTreeRef = obj.getRaw("Dests");
                  } else if (this.catDict.has("Dests")) {
                    nameDictionaryRef = this.catDict.get("Dests");
                  }
                  if (nameDictionaryRef) {
                    var value = nameDictionaryRef.get(destinationId);
                    if (value) {
                      dest = fetchDestination(value);
                    }
                  }
                  if (nameTreeRef) {
                    var nameTree = new NameTree(nameTreeRef, xref);
                    dest = fetchDestination(nameTree.get(destinationId));
                  }
                  return dest;
                },
                get pageLabels() {
                  var obj = null;
                  try {
                    obj = this.readPageLabels();
                  } catch (ex) {
                    if (ex instanceof _util.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)("Unable to read page labels.");
                  }
                  return (0, _util.shadow)(this, "pageLabels", obj);
                },
                readPageLabels: function Catalog_readPageLabels() {
                  var obj = this.catDict.getRaw("PageLabels");
                  if (!obj) {
                    return null;
                  }
                  var pageLabels = new Array(this.numPages);
                  var style = null;
                  var prefix = "";
                  var numberTree = new NumberTree(obj, this.xref);
                  var nums = numberTree.getAll();
                  var currentLabel = "", currentIndex = 1;
                  for (var i = 0, ii = this.numPages; i < ii; i++) {
                    if (i in nums) {
                      var labelDict = nums[i];
                      if (!(0, _primitives.isDict)(labelDict)) {
                        throw new _util.FormatError("The PageLabel is not a dictionary.");
                      }
                      var type = labelDict.get("Type");
                      if (type && !(0, _primitives.isName)(type, "PageLabel")) {
                        throw new _util.FormatError("Invalid type in PageLabel dictionary.");
                      }
                      var s = labelDict.get("S");
                      if (s && !(0, _primitives.isName)(s)) {
                        throw new _util.FormatError("Invalid style in PageLabel dictionary.");
                      }
                      style = s ? s.name : null;
                      var p = labelDict.get("P");
                      if (p && !(0, _util.isString)(p)) {
                        throw new _util.FormatError("Invalid prefix in PageLabel dictionary.");
                      }
                      prefix = p ? (0, _util.stringToPDFString)(p) : "";
                      var st = labelDict.get("St");
                      if (st && !(Number.isInteger(st) && st >= 1)) {
                        throw new _util.FormatError("Invalid start in PageLabel dictionary.");
                      }
                      currentIndex = st || 1;
                    }
                    switch (style) {
                      case "D":
                        currentLabel = currentIndex;
                        break;
                      case "R":
                      case "r":
                        currentLabel = _util.Util.toRoman(currentIndex, style === "r");
                        break;
                      case "A":
                      case "a":
                        var LIMIT = 26;
                        var A_UPPER_CASE = 65, A_LOWER_CASE = 97;
                        var baseCharCode = style === "a" ? A_LOWER_CASE : A_UPPER_CASE;
                        var letterIndex = currentIndex - 1;
                        var character = String.fromCharCode(baseCharCode + letterIndex % LIMIT);
                        var charBuf = [];
                        for (var j = 0, jj = letterIndex / LIMIT | 0; j <= jj; j++) {
                          charBuf.push(character);
                        }
                        currentLabel = charBuf.join("");
                        break;
                      default:
                        if (style) {
                          throw new _util.FormatError('Invalid style "' + style + '" in PageLabel dictionary.');
                        }
                    }
                    pageLabels[i] = prefix + currentLabel;
                    currentLabel = "";
                    currentIndex++;
                  }
                  return pageLabels;
                },
                get pageMode() {
                  var obj = this.catDict.get("PageMode");
                  var pageMode = "UseNone";
                  if ((0, _primitives.isName)(obj)) {
                    switch (obj.name) {
                      case "UseNone":
                      case "UseOutlines":
                      case "UseThumbs":
                      case "FullScreen":
                      case "UseOC":
                      case "UseAttachments":
                        pageMode = obj.name;
                    }
                  }
                  return (0, _util.shadow)(this, "pageMode", pageMode);
                },
                get attachments() {
                  var xref = this.xref;
                  var attachments = null, nameTreeRef;
                  var obj = this.catDict.get("Names");
                  if (obj) {
                    nameTreeRef = obj.getRaw("EmbeddedFiles");
                  }
                  if (nameTreeRef) {
                    var nameTree = new NameTree(nameTreeRef, xref);
                    var names = nameTree.getAll();
                    for (var name in names) {
                      var fs = new FileSpec(names[name], xref);
                      if (!attachments) {
                        attachments = /* @__PURE__ */ Object.create(null);
                      }
                      attachments[(0, _util.stringToPDFString)(name)] = fs.serializable;
                    }
                  }
                  return (0, _util.shadow)(this, "attachments", attachments);
                },
                get javaScript() {
                  var xref = this.xref;
                  var obj = this.catDict.get("Names");
                  var javaScript = [];
                  function appendIfJavaScriptDict(jsDict2) {
                    var type = jsDict2.get("S");
                    if (!(0, _primitives.isName)(type, "JavaScript")) {
                      return;
                    }
                    var js = jsDict2.get("JS");
                    if ((0, _primitives.isStream)(js)) {
                      js = (0, _util.bytesToString)(js.getBytes());
                    } else if (!(0, _util.isString)(js)) {
                      return;
                    }
                    javaScript.push((0, _util.stringToPDFString)(js));
                  }
                  if (obj && obj.has("JavaScript")) {
                    var nameTree = new NameTree(obj.getRaw("JavaScript"), xref);
                    var names = nameTree.getAll();
                    for (var name in names) {
                      var jsDict = names[name];
                      if ((0, _primitives.isDict)(jsDict)) {
                        appendIfJavaScriptDict(jsDict);
                      }
                    }
                  }
                  var openactionDict = this.catDict.get("OpenAction");
                  if ((0, _primitives.isDict)(openactionDict, "Action")) {
                    var actionType = openactionDict.get("S");
                    if ((0, _primitives.isName)(actionType, "Named")) {
                      var action = openactionDict.get("N");
                      if ((0, _primitives.isName)(action, "Print")) {
                        javaScript.push("print({});");
                      }
                    } else {
                      appendIfJavaScriptDict(openactionDict);
                    }
                  }
                  return (0, _util.shadow)(this, "javaScript", javaScript);
                },
                cleanup: function Catalog_cleanup() {
                  var _this = this;
                  this.pageKidsCountCache.clear();
                  var promises = [];
                  this.fontCache.forEach(function(promise) {
                    promises.push(promise);
                  });
                  return Promise.all(promises).then(function(translatedFonts) {
                    for (var i = 0, ii = translatedFonts.length; i < ii; i++) {
                      var font = translatedFonts[i].dict;
                      delete font.translated;
                    }
                    _this.fontCache.clear();
                    _this.builtInCMapCache = /* @__PURE__ */ Object.create(null);
                  });
                },
                getPage: function Catalog_getPage(pageIndex) {
                  var _this2 = this;
                  if (!(pageIndex in this.pagePromises)) {
                    this.pagePromises[pageIndex] = this.getPageDict(pageIndex).then(function(_ref) {
                      var _ref2 = _slicedToArray(_ref, 2), dict = _ref2[0], ref = _ref2[1];
                      return _this2.pageFactory.createPage(pageIndex, dict, ref, _this2.fontCache, _this2.builtInCMapCache);
                    });
                  }
                  return this.pagePromises[pageIndex];
                },
                getPageDict: function Catalog_getPageDict(pageIndex) {
                  var capability = (0, _util.createPromiseCapability)();
                  var nodesToVisit = [this.catDict.getRaw("Pages")];
                  var count, currentPageIndex = 0;
                  var xref = this.xref, pageKidsCountCache = this.pageKidsCountCache;
                  function next() {
                    while (nodesToVisit.length) {
                      var currentNode = nodesToVisit.pop();
                      if ((0, _primitives.isRef)(currentNode)) {
                        count = pageKidsCountCache.get(currentNode);
                        if (count > 0 && currentPageIndex + count < pageIndex) {
                          currentPageIndex += count;
                          continue;
                        }
                        xref.fetchAsync(currentNode).then(function(obj) {
                          if ((0, _primitives.isDict)(obj, "Page") || (0, _primitives.isDict)(obj) && !obj.has("Kids")) {
                            if (pageIndex === currentPageIndex) {
                              if (currentNode && !pageKidsCountCache.has(currentNode)) {
                                pageKidsCountCache.put(currentNode, 1);
                              }
                              capability.resolve([obj, currentNode]);
                            } else {
                              currentPageIndex++;
                              next();
                            }
                            return;
                          }
                          nodesToVisit.push(obj);
                          next();
                        }, capability.reject);
                        return;
                      }
                      if (!(0, _primitives.isDict)(currentNode)) {
                        capability.reject(new _util.FormatError("page dictionary kid reference points to wrong type of object"));
                        return;
                      }
                      count = currentNode.get("Count");
                      var objId = currentNode.objId;
                      if (objId && !pageKidsCountCache.has(objId)) {
                        pageKidsCountCache.put(objId, count);
                      }
                      if (currentPageIndex + count <= pageIndex) {
                        currentPageIndex += count;
                        continue;
                      }
                      var kids = currentNode.get("Kids");
                      if (!Array.isArray(kids)) {
                        capability.reject(new _util.FormatError("page dictionary kids object is not an array"));
                        return;
                      }
                      for (var last = kids.length - 1; last >= 0; last--) {
                        nodesToVisit.push(kids[last]);
                      }
                    }
                    capability.reject(new Error("Page index " + pageIndex + " not found."));
                  }
                  next();
                  return capability.promise;
                },
                getPageIndex: function Catalog_getPageIndex(pageRef) {
                  var xref = this.xref;
                  function pagesBeforeRef(kidRef) {
                    var total2 = 0;
                    var parentRef;
                    return xref.fetchAsync(kidRef).then(function(node) {
                      if ((0, _primitives.isRefsEqual)(kidRef, pageRef) && !(0, _primitives.isDict)(node, "Page") && !((0, _primitives.isDict)(node) && !node.has("Type") && node.has("Contents"))) {
                        throw new _util.FormatError("The reference does not point to a /Page Dict.");
                      }
                      if (!node) {
                        return null;
                      }
                      if (!(0, _primitives.isDict)(node)) {
                        throw new _util.FormatError("node must be a Dict.");
                      }
                      parentRef = node.getRaw("Parent");
                      return node.getAsync("Parent");
                    }).then(function(parent) {
                      if (!parent) {
                        return null;
                      }
                      if (!(0, _primitives.isDict)(parent)) {
                        throw new _util.FormatError("parent must be a Dict.");
                      }
                      return parent.getAsync("Kids");
                    }).then(function(kids) {
                      if (!kids) {
                        return null;
                      }
                      var kidPromises = [];
                      var found = false;
                      for (var i = 0; i < kids.length; i++) {
                        var kid = kids[i];
                        if (!(0, _primitives.isRef)(kid)) {
                          throw new _util.FormatError("kid must be a Ref.");
                        }
                        if (kid.num === kidRef.num) {
                          found = true;
                          break;
                        }
                        kidPromises.push(xref.fetchAsync(kid).then(function(kid2) {
                          if (kid2.has("Count")) {
                            var count = kid2.get("Count");
                            total2 += count;
                          } else {
                            total2++;
                          }
                        }));
                      }
                      if (!found) {
                        throw new _util.FormatError("kid ref not found in parents kids");
                      }
                      return Promise.all(kidPromises).then(function() {
                        return [total2, parentRef];
                      });
                    });
                  }
                  var total = 0;
                  function next(ref) {
                    return pagesBeforeRef(ref).then(function(args) {
                      if (!args) {
                        return total;
                      }
                      var count = args[0];
                      var parentRef = args[1];
                      total += count;
                      return next(parentRef);
                    });
                  }
                  return next(pageRef);
                }
              };
              Catalog2.parseDestDictionary = function Catalog_parseDestDictionary(params) {
                function addDefaultProtocolToUrl(url2) {
                  if (url2.indexOf("www.") === 0) {
                    return "http://" + url2;
                  }
                  return url2;
                }
                function tryConvertUrlEncoding(url2) {
                  try {
                    return (0, _util.stringToUTF8String)(url2);
                  } catch (e) {
                    return url2;
                  }
                }
                var destDict = params.destDict;
                if (!(0, _primitives.isDict)(destDict)) {
                  (0, _util.warn)('parseDestDictionary: "destDict" must be a dictionary.');
                  return;
                }
                var resultObj = params.resultObj;
                if ((typeof resultObj === "undefined" ? "undefined" : _typeof(resultObj)) !== "object") {
                  (0, _util.warn)('parseDestDictionary: "resultObj" must be an object.');
                  return;
                }
                var docBaseUrl = params.docBaseUrl || null;
                var action = destDict.get("A"), url, dest;
                if (!(0, _primitives.isDict)(action) && destDict.has("Dest")) {
                  action = destDict.get("Dest");
                }
                if ((0, _primitives.isDict)(action)) {
                  var actionType = action.get("S");
                  if (!(0, _primitives.isName)(actionType)) {
                    (0, _util.warn)("parseDestDictionary: Invalid type in Action dictionary.");
                    return;
                  }
                  var actionName = actionType.name;
                  switch (actionName) {
                    case "URI":
                      url = action.get("URI");
                      if ((0, _primitives.isName)(url)) {
                        url = "/" + url.name;
                      } else if ((0, _util.isString)(url)) {
                        url = addDefaultProtocolToUrl(url);
                      }
                      break;
                    case "GoTo":
                      dest = action.get("D");
                      break;
                    case "Launch":
                    case "GoToR":
                      var urlDict = action.get("F");
                      if ((0, _primitives.isDict)(urlDict)) {
                        url = urlDict.get("F") || null;
                      } else if ((0, _util.isString)(urlDict)) {
                        url = urlDict;
                      }
                      var remoteDest = action.get("D");
                      if (remoteDest) {
                        if ((0, _primitives.isName)(remoteDest)) {
                          remoteDest = remoteDest.name;
                        }
                        if ((0, _util.isString)(url)) {
                          var baseUrl = url.split("#")[0];
                          if ((0, _util.isString)(remoteDest)) {
                            url = baseUrl + "#" + remoteDest;
                          } else if (Array.isArray(remoteDest)) {
                            url = baseUrl + "#" + JSON.stringify(remoteDest);
                          }
                        }
                      }
                      var newWindow = action.get("NewWindow");
                      if ((0, _util.isBool)(newWindow)) {
                        resultObj.newWindow = newWindow;
                      }
                      break;
                    case "Named":
                      var namedAction = action.get("N");
                      if ((0, _primitives.isName)(namedAction)) {
                        resultObj.action = namedAction.name;
                      }
                      break;
                    case "JavaScript":
                      var jsAction = action.get("JS"), js;
                      if ((0, _primitives.isStream)(jsAction)) {
                        js = (0, _util.bytesToString)(jsAction.getBytes());
                      } else if ((0, _util.isString)(jsAction)) {
                        js = jsAction;
                      }
                      if (js) {
                        var URL_OPEN_METHODS = ["app.launchURL", "window.open"];
                        var regex = new RegExp("^\\s*(" + URL_OPEN_METHODS.join("|").split(".").join("\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i");
                        var jsUrl = regex.exec((0, _util.stringToPDFString)(js));
                        if (jsUrl && jsUrl[2]) {
                          url = jsUrl[2];
                          if (jsUrl[3] === "true" && jsUrl[1] === "app.launchURL") {
                            resultObj.newWindow = true;
                          }
                          break;
                        }
                      }
                    default:
                      (0, _util.warn)('parseDestDictionary: Unsupported Action type "' + actionName + '".');
                      break;
                  }
                } else if (destDict.has("Dest")) {
                  dest = destDict.get("Dest");
                }
                if ((0, _util.isString)(url)) {
                  url = tryConvertUrlEncoding(url);
                  var absoluteUrl = (0, _util.createValidAbsoluteUrl)(url, docBaseUrl);
                  if (absoluteUrl) {
                    resultObj.url = absoluteUrl.href;
                  }
                  resultObj.unsafeUrl = url;
                }
                if (dest) {
                  if ((0, _primitives.isName)(dest)) {
                    dest = dest.name;
                  }
                  if ((0, _util.isString)(dest) || Array.isArray(dest)) {
                    resultObj.dest = dest;
                  }
                }
              };
              return Catalog2;
            }();
            var XRef = function XRefClosure() {
              function XRef2(stream, pdfManager) {
                this.stream = stream;
                this.pdfManager = pdfManager;
                this.entries = [];
                this.xrefstms = /* @__PURE__ */ Object.create(null);
                this.cache = [];
                this.stats = {
                  streamTypes: [],
                  fontTypes: []
                };
              }
              XRef2.prototype = {
                setStartXRef: function XRef_setStartXRef(startXRef) {
                  this.startXRefQueue = [startXRef];
                },
                parse: function XRef_parse(recoveryMode) {
                  var trailerDict;
                  if (!recoveryMode) {
                    trailerDict = this.readXRef();
                  } else {
                    (0, _util.warn)("Indexing all PDF objects");
                    trailerDict = this.indexObjects();
                  }
                  trailerDict.assignXref(this);
                  this.trailer = trailerDict;
                  var encrypt = trailerDict.get("Encrypt");
                  if ((0, _primitives.isDict)(encrypt)) {
                    var ids = trailerDict.get("ID");
                    var fileId = ids && ids.length ? ids[0] : "";
                    encrypt.suppressEncryption = true;
                    this.encrypt = new _crypto.CipherTransformFactory(encrypt, fileId, this.pdfManager.password);
                  }
                  if (!(this.root = trailerDict.get("Root"))) {
                    throw new _util.FormatError("Invalid root reference");
                  }
                },
                processXRefTable: function XRef_processXRefTable(parser) {
                  if (!("tableState" in this)) {
                    this.tableState = {
                      entryNum: 0,
                      streamPos: parser.lexer.stream.pos,
                      parserBuf1: parser.buf1,
                      parserBuf2: parser.buf2
                    };
                  }
                  var obj = this.readXRefTable(parser);
                  if (!(0, _primitives.isCmd)(obj, "trailer")) {
                    throw new _util.FormatError("Invalid XRef table: could not find trailer dictionary");
                  }
                  var dict = parser.getObj();
                  if (!(0, _primitives.isDict)(dict) && dict.dict) {
                    dict = dict.dict;
                  }
                  if (!(0, _primitives.isDict)(dict)) {
                    throw new _util.FormatError("Invalid XRef table: could not parse trailer dictionary");
                  }
                  delete this.tableState;
                  return dict;
                },
                readXRefTable: function XRef_readXRefTable(parser) {
                  var stream = parser.lexer.stream;
                  var tableState = this.tableState;
                  stream.pos = tableState.streamPos;
                  parser.buf1 = tableState.parserBuf1;
                  parser.buf2 = tableState.parserBuf2;
                  var obj;
                  while (true) {
                    if (!("firstEntryNum" in tableState) || !("entryCount" in tableState)) {
                      if ((0, _primitives.isCmd)(obj = parser.getObj(), "trailer")) {
                        break;
                      }
                      tableState.firstEntryNum = obj;
                      tableState.entryCount = parser.getObj();
                    }
                    var first = tableState.firstEntryNum;
                    var count = tableState.entryCount;
                    if (!Number.isInteger(first) || !Number.isInteger(count)) {
                      throw new _util.FormatError("Invalid XRef table: wrong types in subsection header");
                    }
                    for (var i = tableState.entryNum; i < count; i++) {
                      tableState.streamPos = stream.pos;
                      tableState.entryNum = i;
                      tableState.parserBuf1 = parser.buf1;
                      tableState.parserBuf2 = parser.buf2;
                      var entry = {};
                      entry.offset = parser.getObj();
                      entry.gen = parser.getObj();
                      var type = parser.getObj();
                      if ((0, _primitives.isCmd)(type, "f")) {
                        entry.free = true;
                      } else if ((0, _primitives.isCmd)(type, "n")) {
                        entry.uncompressed = true;
                      }
                      if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) {
                        throw new _util.FormatError("Invalid entry in XRef subsection: " + first + ", " + count);
                      }
                      if (i === 0 && entry.free && first === 1) {
                        first = 0;
                      }
                      if (!this.entries[i + first]) {
                        this.entries[i + first] = entry;
                      }
                    }
                    tableState.entryNum = 0;
                    tableState.streamPos = stream.pos;
                    tableState.parserBuf1 = parser.buf1;
                    tableState.parserBuf2 = parser.buf2;
                    delete tableState.firstEntryNum;
                    delete tableState.entryCount;
                  }
                  if (this.entries[0] && !this.entries[0].free) {
                    throw new _util.FormatError("Invalid XRef table: unexpected first object");
                  }
                  return obj;
                },
                processXRefStream: function XRef_processXRefStream(stream) {
                  if (!("streamState" in this)) {
                    var streamParameters = stream.dict;
                    var byteWidths = streamParameters.get("W");
                    var range = streamParameters.get("Index");
                    if (!range) {
                      range = [0, streamParameters.get("Size")];
                    }
                    this.streamState = {
                      entryRanges: range,
                      byteWidths,
                      entryNum: 0,
                      streamPos: stream.pos
                    };
                  }
                  this.readXRefStream(stream);
                  delete this.streamState;
                  return stream.dict;
                },
                readXRefStream: function XRef_readXRefStream(stream) {
                  var i, j;
                  var streamState = this.streamState;
                  stream.pos = streamState.streamPos;
                  var byteWidths = streamState.byteWidths;
                  var typeFieldWidth = byteWidths[0];
                  var offsetFieldWidth = byteWidths[1];
                  var generationFieldWidth = byteWidths[2];
                  var entryRanges = streamState.entryRanges;
                  while (entryRanges.length > 0) {
                    var first = entryRanges[0];
                    var n = entryRanges[1];
                    if (!Number.isInteger(first) || !Number.isInteger(n)) {
                      throw new _util.FormatError("Invalid XRef range fields: " + first + ", " + n);
                    }
                    if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) {
                      throw new _util.FormatError("Invalid XRef entry fields length: " + first + ", " + n);
                    }
                    for (i = streamState.entryNum; i < n; ++i) {
                      streamState.entryNum = i;
                      streamState.streamPos = stream.pos;
                      var type = 0, offset = 0, generation = 0;
                      for (j = 0; j < typeFieldWidth; ++j) {
                        type = type << 8 | stream.getByte();
                      }
                      if (typeFieldWidth === 0) {
                        type = 1;
                      }
                      for (j = 0; j < offsetFieldWidth; ++j) {
                        offset = offset << 8 | stream.getByte();
                      }
                      for (j = 0; j < generationFieldWidth; ++j) {
                        generation = generation << 8 | stream.getByte();
                      }
                      var entry = {};
                      entry.offset = offset;
                      entry.gen = generation;
                      switch (type) {
                        case 0:
                          entry.free = true;
                          break;
                        case 1:
                          entry.uncompressed = true;
                          break;
                        case 2:
                          break;
                        default:
                          throw new _util.FormatError("Invalid XRef entry type: " + type);
                      }
                      if (!this.entries[first + i]) {
                        this.entries[first + i] = entry;
                      }
                    }
                    streamState.entryNum = 0;
                    streamState.streamPos = stream.pos;
                    entryRanges.splice(0, 2);
                  }
                },
                indexObjects: function XRef_indexObjects() {
                  var TAB = 9, LF = 10, CR = 13, SPACE = 32;
                  var PERCENT = 37, LT = 60;
                  function readToken(data, offset) {
                    var token2 = "", ch2 = data[offset];
                    while (ch2 !== LF && ch2 !== CR && ch2 !== LT) {
                      if (++offset >= data.length) {
                        break;
                      }
                      token2 += String.fromCharCode(ch2);
                      ch2 = data[offset];
                    }
                    return token2;
                  }
                  function skipUntil(data, offset, what) {
                    var length2 = what.length, dataLength = data.length;
                    var skipped = 0;
                    while (offset < dataLength) {
                      var i2 = 0;
                      while (i2 < length2 && data[offset + i2] === what[i2]) {
                        ++i2;
                      }
                      if (i2 >= length2) {
                        break;
                      }
                      offset++;
                      skipped++;
                    }
                    return skipped;
                  }
                  var objRegExp = /^(\d+)\s+(\d+)\s+obj\b/;
                  var trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]);
                  var startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
                  var endobjBytes = new Uint8Array([101, 110, 100, 111, 98, 106]);
                  var xrefBytes = new Uint8Array([47, 88, 82, 101, 102]);
                  this.entries.length = 0;
                  var stream = this.stream;
                  stream.pos = 0;
                  var buffer = stream.getBytes();
                  var position = stream.start, length = buffer.length;
                  var trailers = [], xrefStms = [];
                  while (position < length) {
                    var ch = buffer[position];
                    if (ch === TAB || ch === LF || ch === CR || ch === SPACE) {
                      ++position;
                      continue;
                    }
                    if (ch === PERCENT) {
                      do {
                        ++position;
                        if (position >= length) {
                          break;
                        }
                        ch = buffer[position];
                      } while (ch !== LF && ch !== CR);
                      continue;
                    }
                    var token = readToken(buffer, position);
                    var m;
                    if (token.indexOf("xref") === 0 && (token.length === 4 || /\s/.test(token[4]))) {
                      position += skipUntil(buffer, position, trailerBytes);
                      trailers.push(position);
                      position += skipUntil(buffer, position, startxrefBytes);
                    } else if (m = objRegExp.exec(token)) {
                      if (typeof this.entries[m[1]] === "undefined") {
                        this.entries[m[1]] = {
                          offset: position - stream.start,
                          gen: m[2] | 0,
                          uncompressed: true
                        };
                      }
                      var contentLength = skipUntil(buffer, position, endobjBytes) + 7;
                      var content = buffer.subarray(position, position + contentLength);
                      var xrefTagOffset = skipUntil(content, 0, xrefBytes);
                      if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) {
                        xrefStms.push(position - stream.start);
                        this.xrefstms[position - stream.start] = 1;
                      }
                      position += contentLength;
                    } else if (token.indexOf("trailer") === 0 && (token.length === 7 || /\s/.test(token[7]))) {
                      trailers.push(position);
                      position += skipUntil(buffer, position, startxrefBytes);
                    } else {
                      position += token.length + 1;
                    }
                  }
                  var i, ii;
                  for (i = 0, ii = xrefStms.length; i < ii; ++i) {
                    this.startXRefQueue.push(xrefStms[i]);
                    this.readXRef(true);
                  }
                  var dict;
                  for (i = 0, ii = trailers.length; i < ii; ++i) {
                    stream.pos = trailers[i];
                    var parser = new _parser.Parser(new _parser.Lexer(stream), true, this, true);
                    var obj = parser.getObj();
                    if (!(0, _primitives.isCmd)(obj, "trailer")) {
                      continue;
                    }
                    dict = parser.getObj();
                    if (!(0, _primitives.isDict)(dict)) {
                      continue;
                    }
                    if (dict.has("ID")) {
                      return dict;
                    }
                  }
                  if (dict) {
                    return dict;
                  }
                  throw new _util.InvalidPDFException("Invalid PDF structure");
                },
                readXRef: function XRef_readXRef(recoveryMode) {
                  var stream = this.stream;
                  var startXRefParsedCache = /* @__PURE__ */ Object.create(null);
                  try {
                    while (this.startXRefQueue.length) {
                      var startXRef = this.startXRefQueue[0];
                      if (startXRefParsedCache[startXRef]) {
                        (0, _util.warn)("readXRef - skipping XRef table since it was already parsed.");
                        this.startXRefQueue.shift();
                        continue;
                      }
                      startXRefParsedCache[startXRef] = true;
                      stream.pos = startXRef + stream.start;
                      var parser = new _parser.Parser(new _parser.Lexer(stream), true, this);
                      var obj = parser.getObj();
                      var dict;
                      if ((0, _primitives.isCmd)(obj, "xref")) {
                        dict = this.processXRefTable(parser);
                        if (!this.topDict) {
                          this.topDict = dict;
                        }
                        obj = dict.get("XRefStm");
                        if (Number.isInteger(obj)) {
                          var pos = obj;
                          if (!(pos in this.xrefstms)) {
                            this.xrefstms[pos] = 1;
                            this.startXRefQueue.push(pos);
                          }
                        }
                      } else if (Number.isInteger(obj)) {
                        if (!Number.isInteger(parser.getObj()) || !(0, _primitives.isCmd)(parser.getObj(), "obj") || !(0, _primitives.isStream)(obj = parser.getObj())) {
                          throw new _util.FormatError("Invalid XRef stream");
                        }
                        dict = this.processXRefStream(obj);
                        if (!this.topDict) {
                          this.topDict = dict;
                        }
                        if (!dict) {
                          throw new _util.FormatError("Failed to read XRef stream");
                        }
                      } else {
                        throw new _util.FormatError("Invalid XRef stream header");
                      }
                      obj = dict.get("Prev");
                      if (Number.isInteger(obj)) {
                        this.startXRefQueue.push(obj);
                      } else if ((0, _primitives.isRef)(obj)) {
                        this.startXRefQueue.push(obj.num);
                      }
                      this.startXRefQueue.shift();
                    }
                    return this.topDict;
                  } catch (e) {
                    if (e instanceof _util.MissingDataException) {
                      throw e;
                    }
                    (0, _util.info)("(while reading XRef): " + e);
                  }
                  if (recoveryMode) {
                    return;
                  }
                  throw new _util.XRefParseException();
                },
                getEntry: function XRef_getEntry(i) {
                  var xrefEntry = this.entries[i];
                  if (xrefEntry && !xrefEntry.free && xrefEntry.offset) {
                    return xrefEntry;
                  }
                  return null;
                },
                fetchIfRef: function XRef_fetchIfRef(obj, suppressEncryption) {
                  if (!(0, _primitives.isRef)(obj)) {
                    return obj;
                  }
                  return this.fetch(obj, suppressEncryption);
                },
                fetch: function XRef_fetch(ref, suppressEncryption) {
                  if (!(0, _primitives.isRef)(ref)) {
                    throw new Error("ref object is not a reference");
                  }
                  var num = ref.num;
                  if (num in this.cache) {
                    var cacheEntry = this.cache[num];
                    if (cacheEntry instanceof _primitives.Dict && !cacheEntry.objId) {
                      cacheEntry.objId = ref.toString();
                    }
                    return cacheEntry;
                  }
                  var xrefEntry = this.getEntry(num);
                  if (xrefEntry === null) {
                    return this.cache[num] = null;
                  }
                  if (xrefEntry.uncompressed) {
                    xrefEntry = this.fetchUncompressed(ref, xrefEntry, suppressEncryption);
                  } else {
                    xrefEntry = this.fetchCompressed(xrefEntry, suppressEncryption);
                  }
                  if ((0, _primitives.isDict)(xrefEntry)) {
                    xrefEntry.objId = ref.toString();
                  } else if ((0, _primitives.isStream)(xrefEntry)) {
                    xrefEntry.dict.objId = ref.toString();
                  }
                  return xrefEntry;
                },
                fetchUncompressed: function XRef_fetchUncompressed(ref, xrefEntry, suppressEncryption) {
                  var gen = ref.gen;
                  var num = ref.num;
                  if (xrefEntry.gen !== gen) {
                    throw new _util.FormatError("inconsistent generation in XRef");
                  }
                  var stream = this.stream.makeSubStream(xrefEntry.offset + this.stream.start);
                  var parser = new _parser.Parser(new _parser.Lexer(stream), true, this);
                  var obj1 = parser.getObj();
                  var obj2 = parser.getObj();
                  var obj3 = parser.getObj();
                  if (!Number.isInteger(obj1)) {
                    obj1 = parseInt(obj1, 10);
                  }
                  if (!Number.isInteger(obj2)) {
                    obj2 = parseInt(obj2, 10);
                  }
                  if (obj1 !== num || obj2 !== gen || !(0, _primitives.isCmd)(obj3)) {
                    throw new _util.FormatError("bad XRef entry");
                  }
                  if (obj3.cmd !== "obj") {
                    if (obj3.cmd.indexOf("obj") === 0) {
                      num = parseInt(obj3.cmd.substring(3), 10);
                      if (!Number.isNaN(num)) {
                        return num;
                      }
                    }
                    throw new _util.FormatError("bad XRef entry");
                  }
                  if (this.encrypt && !suppressEncryption) {
                    xrefEntry = parser.getObj(this.encrypt.createCipherTransform(num, gen));
                  } else {
                    xrefEntry = parser.getObj();
                  }
                  if (!(0, _primitives.isStream)(xrefEntry)) {
                    this.cache[num] = xrefEntry;
                  }
                  return xrefEntry;
                },
                fetchCompressed: function XRef_fetchCompressed(xrefEntry, suppressEncryption) {
                  var tableOffset = xrefEntry.offset;
                  var stream = this.fetch(new _primitives.Ref(tableOffset, 0));
                  if (!(0, _primitives.isStream)(stream)) {
                    throw new _util.FormatError("bad ObjStm stream");
                  }
                  var first = stream.dict.get("First");
                  var n = stream.dict.get("N");
                  if (!Number.isInteger(first) || !Number.isInteger(n)) {
                    throw new _util.FormatError("invalid first and n parameters for ObjStm stream");
                  }
                  var parser = new _parser.Parser(new _parser.Lexer(stream), false, this);
                  parser.allowStreams = true;
                  var i, entries = [], num, nums = [];
                  for (i = 0; i < n; ++i) {
                    num = parser.getObj();
                    if (!Number.isInteger(num)) {
                      throw new _util.FormatError("invalid object number in the ObjStm stream: " + num);
                    }
                    nums.push(num);
                    var offset = parser.getObj();
                    if (!Number.isInteger(offset)) {
                      throw new _util.FormatError("invalid object offset in the ObjStm stream: " + offset);
                    }
                  }
                  for (i = 0; i < n; ++i) {
                    entries.push(parser.getObj());
                    if ((0, _primitives.isCmd)(parser.buf1, "endobj")) {
                      parser.shift();
                    }
                    num = nums[i];
                    var entry = this.entries[num];
                    if (entry && entry.offset === tableOffset && entry.gen === i) {
                      this.cache[num] = entries[i];
                    }
                  }
                  xrefEntry = entries[xrefEntry.gen];
                  if (xrefEntry === void 0) {
                    throw new _util.FormatError("bad XRef entry for compressed object");
                  }
                  return xrefEntry;
                },
                fetchIfRefAsync: function XRef_fetchIfRefAsync(obj, suppressEncryption) {
                  if (!(0, _primitives.isRef)(obj)) {
                    return Promise.resolve(obj);
                  }
                  return this.fetchAsync(obj, suppressEncryption);
                },
                fetchAsync: function XRef_fetchAsync(ref, suppressEncryption) {
                  var streamManager = this.stream.manager;
                  var xref = this;
                  return new Promise(function tryFetch(resolve, reject) {
                    try {
                      resolve(xref.fetch(ref, suppressEncryption));
                    } catch (e) {
                      if (e instanceof _util.MissingDataException) {
                        streamManager.requestRange(e.begin, e.end).then(function() {
                          tryFetch(resolve, reject);
                        }, reject);
                        return;
                      }
                      reject(e);
                    }
                  });
                },
                getCatalogObj: function XRef_getCatalogObj() {
                  return this.root;
                }
              };
              return XRef2;
            }();
            var NameOrNumberTree = function NameOrNumberTreeClosure() {
              function NameOrNumberTree2(root, xref) {
                throw new Error("Cannot initialize NameOrNumberTree.");
              }
              NameOrNumberTree2.prototype = {
                getAll: function NameOrNumberTree_getAll() {
                  var dict = /* @__PURE__ */ Object.create(null);
                  if (!this.root) {
                    return dict;
                  }
                  var xref = this.xref;
                  var processed = new _primitives.RefSet();
                  processed.put(this.root);
                  var queue = [this.root];
                  while (queue.length > 0) {
                    var i, n;
                    var obj = xref.fetchIfRef(queue.shift());
                    if (!(0, _primitives.isDict)(obj)) {
                      continue;
                    }
                    if (obj.has("Kids")) {
                      var kids = obj.get("Kids");
                      for (i = 0, n = kids.length; i < n; i++) {
                        var kid = kids[i];
                        if (processed.has(kid)) {
                          throw new _util.FormatError('Duplicate entry in "' + this._type + '" tree.');
                        }
                        queue.push(kid);
                        processed.put(kid);
                      }
                      continue;
                    }
                    var entries = obj.get(this._type);
                    if (Array.isArray(entries)) {
                      for (i = 0, n = entries.length; i < n; i += 2) {
                        dict[xref.fetchIfRef(entries[i])] = xref.fetchIfRef(entries[i + 1]);
                      }
                    }
                  }
                  return dict;
                },
                get: function NameOrNumberTree_get(key) {
                  if (!this.root) {
                    return null;
                  }
                  var xref = this.xref;
                  var kidsOrEntries = xref.fetchIfRef(this.root);
                  var loopCount = 0;
                  var MAX_LEVELS = 10;
                  var l, r, m;
                  while (kidsOrEntries.has("Kids")) {
                    if (++loopCount > MAX_LEVELS) {
                      (0, _util.warn)('Search depth limit reached for "' + this._type + '" tree.');
                      return null;
                    }
                    var kids = kidsOrEntries.get("Kids");
                    if (!Array.isArray(kids)) {
                      return null;
                    }
                    l = 0;
                    r = kids.length - 1;
                    while (l <= r) {
                      m = l + r >> 1;
                      var kid = xref.fetchIfRef(kids[m]);
                      var limits = kid.get("Limits");
                      if (key < xref.fetchIfRef(limits[0])) {
                        r = m - 1;
                      } else if (key > xref.fetchIfRef(limits[1])) {
                        l = m + 1;
                      } else {
                        kidsOrEntries = xref.fetchIfRef(kids[m]);
                        break;
                      }
                    }
                    if (l > r) {
                      return null;
                    }
                  }
                  var entries = kidsOrEntries.get(this._type);
                  if (Array.isArray(entries)) {
                    l = 0;
                    r = entries.length - 2;
                    while (l <= r) {
                      m = l + r & ~1;
                      var currentKey = xref.fetchIfRef(entries[m]);
                      if (key < currentKey) {
                        r = m - 2;
                      } else if (key > currentKey) {
                        l = m + 2;
                      } else {
                        return xref.fetchIfRef(entries[m + 1]);
                      }
                    }
                  }
                  return null;
                }
              };
              return NameOrNumberTree2;
            }();
            var NameTree = function NameTreeClosure() {
              function NameTree2(root, xref) {
                this.root = root;
                this.xref = xref;
                this._type = "Names";
              }
              _util.Util.inherit(NameTree2, NameOrNumberTree, {});
              return NameTree2;
            }();
            var NumberTree = function NumberTreeClosure() {
              function NumberTree2(root, xref) {
                this.root = root;
                this.xref = xref;
                this._type = "Nums";
              }
              _util.Util.inherit(NumberTree2, NameOrNumberTree, {});
              return NumberTree2;
            }();
            var FileSpec = function FileSpecClosure() {
              function FileSpec2(root, xref) {
                if (!root || !(0, _primitives.isDict)(root)) {
                  return;
                }
                this.xref = xref;
                this.root = root;
                if (root.has("FS")) {
                  this.fs = root.get("FS");
                }
                this.description = root.has("Desc") ? (0, _util.stringToPDFString)(root.get("Desc")) : "";
                if (root.has("RF")) {
                  (0, _util.warn)("Related file specifications are not supported");
                }
                this.contentAvailable = true;
                if (!root.has("EF")) {
                  this.contentAvailable = false;
                  (0, _util.warn)("Non-embedded file specifications are not supported");
                }
              }
              function pickPlatformItem(dict) {
                if (dict.has("UF")) {
                  return dict.get("UF");
                } else if (dict.has("F")) {
                  return dict.get("F");
                } else if (dict.has("Unix")) {
                  return dict.get("Unix");
                } else if (dict.has("Mac")) {
                  return dict.get("Mac");
                } else if (dict.has("DOS")) {
                  return dict.get("DOS");
                }
                return null;
              }
              FileSpec2.prototype = {
                get filename() {
                  if (!this._filename && this.root) {
                    var filename = pickPlatformItem(this.root) || "unnamed";
                    this._filename = (0, _util.stringToPDFString)(filename).replace(/\\\\/g, "\\").replace(/\\\//g, "/").replace(/\\/g, "/");
                  }
                  return this._filename;
                },
                get content() {
                  if (!this.contentAvailable) {
                    return null;
                  }
                  if (!this.contentRef && this.root) {
                    this.contentRef = pickPlatformItem(this.root.get("EF"));
                  }
                  var content = null;
                  if (this.contentRef) {
                    var xref = this.xref;
                    var fileObj = xref.fetchIfRef(this.contentRef);
                    if (fileObj && (0, _primitives.isStream)(fileObj)) {
                      content = fileObj.getBytes();
                    } else {
                      (0, _util.warn)("Embedded file specification points to non-existing/invalid content");
                    }
                  } else {
                    (0, _util.warn)("Embedded file specification does not have a content");
                  }
                  return content;
                },
                get serializable() {
                  return {
                    filename: this.filename,
                    content: this.content
                  };
                }
              };
              return FileSpec2;
            }();
            var ObjectLoader = function() {
              function mayHaveChildren(value) {
                return (0, _primitives.isRef)(value) || (0, _primitives.isDict)(value) || Array.isArray(value) || (0, _primitives.isStream)(value);
              }
              function addChildren(node, nodesToVisit) {
                if ((0, _primitives.isDict)(node) || (0, _primitives.isStream)(node)) {
                  var dict = (0, _primitives.isDict)(node) ? node : node.dict;
                  var dictKeys = dict.getKeys();
                  for (var i = 0, ii = dictKeys.length; i < ii; i++) {
                    var rawValue = dict.getRaw(dictKeys[i]);
                    if (mayHaveChildren(rawValue)) {
                      nodesToVisit.push(rawValue);
                    }
                  }
                } else if (Array.isArray(node)) {
                  for (var _i = 0, _ii = node.length; _i < _ii; _i++) {
                    var value = node[_i];
                    if (mayHaveChildren(value)) {
                      nodesToVisit.push(value);
                    }
                  }
                }
              }
              function ObjectLoader2(dict, keys, xref) {
                this.dict = dict;
                this.keys = keys;
                this.xref = xref;
                this.refSet = null;
                this.capability = null;
              }
              ObjectLoader2.prototype = {
                load: function load() {
                  this.capability = (0, _util.createPromiseCapability)();
                  if (!(this.xref.stream instanceof _chunked_stream.ChunkedStream) || this.xref.stream.getMissingChunks().length === 0) {
                    this.capability.resolve();
                    return this.capability.promise;
                  }
                  var keys = this.keys, dict = this.dict;
                  this.refSet = new _primitives.RefSet();
                  var nodesToVisit = [];
                  for (var i = 0, ii = keys.length; i < ii; i++) {
                    var rawValue = dict.getRaw(keys[i]);
                    if (rawValue !== void 0) {
                      nodesToVisit.push(rawValue);
                    }
                  }
                  this._walk(nodesToVisit);
                  return this.capability.promise;
                },
                _walk: function _walk(nodesToVisit) {
                  var _this3 = this;
                  var nodesToRevisit = [];
                  var pendingRequests = [];
                  while (nodesToVisit.length) {
                    var currentNode = nodesToVisit.pop();
                    if ((0, _primitives.isRef)(currentNode)) {
                      if (this.refSet.has(currentNode)) {
                        continue;
                      }
                      try {
                        this.refSet.put(currentNode);
                        currentNode = this.xref.fetch(currentNode);
                      } catch (ex) {
                        if (!(ex instanceof _util.MissingDataException)) {
                          throw ex;
                        }
                        nodesToRevisit.push(currentNode);
                        pendingRequests.push({
                          begin: ex.begin,
                          end: ex.end
                        });
                      }
                    }
                    if (currentNode && currentNode.getBaseStreams) {
                      var baseStreams = currentNode.getBaseStreams();
                      var foundMissingData = false;
                      for (var i = 0, ii = baseStreams.length; i < ii; i++) {
                        var stream = baseStreams[i];
                        if (stream.getMissingChunks && stream.getMissingChunks().length) {
                          foundMissingData = true;
                          pendingRequests.push({
                            begin: stream.start,
                            end: stream.end
                          });
                        }
                      }
                      if (foundMissingData) {
                        nodesToRevisit.push(currentNode);
                      }
                    }
                    addChildren(currentNode, nodesToVisit);
                  }
                  if (pendingRequests.length) {
                    this.xref.stream.manager.requestRanges(pendingRequests).then(function() {
                      for (var _i2 = 0, _ii2 = nodesToRevisit.length; _i2 < _ii2; _i2++) {
                        var node = nodesToRevisit[_i2];
                        if ((0, _primitives.isRef)(node)) {
                          _this3.refSet.remove(node);
                        }
                      }
                      _this3._walk(nodesToRevisit);
                    }, this.capability.reject);
                    return;
                  }
                  this.refSet = null;
                  this.capability.resolve();
                }
              };
              return ObjectLoader2;
            }();
            exports2.Catalog = Catalog;
            exports2.ObjectLoader = ObjectLoader;
            exports2.XRef = XRef;
            exports2.FileSpec = FileSpec;
          },
          /* 74 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.JpxImage = void 0;
            var _util = __w_pdfjs_require__(0);
            var _arithmetic_decoder = __w_pdfjs_require__(75);
            var JpxError = function JpxErrorClosure() {
              function JpxError2(msg) {
                this.message = "JPX error: " + msg;
              }
              JpxError2.prototype = new Error();
              JpxError2.prototype.name = "JpxError";
              JpxError2.constructor = JpxError2;
              return JpxError2;
            }();
            var JpxImage = function JpxImageClosure() {
              var SubbandsGainLog2 = {
                "LL": 0,
                "LH": 1,
                "HL": 1,
                "HH": 2
              };
              function JpxImage2() {
                this.failOnCorruptedImage = false;
              }
              JpxImage2.prototype = {
                parse: function JpxImage_parse(data) {
                  var head = (0, _util.readUint16)(data, 0);
                  if (head === 65359) {
                    this.parseCodestream(data, 0, data.length);
                    return;
                  }
                  var position = 0, length = data.length;
                  while (position < length) {
                    var headerSize = 8;
                    var lbox = (0, _util.readUint32)(data, position);
                    var tbox = (0, _util.readUint32)(data, position + 4);
                    position += headerSize;
                    if (lbox === 1) {
                      lbox = (0, _util.readUint32)(data, position) * 4294967296 + (0, _util.readUint32)(data, position + 4);
                      position += 8;
                      headerSize += 8;
                    }
                    if (lbox === 0) {
                      lbox = length - position + headerSize;
                    }
                    if (lbox < headerSize) {
                      throw new JpxError("Invalid box field size");
                    }
                    var dataLength = lbox - headerSize;
                    var jumpDataLength = true;
                    switch (tbox) {
                      case 1785737832:
                        jumpDataLength = false;
                        break;
                      case 1668246642:
                        var method = data[position];
                        if (method === 1) {
                          var colorspace = (0, _util.readUint32)(data, position + 3);
                          switch (colorspace) {
                            case 16:
                            case 17:
                            case 18:
                              break;
                            default:
                              (0, _util.warn)("Unknown colorspace " + colorspace);
                              break;
                          }
                        } else if (method === 2) {
                          (0, _util.info)("ICC profile not supported");
                        }
                        break;
                      case 1785737827:
                        this.parseCodestream(data, position, position + dataLength);
                        break;
                      case 1783636e3:
                        if ((0, _util.readUint32)(data, position) !== 218793738) {
                          (0, _util.warn)("Invalid JP2 signature");
                        }
                        break;
                      case 1783634458:
                      case 1718909296:
                      case 1920099697:
                      case 1919251232:
                      case 1768449138:
                        break;
                      default:
                        var headerType = String.fromCharCode(tbox >> 24 & 255, tbox >> 16 & 255, tbox >> 8 & 255, tbox & 255);
                        (0, _util.warn)("Unsupported header type " + tbox + " (" + headerType + ")");
                        break;
                    }
                    if (jumpDataLength) {
                      position += dataLength;
                    }
                  }
                },
                parseImageProperties: function JpxImage_parseImageProperties(stream) {
                  var newByte = stream.getByte();
                  while (newByte >= 0) {
                    var oldByte = newByte;
                    newByte = stream.getByte();
                    var code = oldByte << 8 | newByte;
                    if (code === 65361) {
                      stream.skip(4);
                      var Xsiz = stream.getInt32() >>> 0;
                      var Ysiz = stream.getInt32() >>> 0;
                      var XOsiz = stream.getInt32() >>> 0;
                      var YOsiz = stream.getInt32() >>> 0;
                      stream.skip(16);
                      var Csiz = stream.getUint16();
                      this.width = Xsiz - XOsiz;
                      this.height = Ysiz - YOsiz;
                      this.componentsCount = Csiz;
                      this.bitsPerComponent = 8;
                      return;
                    }
                  }
                  throw new JpxError("No size marker found in JPX stream");
                },
                parseCodestream: function JpxImage_parseCodestream(data, start, end) {
                  var context = {};
                  var doNotRecover = false;
                  try {
                    var position = start;
                    while (position + 1 < end) {
                      var code = (0, _util.readUint16)(data, position);
                      position += 2;
                      var length = 0, j, sqcd, spqcds, spqcdSize, scalarExpounded, tile;
                      switch (code) {
                        case 65359:
                          context.mainHeader = true;
                          break;
                        case 65497:
                          break;
                        case 65361:
                          length = (0, _util.readUint16)(data, position);
                          var siz = {};
                          siz.Xsiz = (0, _util.readUint32)(data, position + 4);
                          siz.Ysiz = (0, _util.readUint32)(data, position + 8);
                          siz.XOsiz = (0, _util.readUint32)(data, position + 12);
                          siz.YOsiz = (0, _util.readUint32)(data, position + 16);
                          siz.XTsiz = (0, _util.readUint32)(data, position + 20);
                          siz.YTsiz = (0, _util.readUint32)(data, position + 24);
                          siz.XTOsiz = (0, _util.readUint32)(data, position + 28);
                          siz.YTOsiz = (0, _util.readUint32)(data, position + 32);
                          var componentsCount = (0, _util.readUint16)(data, position + 36);
                          siz.Csiz = componentsCount;
                          var components = [];
                          j = position + 38;
                          for (var i = 0; i < componentsCount; i++) {
                            var component = {
                              precision: (data[j] & 127) + 1,
                              isSigned: !!(data[j] & 128),
                              XRsiz: data[j + 1],
                              YRsiz: data[j + 1]
                            };
                            calculateComponentDimensions(component, siz);
                            components.push(component);
                          }
                          context.SIZ = siz;
                          context.components = components;
                          calculateTileGrids(context, components);
                          context.QCC = [];
                          context.COC = [];
                          break;
                        case 65372:
                          length = (0, _util.readUint16)(data, position);
                          var qcd = {};
                          j = position + 2;
                          sqcd = data[j++];
                          switch (sqcd & 31) {
                            case 0:
                              spqcdSize = 8;
                              scalarExpounded = true;
                              break;
                            case 1:
                              spqcdSize = 16;
                              scalarExpounded = false;
                              break;
                            case 2:
                              spqcdSize = 16;
                              scalarExpounded = true;
                              break;
                            default:
                              throw new Error("Invalid SQcd value " + sqcd);
                          }
                          qcd.noQuantization = spqcdSize === 8;
                          qcd.scalarExpounded = scalarExpounded;
                          qcd.guardBits = sqcd >> 5;
                          spqcds = [];
                          while (j < length + position) {
                            var spqcd = {};
                            if (spqcdSize === 8) {
                              spqcd.epsilon = data[j++] >> 3;
                              spqcd.mu = 0;
                            } else {
                              spqcd.epsilon = data[j] >> 3;
                              spqcd.mu = (data[j] & 7) << 8 | data[j + 1];
                              j += 2;
                            }
                            spqcds.push(spqcd);
                          }
                          qcd.SPqcds = spqcds;
                          if (context.mainHeader) {
                            context.QCD = qcd;
                          } else {
                            context.currentTile.QCD = qcd;
                            context.currentTile.QCC = [];
                          }
                          break;
                        case 65373:
                          length = (0, _util.readUint16)(data, position);
                          var qcc = {};
                          j = position + 2;
                          var cqcc;
                          if (context.SIZ.Csiz < 257) {
                            cqcc = data[j++];
                          } else {
                            cqcc = (0, _util.readUint16)(data, j);
                            j += 2;
                          }
                          sqcd = data[j++];
                          switch (sqcd & 31) {
                            case 0:
                              spqcdSize = 8;
                              scalarExpounded = true;
                              break;
                            case 1:
                              spqcdSize = 16;
                              scalarExpounded = false;
                              break;
                            case 2:
                              spqcdSize = 16;
                              scalarExpounded = true;
                              break;
                            default:
                              throw new Error("Invalid SQcd value " + sqcd);
                          }
                          qcc.noQuantization = spqcdSize === 8;
                          qcc.scalarExpounded = scalarExpounded;
                          qcc.guardBits = sqcd >> 5;
                          spqcds = [];
                          while (j < length + position) {
                            spqcd = {};
                            if (spqcdSize === 8) {
                              spqcd.epsilon = data[j++] >> 3;
                              spqcd.mu = 0;
                            } else {
                              spqcd.epsilon = data[j] >> 3;
                              spqcd.mu = (data[j] & 7) << 8 | data[j + 1];
                              j += 2;
                            }
                            spqcds.push(spqcd);
                          }
                          qcc.SPqcds = spqcds;
                          if (context.mainHeader) {
                            context.QCC[cqcc] = qcc;
                          } else {
                            context.currentTile.QCC[cqcc] = qcc;
                          }
                          break;
                        case 65362:
                          length = (0, _util.readUint16)(data, position);
                          var cod = {};
                          j = position + 2;
                          var scod = data[j++];
                          cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
                          cod.sopMarkerUsed = !!(scod & 2);
                          cod.ephMarkerUsed = !!(scod & 4);
                          cod.progressionOrder = data[j++];
                          cod.layersCount = (0, _util.readUint16)(data, j);
                          j += 2;
                          cod.multipleComponentTransform = data[j++];
                          cod.decompositionLevelsCount = data[j++];
                          cod.xcb = (data[j++] & 15) + 2;
                          cod.ycb = (data[j++] & 15) + 2;
                          var blockStyle = data[j++];
                          cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
                          cod.resetContextProbabilities = !!(blockStyle & 2);
                          cod.terminationOnEachCodingPass = !!(blockStyle & 4);
                          cod.verticalyStripe = !!(blockStyle & 8);
                          cod.predictableTermination = !!(blockStyle & 16);
                          cod.segmentationSymbolUsed = !!(blockStyle & 32);
                          cod.reversibleTransformation = data[j++];
                          if (cod.entropyCoderWithCustomPrecincts) {
                            var precinctsSizes = [];
                            while (j < length + position) {
                              var precinctsSize = data[j++];
                              precinctsSizes.push({
                                PPx: precinctsSize & 15,
                                PPy: precinctsSize >> 4
                              });
                            }
                            cod.precinctsSizes = precinctsSizes;
                          }
                          var unsupported = [];
                          if (cod.selectiveArithmeticCodingBypass) {
                            unsupported.push("selectiveArithmeticCodingBypass");
                          }
                          if (cod.resetContextProbabilities) {
                            unsupported.push("resetContextProbabilities");
                          }
                          if (cod.terminationOnEachCodingPass) {
                            unsupported.push("terminationOnEachCodingPass");
                          }
                          if (cod.verticalyStripe) {
                            unsupported.push("verticalyStripe");
                          }
                          if (cod.predictableTermination) {
                            unsupported.push("predictableTermination");
                          }
                          if (unsupported.length > 0) {
                            doNotRecover = true;
                            throw new Error("Unsupported COD options (" + unsupported.join(", ") + ")");
                          }
                          if (context.mainHeader) {
                            context.COD = cod;
                          } else {
                            context.currentTile.COD = cod;
                            context.currentTile.COC = [];
                          }
                          break;
                        case 65424:
                          length = (0, _util.readUint16)(data, position);
                          tile = {};
                          tile.index = (0, _util.readUint16)(data, position + 2);
                          tile.length = (0, _util.readUint32)(data, position + 4);
                          tile.dataEnd = tile.length + position - 2;
                          tile.partIndex = data[position + 8];
                          tile.partsCount = data[position + 9];
                          context.mainHeader = false;
                          if (tile.partIndex === 0) {
                            tile.COD = context.COD;
                            tile.COC = context.COC.slice(0);
                            tile.QCD = context.QCD;
                            tile.QCC = context.QCC.slice(0);
                          }
                          context.currentTile = tile;
                          break;
                        case 65427:
                          tile = context.currentTile;
                          if (tile.partIndex === 0) {
                            initializeTile(context, tile.index);
                            buildPackets(context);
                          }
                          length = tile.dataEnd - position;
                          parseTilePackets(context, data, position, length);
                          break;
                        case 65365:
                        case 65367:
                        case 65368:
                        case 65380:
                          length = (0, _util.readUint16)(data, position);
                          break;
                        case 65363:
                          throw new Error("Codestream code 0xFF53 (COC) is not implemented");
                        default:
                          throw new Error("Unknown codestream code: " + code.toString(16));
                      }
                      position += length;
                    }
                  } catch (e) {
                    if (doNotRecover || this.failOnCorruptedImage) {
                      throw new JpxError(e.message);
                    } else {
                      (0, _util.warn)("JPX: Trying to recover from: " + e.message);
                    }
                  }
                  this.tiles = transformComponents(context);
                  this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
                  this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
                  this.componentsCount = context.SIZ.Csiz;
                }
              };
              function calculateComponentDimensions(component, siz) {
                component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
                component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
                component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
                component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
                component.width = component.x1 - component.x0;
                component.height = component.y1 - component.y0;
              }
              function calculateTileGrids(context, components) {
                var siz = context.SIZ;
                var tile, tiles = [];
                var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
                var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
                for (var q = 0; q < numYtiles; q++) {
                  for (var p = 0; p < numXtiles; p++) {
                    tile = {};
                    tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
                    tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
                    tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
                    tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
                    tile.width = tile.tx1 - tile.tx0;
                    tile.height = tile.ty1 - tile.ty0;
                    tile.components = [];
                    tiles.push(tile);
                  }
                }
                context.tiles = tiles;
                var componentsCount = siz.Csiz;
                for (var i = 0, ii = componentsCount; i < ii; i++) {
                  var component = components[i];
                  for (var j = 0, jj = tiles.length; j < jj; j++) {
                    var tileComponent = {};
                    tile = tiles[j];
                    tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
                    tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
                    tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
                    tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
                    tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
                    tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
                    tile.components[i] = tileComponent;
                  }
                }
              }
              function getBlocksDimensions(context, component, r) {
                var codOrCoc = component.codingStyleParameters;
                var result = {};
                if (!codOrCoc.entropyCoderWithCustomPrecincts) {
                  result.PPx = 15;
                  result.PPy = 15;
                } else {
                  result.PPx = codOrCoc.precinctsSizes[r].PPx;
                  result.PPy = codOrCoc.precinctsSizes[r].PPy;
                }
                result.xcb_ = r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) : Math.min(codOrCoc.xcb, result.PPx);
                result.ycb_ = r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) : Math.min(codOrCoc.ycb, result.PPy);
                return result;
              }
              function buildPrecincts(context, resolution, dimensions) {
                var precinctWidth = 1 << dimensions.PPx;
                var precinctHeight = 1 << dimensions.PPy;
                var isZeroRes = resolution.resLevel === 0;
                var precinctWidthInSubband = 1 << dimensions.PPx + (isZeroRes ? 0 : -1);
                var precinctHeightInSubband = 1 << dimensions.PPy + (isZeroRes ? 0 : -1);
                var numprecinctswide = resolution.trx1 > resolution.trx0 ? Math.ceil(resolution.trx1 / precinctWidth) - Math.floor(resolution.trx0 / precinctWidth) : 0;
                var numprecinctshigh = resolution.try1 > resolution.try0 ? Math.ceil(resolution.try1 / precinctHeight) - Math.floor(resolution.try0 / precinctHeight) : 0;
                var numprecincts = numprecinctswide * numprecinctshigh;
                resolution.precinctParameters = {
                  precinctWidth,
                  precinctHeight,
                  numprecinctswide,
                  numprecinctshigh,
                  numprecincts,
                  precinctWidthInSubband,
                  precinctHeightInSubband
                };
              }
              function buildCodeblocks(context, subband, dimensions) {
                var xcb_ = dimensions.xcb_;
                var ycb_ = dimensions.ycb_;
                var codeblockWidth = 1 << xcb_;
                var codeblockHeight = 1 << ycb_;
                var cbx0 = subband.tbx0 >> xcb_;
                var cby0 = subband.tby0 >> ycb_;
                var cbx1 = subband.tbx1 + codeblockWidth - 1 >> xcb_;
                var cby1 = subband.tby1 + codeblockHeight - 1 >> ycb_;
                var precinctParameters = subband.resolution.precinctParameters;
                var codeblocks = [];
                var precincts = [];
                var i, j, codeblock, precinctNumber;
                for (j = cby0; j < cby1; j++) {
                  for (i = cbx0; i < cbx1; i++) {
                    codeblock = {
                      cbx: i,
                      cby: j,
                      tbx0: codeblockWidth * i,
                      tby0: codeblockHeight * j,
                      tbx1: codeblockWidth * (i + 1),
                      tby1: codeblockHeight * (j + 1)
                    };
                    codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
                    codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
                    codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
                    codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);
                    var pi = Math.floor((codeblock.tbx0_ - subband.tbx0) / precinctParameters.precinctWidthInSubband);
                    var pj = Math.floor((codeblock.tby0_ - subband.tby0) / precinctParameters.precinctHeightInSubband);
                    precinctNumber = pi + pj * precinctParameters.numprecinctswide;
                    codeblock.precinctNumber = precinctNumber;
                    codeblock.subbandType = subband.type;
                    codeblock.Lblock = 3;
                    if (codeblock.tbx1_ <= codeblock.tbx0_ || codeblock.tby1_ <= codeblock.tby0_) {
                      continue;
                    }
                    codeblocks.push(codeblock);
                    var precinct = precincts[precinctNumber];
                    if (precinct !== void 0) {
                      if (i < precinct.cbxMin) {
                        precinct.cbxMin = i;
                      } else if (i > precinct.cbxMax) {
                        precinct.cbxMax = i;
                      }
                      if (j < precinct.cbyMin) {
                        precinct.cbxMin = j;
                      } else if (j > precinct.cbyMax) {
                        precinct.cbyMax = j;
                      }
                    } else {
                      precincts[precinctNumber] = precinct = {
                        cbxMin: i,
                        cbyMin: j,
                        cbxMax: i,
                        cbyMax: j
                      };
                    }
                    codeblock.precinct = precinct;
                  }
                }
                subband.codeblockParameters = {
                  codeblockWidth: xcb_,
                  codeblockHeight: ycb_,
                  numcodeblockwide: cbx1 - cbx0 + 1,
                  numcodeblockhigh: cby1 - cby0 + 1
                };
                subband.codeblocks = codeblocks;
                subband.precincts = precincts;
              }
              function createPacket(resolution, precinctNumber, layerNumber) {
                var precinctCodeblocks = [];
                var subbands = resolution.subbands;
                for (var i = 0, ii = subbands.length; i < ii; i++) {
                  var subband = subbands[i];
                  var codeblocks = subband.codeblocks;
                  for (var j = 0, jj = codeblocks.length; j < jj; j++) {
                    var codeblock = codeblocks[j];
                    if (codeblock.precinctNumber !== precinctNumber) {
                      continue;
                    }
                    precinctCodeblocks.push(codeblock);
                  }
                }
                return {
                  layerNumber,
                  codeblocks: precinctCodeblocks
                };
              }
              function LayerResolutionComponentPositionIterator(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var layersCount = tile.codingStyleDefaultParameters.layersCount;
                var componentsCount = siz.Csiz;
                var maxDecompositionLevelsCount = 0;
                for (var q = 0; q < componentsCount; q++) {
                  maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
                }
                var l = 0, r = 0, i = 0, k = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; l < layersCount; l++) {
                    for (; r <= maxDecompositionLevelsCount; r++) {
                      for (; i < componentsCount; i++) {
                        var component = tile.components[i];
                        if (r > component.codingStyleParameters.decompositionLevelsCount) {
                          continue;
                        }
                        var resolution = component.resolutions[r];
                        var numprecincts = resolution.precinctParameters.numprecincts;
                        for (; k < numprecincts; ) {
                          var packet = createPacket(resolution, k, l);
                          k++;
                          return packet;
                        }
                        k = 0;
                      }
                      i = 0;
                    }
                    r = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function ResolutionLayerComponentPositionIterator(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var layersCount = tile.codingStyleDefaultParameters.layersCount;
                var componentsCount = siz.Csiz;
                var maxDecompositionLevelsCount = 0;
                for (var q = 0; q < componentsCount; q++) {
                  maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, tile.components[q].codingStyleParameters.decompositionLevelsCount);
                }
                var r = 0, l = 0, i = 0, k = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; r <= maxDecompositionLevelsCount; r++) {
                    for (; l < layersCount; l++) {
                      for (; i < componentsCount; i++) {
                        var component = tile.components[i];
                        if (r > component.codingStyleParameters.decompositionLevelsCount) {
                          continue;
                        }
                        var resolution = component.resolutions[r];
                        var numprecincts = resolution.precinctParameters.numprecincts;
                        for (; k < numprecincts; ) {
                          var packet = createPacket(resolution, k, l);
                          k++;
                          return packet;
                        }
                        k = 0;
                      }
                      i = 0;
                    }
                    l = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function ResolutionPositionComponentLayerIterator(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var layersCount = tile.codingStyleDefaultParameters.layersCount;
                var componentsCount = siz.Csiz;
                var l, r, c, p;
                var maxDecompositionLevelsCount = 0;
                for (c = 0; c < componentsCount; c++) {
                  var component = tile.components[c];
                  maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount, component.codingStyleParameters.decompositionLevelsCount);
                }
                var maxNumPrecinctsInLevel = new Int32Array(maxDecompositionLevelsCount + 1);
                for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
                  var maxNumPrecincts = 0;
                  for (c = 0; c < componentsCount; ++c) {
                    var resolutions = tile.components[c].resolutions;
                    if (r < resolutions.length) {
                      maxNumPrecincts = Math.max(maxNumPrecincts, resolutions[r].precinctParameters.numprecincts);
                    }
                  }
                  maxNumPrecinctsInLevel[r] = maxNumPrecincts;
                }
                l = 0;
                r = 0;
                c = 0;
                p = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; r <= maxDecompositionLevelsCount; r++) {
                    for (; p < maxNumPrecinctsInLevel[r]; p++) {
                      for (; c < componentsCount; c++) {
                        var component2 = tile.components[c];
                        if (r > component2.codingStyleParameters.decompositionLevelsCount) {
                          continue;
                        }
                        var resolution = component2.resolutions[r];
                        var numprecincts = resolution.precinctParameters.numprecincts;
                        if (p >= numprecincts) {
                          continue;
                        }
                        for (; l < layersCount; ) {
                          var packet = createPacket(resolution, p, l);
                          l++;
                          return packet;
                        }
                        l = 0;
                      }
                      c = 0;
                    }
                    p = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function PositionComponentResolutionLayerIterator(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var layersCount = tile.codingStyleDefaultParameters.layersCount;
                var componentsCount = siz.Csiz;
                var precinctsSizes = getPrecinctSizesInImageScale(tile);
                var precinctsIterationSizes = precinctsSizes;
                var l = 0, r = 0, c = 0, px = 0, py = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; py < precinctsIterationSizes.maxNumHigh; py++) {
                    for (; px < precinctsIterationSizes.maxNumWide; px++) {
                      for (; c < componentsCount; c++) {
                        var component = tile.components[c];
                        var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                        for (; r <= decompositionLevelsCount; r++) {
                          var resolution = component.resolutions[r];
                          var sizeInImageScale = precinctsSizes.components[c].resolutions[r];
                          var k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
                          if (k === null) {
                            continue;
                          }
                          for (; l < layersCount; ) {
                            var packet = createPacket(resolution, k, l);
                            l++;
                            return packet;
                          }
                          l = 0;
                        }
                        r = 0;
                      }
                      c = 0;
                    }
                    px = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function ComponentPositionResolutionLayerIterator(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var layersCount = tile.codingStyleDefaultParameters.layersCount;
                var componentsCount = siz.Csiz;
                var precinctsSizes = getPrecinctSizesInImageScale(tile);
                var l = 0, r = 0, c = 0, px = 0, py = 0;
                this.nextPacket = function JpxImage_nextPacket() {
                  for (; c < componentsCount; ++c) {
                    var component = tile.components[c];
                    var precinctsIterationSizes = precinctsSizes.components[c];
                    var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                    for (; py < precinctsIterationSizes.maxNumHigh; py++) {
                      for (; px < precinctsIterationSizes.maxNumWide; px++) {
                        for (; r <= decompositionLevelsCount; r++) {
                          var resolution = component.resolutions[r];
                          var sizeInImageScale = precinctsIterationSizes.resolutions[r];
                          var k = getPrecinctIndexIfExist(px, py, sizeInImageScale, precinctsIterationSizes, resolution);
                          if (k === null) {
                            continue;
                          }
                          for (; l < layersCount; ) {
                            var packet = createPacket(resolution, k, l);
                            l++;
                            return packet;
                          }
                          l = 0;
                        }
                        r = 0;
                      }
                      px = 0;
                    }
                    py = 0;
                  }
                  throw new JpxError("Out of packets");
                };
              }
              function getPrecinctIndexIfExist(pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
                var posX = pxIndex * precinctIterationSizes.minWidth;
                var posY = pyIndex * precinctIterationSizes.minHeight;
                if (posX % sizeInImageScale.width !== 0 || posY % sizeInImageScale.height !== 0) {
                  return null;
                }
                var startPrecinctRowIndex = posY / sizeInImageScale.width * resolution.precinctParameters.numprecinctswide;
                return posX / sizeInImageScale.height + startPrecinctRowIndex;
              }
              function getPrecinctSizesInImageScale(tile) {
                var componentsCount = tile.components.length;
                var minWidth = Number.MAX_VALUE;
                var minHeight = Number.MAX_VALUE;
                var maxNumWide = 0;
                var maxNumHigh = 0;
                var sizePerComponent = new Array(componentsCount);
                for (var c = 0; c < componentsCount; c++) {
                  var component = tile.components[c];
                  var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                  var sizePerResolution = new Array(decompositionLevelsCount + 1);
                  var minWidthCurrentComponent = Number.MAX_VALUE;
                  var minHeightCurrentComponent = Number.MAX_VALUE;
                  var maxNumWideCurrentComponent = 0;
                  var maxNumHighCurrentComponent = 0;
                  var scale = 1;
                  for (var r = decompositionLevelsCount; r >= 0; --r) {
                    var resolution = component.resolutions[r];
                    var widthCurrentResolution = scale * resolution.precinctParameters.precinctWidth;
                    var heightCurrentResolution = scale * resolution.precinctParameters.precinctHeight;
                    minWidthCurrentComponent = Math.min(minWidthCurrentComponent, widthCurrentResolution);
                    minHeightCurrentComponent = Math.min(minHeightCurrentComponent, heightCurrentResolution);
                    maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent, resolution.precinctParameters.numprecinctswide);
                    maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent, resolution.precinctParameters.numprecinctshigh);
                    sizePerResolution[r] = {
                      width: widthCurrentResolution,
                      height: heightCurrentResolution
                    };
                    scale <<= 1;
                  }
                  minWidth = Math.min(minWidth, minWidthCurrentComponent);
                  minHeight = Math.min(minHeight, minHeightCurrentComponent);
                  maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
                  maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
                  sizePerComponent[c] = {
                    resolutions: sizePerResolution,
                    minWidth: minWidthCurrentComponent,
                    minHeight: minHeightCurrentComponent,
                    maxNumWide: maxNumWideCurrentComponent,
                    maxNumHigh: maxNumHighCurrentComponent
                  };
                }
                return {
                  components: sizePerComponent,
                  minWidth,
                  minHeight,
                  maxNumWide,
                  maxNumHigh
                };
              }
              function buildPackets(context) {
                var siz = context.SIZ;
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var componentsCount = siz.Csiz;
                for (var c = 0; c < componentsCount; c++) {
                  var component = tile.components[c];
                  var decompositionLevelsCount = component.codingStyleParameters.decompositionLevelsCount;
                  var resolutions = [];
                  var subbands = [];
                  for (var r = 0; r <= decompositionLevelsCount; r++) {
                    var blocksDimensions = getBlocksDimensions(context, component, r);
                    var resolution = {};
                    var scale = 1 << decompositionLevelsCount - r;
                    resolution.trx0 = Math.ceil(component.tcx0 / scale);
                    resolution.try0 = Math.ceil(component.tcy0 / scale);
                    resolution.trx1 = Math.ceil(component.tcx1 / scale);
                    resolution.try1 = Math.ceil(component.tcy1 / scale);
                    resolution.resLevel = r;
                    buildPrecincts(context, resolution, blocksDimensions);
                    resolutions.push(resolution);
                    var subband;
                    if (r === 0) {
                      subband = {};
                      subband.type = "LL";
                      subband.tbx0 = Math.ceil(component.tcx0 / scale);
                      subband.tby0 = Math.ceil(component.tcy0 / scale);
                      subband.tbx1 = Math.ceil(component.tcx1 / scale);
                      subband.tby1 = Math.ceil(component.tcy1 / scale);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolution.subbands = [subband];
                    } else {
                      var bscale = 1 << decompositionLevelsCount - r + 1;
                      var resolutionSubbands = [];
                      subband = {};
                      subband.type = "HL";
                      subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
                      subband.tby0 = Math.ceil(component.tcy0 / bscale);
                      subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
                      subband.tby1 = Math.ceil(component.tcy1 / bscale);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolutionSubbands.push(subband);
                      subband = {};
                      subband.type = "LH";
                      subband.tbx0 = Math.ceil(component.tcx0 / bscale);
                      subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
                      subband.tbx1 = Math.ceil(component.tcx1 / bscale);
                      subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolutionSubbands.push(subband);
                      subband = {};
                      subband.type = "HH";
                      subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
                      subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
                      subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
                      subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
                      subband.resolution = resolution;
                      buildCodeblocks(context, subband, blocksDimensions);
                      subbands.push(subband);
                      resolutionSubbands.push(subband);
                      resolution.subbands = resolutionSubbands;
                    }
                  }
                  component.resolutions = resolutions;
                  component.subbands = subbands;
                }
                var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
                switch (progressionOrder) {
                  case 0:
                    tile.packetsIterator = new LayerResolutionComponentPositionIterator(context);
                    break;
                  case 1:
                    tile.packetsIterator = new ResolutionLayerComponentPositionIterator(context);
                    break;
                  case 2:
                    tile.packetsIterator = new ResolutionPositionComponentLayerIterator(context);
                    break;
                  case 3:
                    tile.packetsIterator = new PositionComponentResolutionLayerIterator(context);
                    break;
                  case 4:
                    tile.packetsIterator = new ComponentPositionResolutionLayerIterator(context);
                    break;
                  default:
                    throw new JpxError("Unsupported progression order " + progressionOrder);
                }
              }
              function parseTilePackets(context, data, offset, dataLength) {
                var position = 0;
                var buffer, bufferSize = 0, skipNextBit = false;
                function readBits(count) {
                  while (bufferSize < count) {
                    var b = data[offset + position];
                    position++;
                    if (skipNextBit) {
                      buffer = buffer << 7 | b;
                      bufferSize += 7;
                      skipNextBit = false;
                    } else {
                      buffer = buffer << 8 | b;
                      bufferSize += 8;
                    }
                    if (b === 255) {
                      skipNextBit = true;
                    }
                  }
                  bufferSize -= count;
                  return buffer >>> bufferSize & (1 << count) - 1;
                }
                function skipMarkerIfEqual(value) {
                  if (data[offset + position - 1] === 255 && data[offset + position] === value) {
                    skipBytes(1);
                    return true;
                  } else if (data[offset + position] === 255 && data[offset + position + 1] === value) {
                    skipBytes(2);
                    return true;
                  }
                  return false;
                }
                function skipBytes(count) {
                  position += count;
                }
                function alignToByte() {
                  bufferSize = 0;
                  if (skipNextBit) {
                    position++;
                    skipNextBit = false;
                  }
                }
                function readCodingpasses() {
                  if (readBits(1) === 0) {
                    return 1;
                  }
                  if (readBits(1) === 0) {
                    return 2;
                  }
                  var value = readBits(2);
                  if (value < 3) {
                    return value + 3;
                  }
                  value = readBits(5);
                  if (value < 31) {
                    return value + 6;
                  }
                  value = readBits(7);
                  return value + 37;
                }
                var tileIndex = context.currentTile.index;
                var tile = context.tiles[tileIndex];
                var sopMarkerUsed = context.COD.sopMarkerUsed;
                var ephMarkerUsed = context.COD.ephMarkerUsed;
                var packetsIterator = tile.packetsIterator;
                while (position < dataLength) {
                  alignToByte();
                  if (sopMarkerUsed && skipMarkerIfEqual(145)) {
                    skipBytes(4);
                  }
                  var packet = packetsIterator.nextPacket();
                  if (!readBits(1)) {
                    continue;
                  }
                  var layerNumber = packet.layerNumber;
                  var queue = [], codeblock;
                  for (var i = 0, ii = packet.codeblocks.length; i < ii; i++) {
                    codeblock = packet.codeblocks[i];
                    var precinct = codeblock.precinct;
                    var codeblockColumn = codeblock.cbx - precinct.cbxMin;
                    var codeblockRow = codeblock.cby - precinct.cbyMin;
                    var codeblockIncluded = false;
                    var firstTimeInclusion = false;
                    var valueReady;
                    if (codeblock["included"] !== void 0) {
                      codeblockIncluded = !!readBits(1);
                    } else {
                      precinct = codeblock.precinct;
                      var inclusionTree, zeroBitPlanesTree;
                      if (precinct["inclusionTree"] !== void 0) {
                        inclusionTree = precinct.inclusionTree;
                      } else {
                        var width = precinct.cbxMax - precinct.cbxMin + 1;
                        var height = precinct.cbyMax - precinct.cbyMin + 1;
                        inclusionTree = new InclusionTree(width, height, layerNumber);
                        zeroBitPlanesTree = new TagTree(width, height);
                        precinct.inclusionTree = inclusionTree;
                        precinct.zeroBitPlanesTree = zeroBitPlanesTree;
                      }
                      if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {
                        while (true) {
                          if (readBits(1)) {
                            valueReady = !inclusionTree.nextLevel();
                            if (valueReady) {
                              codeblock.included = true;
                              codeblockIncluded = firstTimeInclusion = true;
                              break;
                            }
                          } else {
                            inclusionTree.incrementValue(layerNumber);
                            break;
                          }
                        }
                      }
                    }
                    if (!codeblockIncluded) {
                      continue;
                    }
                    if (firstTimeInclusion) {
                      zeroBitPlanesTree = precinct.zeroBitPlanesTree;
                      zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
                      while (true) {
                        if (readBits(1)) {
                          valueReady = !zeroBitPlanesTree.nextLevel();
                          if (valueReady) {
                            break;
                          }
                        } else {
                          zeroBitPlanesTree.incrementValue();
                        }
                      }
                      codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
                    }
                    var codingpasses = readCodingpasses();
                    while (readBits(1)) {
                      codeblock.Lblock++;
                    }
                    var codingpassesLog2 = (0, _util.log2)(codingpasses);
                    var bits = (codingpasses < 1 << codingpassesLog2 ? codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
                    var codedDataLength = readBits(bits);
                    queue.push({
                      codeblock,
                      codingpasses,
                      dataLength: codedDataLength
                    });
                  }
                  alignToByte();
                  if (ephMarkerUsed) {
                    skipMarkerIfEqual(146);
                  }
                  while (queue.length > 0) {
                    var packetItem = queue.shift();
                    codeblock = packetItem.codeblock;
                    if (codeblock["data"] === void 0) {
                      codeblock.data = [];
                    }
                    codeblock.data.push({
                      data,
                      start: offset + position,
                      end: offset + position + packetItem.dataLength,
                      codingpasses: packetItem.codingpasses
                    });
                    position += packetItem.dataLength;
                  }
                }
                return position;
              }
              function copyCoefficients(coefficients, levelWidth, levelHeight, subband, delta, mb, reversible, segmentationSymbolUsed) {
                var x0 = subband.tbx0;
                var y0 = subband.tby0;
                var width = subband.tbx1 - subband.tbx0;
                var codeblocks = subband.codeblocks;
                var right = subband.type.charAt(0) === "H" ? 1 : 0;
                var bottom = subband.type.charAt(1) === "H" ? levelWidth : 0;
                for (var i = 0, ii = codeblocks.length; i < ii; ++i) {
                  var codeblock = codeblocks[i];
                  var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
                  var blockHeight = codeblock.tby1_ - codeblock.tby0_;
                  if (blockWidth === 0 || blockHeight === 0) {
                    continue;
                  }
                  if (codeblock["data"] === void 0) {
                    continue;
                  }
                  var bitModel, currentCodingpassType;
                  bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType, codeblock.zeroBitPlanes, mb);
                  currentCodingpassType = 2;
                  var data = codeblock.data, totalLength = 0, codingpasses = 0;
                  var j, jj, dataItem;
                  for (j = 0, jj = data.length; j < jj; j++) {
                    dataItem = data[j];
                    totalLength += dataItem.end - dataItem.start;
                    codingpasses += dataItem.codingpasses;
                  }
                  var encodedData = new Uint8Array(totalLength);
                  var position = 0;
                  for (j = 0, jj = data.length; j < jj; j++) {
                    dataItem = data[j];
                    var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
                    encodedData.set(chunk, position);
                    position += chunk.length;
                  }
                  var decoder = new _arithmetic_decoder.ArithmeticDecoder(encodedData, 0, totalLength);
                  bitModel.setDecoder(decoder);
                  for (j = 0; j < codingpasses; j++) {
                    switch (currentCodingpassType) {
                      case 0:
                        bitModel.runSignificancePropagationPass();
                        break;
                      case 1:
                        bitModel.runMagnitudeRefinementPass();
                        break;
                      case 2:
                        bitModel.runCleanupPass();
                        if (segmentationSymbolUsed) {
                          bitModel.checkSegmentationSymbol();
                        }
                        break;
                    }
                    currentCodingpassType = (currentCodingpassType + 1) % 3;
                  }
                  var offset = codeblock.tbx0_ - x0 + (codeblock.tby0_ - y0) * width;
                  var sign = bitModel.coefficentsSign;
                  var magnitude = bitModel.coefficentsMagnitude;
                  var bitsDecoded = bitModel.bitsDecoded;
                  var magnitudeCorrection = reversible ? 0 : 0.5;
                  var k, n, nb;
                  position = 0;
                  var interleave = subband.type !== "LL";
                  for (j = 0; j < blockHeight; j++) {
                    var row = offset / width | 0;
                    var levelOffset = 2 * row * (levelWidth - width) + right + bottom;
                    for (k = 0; k < blockWidth; k++) {
                      n = magnitude[position];
                      if (n !== 0) {
                        n = (n + magnitudeCorrection) * delta;
                        if (sign[position] !== 0) {
                          n = -n;
                        }
                        nb = bitsDecoded[position];
                        var pos = interleave ? levelOffset + (offset << 1) : offset;
                        if (reversible && nb >= mb) {
                          coefficients[pos] = n;
                        } else {
                          coefficients[pos] = n * (1 << mb - nb);
                        }
                      }
                      offset++;
                      position++;
                    }
                    offset += width - blockWidth;
                  }
                }
              }
              function transformTile(context, tile, c) {
                var component = tile.components[c];
                var codingStyleParameters = component.codingStyleParameters;
                var quantizationParameters = component.quantizationParameters;
                var decompositionLevelsCount = codingStyleParameters.decompositionLevelsCount;
                var spqcds = quantizationParameters.SPqcds;
                var scalarExpounded = quantizationParameters.scalarExpounded;
                var guardBits = quantizationParameters.guardBits;
                var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
                var precision = context.components[c].precision;
                var reversible = codingStyleParameters.reversibleTransformation;
                var transform = reversible ? new ReversibleTransform() : new IrreversibleTransform();
                var subbandCoefficients = [];
                var b = 0;
                for (var i = 0; i <= decompositionLevelsCount; i++) {
                  var resolution = component.resolutions[i];
                  var width = resolution.trx1 - resolution.trx0;
                  var height = resolution.try1 - resolution.try0;
                  var coefficients = new Float32Array(width * height);
                  for (var j = 0, jj = resolution.subbands.length; j < jj; j++) {
                    var mu, epsilon;
                    if (!scalarExpounded) {
                      mu = spqcds[0].mu;
                      epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
                    } else {
                      mu = spqcds[b].mu;
                      epsilon = spqcds[b].epsilon;
                      b++;
                    }
                    var subband = resolution.subbands[j];
                    var gainLog2 = SubbandsGainLog2[subband.type];
                    var delta = reversible ? 1 : Math.pow(2, precision + gainLog2 - epsilon) * (1 + mu / 2048);
                    var mb = guardBits + epsilon - 1;
                    copyCoefficients(coefficients, width, height, subband, delta, mb, reversible, segmentationSymbolUsed);
                  }
                  subbandCoefficients.push({
                    width,
                    height,
                    items: coefficients
                  });
                }
                var result = transform.calculate(subbandCoefficients, component.tcx0, component.tcy0);
                return {
                  left: component.tcx0,
                  top: component.tcy0,
                  width: result.width,
                  height: result.height,
                  items: result.items
                };
              }
              function transformComponents(context) {
                var siz = context.SIZ;
                var components = context.components;
                var componentsCount = siz.Csiz;
                var resultImages = [];
                for (var i = 0, ii = context.tiles.length; i < ii; i++) {
                  var tile = context.tiles[i];
                  var transformedTiles = [];
                  var c;
                  for (c = 0; c < componentsCount; c++) {
                    transformedTiles[c] = transformTile(context, tile, c);
                  }
                  var tile0 = transformedTiles[0];
                  var out = new Uint8ClampedArray(tile0.items.length * componentsCount);
                  var result = {
                    left: tile0.left,
                    top: tile0.top,
                    width: tile0.width,
                    height: tile0.height,
                    items: out
                  };
                  var shift, offset;
                  var pos = 0, j, jj, y0, y1, y2;
                  if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
                    var fourComponents = componentsCount === 4;
                    var y0items = transformedTiles[0].items;
                    var y1items = transformedTiles[1].items;
                    var y2items = transformedTiles[2].items;
                    var y3items = fourComponents ? transformedTiles[3].items : null;
                    shift = components[0].precision - 8;
                    offset = (128 << shift) + 0.5;
                    var component0 = tile.components[0];
                    var alpha01 = componentsCount - 3;
                    jj = y0items.length;
                    if (!component0.codingStyleParameters.reversibleTransformation) {
                      for (j = 0; j < jj; j++, pos += alpha01) {
                        y0 = y0items[j] + offset;
                        y1 = y1items[j];
                        y2 = y2items[j];
                        out[pos++] = y0 + 1.402 * y2 >> shift;
                        out[pos++] = y0 - 0.34413 * y1 - 0.71414 * y2 >> shift;
                        out[pos++] = y0 + 1.772 * y1 >> shift;
                      }
                    } else {
                      for (j = 0; j < jj; j++, pos += alpha01) {
                        y0 = y0items[j] + offset;
                        y1 = y1items[j];
                        y2 = y2items[j];
                        var g = y0 - (y2 + y1 >> 2);
                        out[pos++] = g + y2 >> shift;
                        out[pos++] = g >> shift;
                        out[pos++] = g + y1 >> shift;
                      }
                    }
                    if (fourComponents) {
                      for (j = 0, pos = 3; j < jj; j++, pos += 4) {
                        out[pos] = y3items[j] + offset >> shift;
                      }
                    }
                  } else {
                    for (c = 0; c < componentsCount; c++) {
                      var items = transformedTiles[c].items;
                      shift = components[c].precision - 8;
                      offset = (128 << shift) + 0.5;
                      for (pos = c, j = 0, jj = items.length; j < jj; j++) {
                        out[pos] = items[j] + offset >> shift;
                        pos += componentsCount;
                      }
                    }
                  }
                  resultImages.push(result);
                }
                return resultImages;
              }
              function initializeTile(context, tileIndex) {
                var siz = context.SIZ;
                var componentsCount = siz.Csiz;
                var tile = context.tiles[tileIndex];
                for (var c = 0; c < componentsCount; c++) {
                  var component = tile.components[c];
                  var qcdOrQcc = context.currentTile.QCC[c] !== void 0 ? context.currentTile.QCC[c] : context.currentTile.QCD;
                  component.quantizationParameters = qcdOrQcc;
                  var codOrCoc = context.currentTile.COC[c] !== void 0 ? context.currentTile.COC[c] : context.currentTile.COD;
                  component.codingStyleParameters = codOrCoc;
                }
                tile.codingStyleDefaultParameters = context.currentTile.COD;
              }
              var TagTree = function TagTreeClosure() {
                function TagTree2(width, height) {
                  var levelsLength = (0, _util.log2)(Math.max(width, height)) + 1;
                  this.levels = [];
                  for (var i = 0; i < levelsLength; i++) {
                    var level = {
                      width,
                      height,
                      items: []
                    };
                    this.levels.push(level);
                    width = Math.ceil(width / 2);
                    height = Math.ceil(height / 2);
                  }
                }
                TagTree2.prototype = {
                  reset: function TagTree_reset(i, j) {
                    var currentLevel = 0, value = 0, level;
                    while (currentLevel < this.levels.length) {
                      level = this.levels[currentLevel];
                      var index = i + j * level.width;
                      if (level.items[index] !== void 0) {
                        value = level.items[index];
                        break;
                      }
                      level.index = index;
                      i >>= 1;
                      j >>= 1;
                      currentLevel++;
                    }
                    currentLevel--;
                    level = this.levels[currentLevel];
                    level.items[level.index] = value;
                    this.currentLevel = currentLevel;
                    delete this.value;
                  },
                  incrementValue: function TagTree_incrementValue() {
                    var level = this.levels[this.currentLevel];
                    level.items[level.index]++;
                  },
                  nextLevel: function TagTree_nextLevel() {
                    var currentLevel = this.currentLevel;
                    var level = this.levels[currentLevel];
                    var value = level.items[level.index];
                    currentLevel--;
                    if (currentLevel < 0) {
                      this.value = value;
                      return false;
                    }
                    this.currentLevel = currentLevel;
                    level = this.levels[currentLevel];
                    level.items[level.index] = value;
                    return true;
                  }
                };
                return TagTree2;
              }();
              var InclusionTree = function InclusionTreeClosure() {
                function InclusionTree2(width, height, defaultValue) {
                  var levelsLength = (0, _util.log2)(Math.max(width, height)) + 1;
                  this.levels = [];
                  for (var i = 0; i < levelsLength; i++) {
                    var items = new Uint8Array(width * height);
                    for (var j = 0, jj = items.length; j < jj; j++) {
                      items[j] = defaultValue;
                    }
                    var level = {
                      width,
                      height,
                      items
                    };
                    this.levels.push(level);
                    width = Math.ceil(width / 2);
                    height = Math.ceil(height / 2);
                  }
                }
                InclusionTree2.prototype = {
                  reset: function InclusionTree_reset(i, j, stopValue) {
                    var currentLevel = 0;
                    while (currentLevel < this.levels.length) {
                      var level = this.levels[currentLevel];
                      var index = i + j * level.width;
                      level.index = index;
                      var value = level.items[index];
                      if (value === 255) {
                        break;
                      }
                      if (value > stopValue) {
                        this.currentLevel = currentLevel;
                        this.propagateValues();
                        return false;
                      }
                      i >>= 1;
                      j >>= 1;
                      currentLevel++;
                    }
                    this.currentLevel = currentLevel - 1;
                    return true;
                  },
                  incrementValue: function InclusionTree_incrementValue(stopValue) {
                    var level = this.levels[this.currentLevel];
                    level.items[level.index] = stopValue + 1;
                    this.propagateValues();
                  },
                  propagateValues: function InclusionTree_propagateValues() {
                    var levelIndex = this.currentLevel;
                    var level = this.levels[levelIndex];
                    var currentValue = level.items[level.index];
                    while (--levelIndex >= 0) {
                      level = this.levels[levelIndex];
                      level.items[level.index] = currentValue;
                    }
                  },
                  nextLevel: function InclusionTree_nextLevel() {
                    var currentLevel = this.currentLevel;
                    var level = this.levels[currentLevel];
                    var value = level.items[level.index];
                    level.items[level.index] = 255;
                    currentLevel--;
                    if (currentLevel < 0) {
                      return false;
                    }
                    this.currentLevel = currentLevel;
                    level = this.levels[currentLevel];
                    level.items[level.index] = value;
                    return true;
                  }
                };
                return InclusionTree2;
              }();
              var BitModel = function BitModelClosure() {
                var UNIFORM_CONTEXT = 17;
                var RUNLENGTH_CONTEXT = 18;
                var LLAndLHContextsLabel = new Uint8Array([0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8]);
                var HLContextLabel = new Uint8Array([0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8]);
                var HHContextLabel = new Uint8Array([0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5, 5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8]);
                function BitModel2(width, height, subband, zeroBitPlanes, mb) {
                  this.width = width;
                  this.height = height;
                  this.contextLabelTable = subband === "HH" ? HHContextLabel : subband === "HL" ? HLContextLabel : LLAndLHContextsLabel;
                  var coefficientCount = width * height;
                  this.neighborsSignificance = new Uint8Array(coefficientCount);
                  this.coefficentsSign = new Uint8Array(coefficientCount);
                  this.coefficentsMagnitude = mb > 14 ? new Uint32Array(coefficientCount) : mb > 6 ? new Uint16Array(coefficientCount) : new Uint8Array(coefficientCount);
                  this.processingFlags = new Uint8Array(coefficientCount);
                  var bitsDecoded = new Uint8Array(coefficientCount);
                  if (zeroBitPlanes !== 0) {
                    for (var i = 0; i < coefficientCount; i++) {
                      bitsDecoded[i] = zeroBitPlanes;
                    }
                  }
                  this.bitsDecoded = bitsDecoded;
                  this.reset();
                }
                BitModel2.prototype = {
                  setDecoder: function BitModel_setDecoder(decoder) {
                    this.decoder = decoder;
                  },
                  reset: function BitModel_reset() {
                    this.contexts = new Int8Array(19);
                    this.contexts[0] = 4 << 1 | 0;
                    this.contexts[UNIFORM_CONTEXT] = 46 << 1 | 0;
                    this.contexts[RUNLENGTH_CONTEXT] = 3 << 1 | 0;
                  },
                  setNeighborsSignificance: function BitModel_setNeighborsSignificance(row, column, index) {
                    var neighborsSignificance = this.neighborsSignificance;
                    var width = this.width, height = this.height;
                    var left = column > 0;
                    var right = column + 1 < width;
                    var i;
                    if (row > 0) {
                      i = index - width;
                      if (left) {
                        neighborsSignificance[i - 1] += 16;
                      }
                      if (right) {
                        neighborsSignificance[i + 1] += 16;
                      }
                      neighborsSignificance[i] += 4;
                    }
                    if (row + 1 < height) {
                      i = index + width;
                      if (left) {
                        neighborsSignificance[i - 1] += 16;
                      }
                      if (right) {
                        neighborsSignificance[i + 1] += 16;
                      }
                      neighborsSignificance[i] += 4;
                    }
                    if (left) {
                      neighborsSignificance[index - 1] += 1;
                    }
                    if (right) {
                      neighborsSignificance[index + 1] += 1;
                    }
                    neighborsSignificance[index] |= 128;
                  },
                  runSignificancePropagationPass: function BitModel_runSignificancePropagationPass() {
                    var decoder = this.decoder;
                    var width = this.width, height = this.height;
                    var coefficentsMagnitude = this.coefficentsMagnitude;
                    var coefficentsSign = this.coefficentsSign;
                    var neighborsSignificance = this.neighborsSignificance;
                    var processingFlags = this.processingFlags;
                    var contexts = this.contexts;
                    var labels = this.contextLabelTable;
                    var bitsDecoded = this.bitsDecoded;
                    var processedInverseMask = ~1;
                    var processedMask = 1;
                    var firstMagnitudeBitMask = 2;
                    for (var i0 = 0; i0 < height; i0 += 4) {
                      for (var j = 0; j < width; j++) {
                        var index = i0 * width + j;
                        for (var i1 = 0; i1 < 4; i1++, index += width) {
                          var i = i0 + i1;
                          if (i >= height) {
                            break;
                          }
                          processingFlags[index] &= processedInverseMask;
                          if (coefficentsMagnitude[index] || !neighborsSignificance[index]) {
                            continue;
                          }
                          var contextLabel = labels[neighborsSignificance[index]];
                          var decision = decoder.readBit(contexts, contextLabel);
                          if (decision) {
                            var sign = this.decodeSignBit(i, j, index);
                            coefficentsSign[index] = sign;
                            coefficentsMagnitude[index] = 1;
                            this.setNeighborsSignificance(i, j, index);
                            processingFlags[index] |= firstMagnitudeBitMask;
                          }
                          bitsDecoded[index]++;
                          processingFlags[index] |= processedMask;
                        }
                      }
                    }
                  },
                  decodeSignBit: function BitModel_decodeSignBit(row, column, index) {
                    var width = this.width, height = this.height;
                    var coefficentsMagnitude = this.coefficentsMagnitude;
                    var coefficentsSign = this.coefficentsSign;
                    var contribution, sign0, sign1, significance1;
                    var contextLabel, decoded;
                    significance1 = column > 0 && coefficentsMagnitude[index - 1] !== 0;
                    if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
                      sign1 = coefficentsSign[index + 1];
                      if (significance1) {
                        sign0 = coefficentsSign[index - 1];
                        contribution = 1 - sign1 - sign0;
                      } else {
                        contribution = 1 - sign1 - sign1;
                      }
                    } else if (significance1) {
                      sign0 = coefficentsSign[index - 1];
                      contribution = 1 - sign0 - sign0;
                    } else {
                      contribution = 0;
                    }
                    var horizontalContribution = 3 * contribution;
                    significance1 = row > 0 && coefficentsMagnitude[index - width] !== 0;
                    if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
                      sign1 = coefficentsSign[index + width];
                      if (significance1) {
                        sign0 = coefficentsSign[index - width];
                        contribution = 1 - sign1 - sign0 + horizontalContribution;
                      } else {
                        contribution = 1 - sign1 - sign1 + horizontalContribution;
                      }
                    } else if (significance1) {
                      sign0 = coefficentsSign[index - width];
                      contribution = 1 - sign0 - sign0 + horizontalContribution;
                    } else {
                      contribution = horizontalContribution;
                    }
                    if (contribution >= 0) {
                      contextLabel = 9 + contribution;
                      decoded = this.decoder.readBit(this.contexts, contextLabel);
                    } else {
                      contextLabel = 9 - contribution;
                      decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
                    }
                    return decoded;
                  },
                  runMagnitudeRefinementPass: function BitModel_runMagnitudeRefinementPass() {
                    var decoder = this.decoder;
                    var width = this.width, height = this.height;
                    var coefficentsMagnitude = this.coefficentsMagnitude;
                    var neighborsSignificance = this.neighborsSignificance;
                    var contexts = this.contexts;
                    var bitsDecoded = this.bitsDecoded;
                    var processingFlags = this.processingFlags;
                    var processedMask = 1;
                    var firstMagnitudeBitMask = 2;
                    var length = width * height;
                    var width4 = width * 4;
                    for (var index0 = 0, indexNext; index0 < length; index0 = indexNext) {
                      indexNext = Math.min(length, index0 + width4);
                      for (var j = 0; j < width; j++) {
                        for (var index = index0 + j; index < indexNext; index += width) {
                          if (!coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                            continue;
                          }
                          var contextLabel = 16;
                          if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
                            processingFlags[index] ^= firstMagnitudeBitMask;
                            var significance = neighborsSignificance[index] & 127;
                            contextLabel = significance === 0 ? 15 : 14;
                          }
                          var bit = decoder.readBit(contexts, contextLabel);
                          coefficentsMagnitude[index] = coefficentsMagnitude[index] << 1 | bit;
                          bitsDecoded[index]++;
                          processingFlags[index] |= processedMask;
                        }
                      }
                    }
                  },
                  runCleanupPass: function BitModel_runCleanupPass() {
                    var decoder = this.decoder;
                    var width = this.width, height = this.height;
                    var neighborsSignificance = this.neighborsSignificance;
                    var coefficentsMagnitude = this.coefficentsMagnitude;
                    var coefficentsSign = this.coefficentsSign;
                    var contexts = this.contexts;
                    var labels = this.contextLabelTable;
                    var bitsDecoded = this.bitsDecoded;
                    var processingFlags = this.processingFlags;
                    var processedMask = 1;
                    var firstMagnitudeBitMask = 2;
                    var oneRowDown = width;
                    var twoRowsDown = width * 2;
                    var threeRowsDown = width * 3;
                    var iNext;
                    for (var i0 = 0; i0 < height; i0 = iNext) {
                      iNext = Math.min(i0 + 4, height);
                      var indexBase = i0 * width;
                      var checkAllEmpty = i0 + 3 < height;
                      for (var j = 0; j < width; j++) {
                        var index0 = indexBase + j;
                        var allEmpty = checkAllEmpty && processingFlags[index0] === 0 && processingFlags[index0 + oneRowDown] === 0 && processingFlags[index0 + twoRowsDown] === 0 && processingFlags[index0 + threeRowsDown] === 0 && neighborsSignificance[index0] === 0 && neighborsSignificance[index0 + oneRowDown] === 0 && neighborsSignificance[index0 + twoRowsDown] === 0 && neighborsSignificance[index0 + threeRowsDown] === 0;
                        var i1 = 0, index = index0;
                        var i = i0, sign;
                        if (allEmpty) {
                          var hasSignificantCoefficent = decoder.readBit(contexts, RUNLENGTH_CONTEXT);
                          if (!hasSignificantCoefficent) {
                            bitsDecoded[index0]++;
                            bitsDecoded[index0 + oneRowDown]++;
                            bitsDecoded[index0 + twoRowsDown]++;
                            bitsDecoded[index0 + threeRowsDown]++;
                            continue;
                          }
                          i1 = decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);
                          if (i1 !== 0) {
                            i = i0 + i1;
                            index += i1 * width;
                          }
                          sign = this.decodeSignBit(i, j, index);
                          coefficentsSign[index] = sign;
                          coefficentsMagnitude[index] = 1;
                          this.setNeighborsSignificance(i, j, index);
                          processingFlags[index] |= firstMagnitudeBitMask;
                          index = index0;
                          for (var i2 = i0; i2 <= i; i2++, index += width) {
                            bitsDecoded[index]++;
                          }
                          i1++;
                        }
                        for (i = i0 + i1; i < iNext; i++, index += width) {
                          if (coefficentsMagnitude[index] || (processingFlags[index] & processedMask) !== 0) {
                            continue;
                          }
                          var contextLabel = labels[neighborsSignificance[index]];
                          var decision = decoder.readBit(contexts, contextLabel);
                          if (decision === 1) {
                            sign = this.decodeSignBit(i, j, index);
                            coefficentsSign[index] = sign;
                            coefficentsMagnitude[index] = 1;
                            this.setNeighborsSignificance(i, j, index);
                            processingFlags[index] |= firstMagnitudeBitMask;
                          }
                          bitsDecoded[index]++;
                        }
                      }
                    }
                  },
                  checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {
                    var decoder = this.decoder;
                    var contexts = this.contexts;
                    var symbol = decoder.readBit(contexts, UNIFORM_CONTEXT) << 3 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 2 | decoder.readBit(contexts, UNIFORM_CONTEXT) << 1 | decoder.readBit(contexts, UNIFORM_CONTEXT);
                    if (symbol !== 10) {
                      throw new JpxError("Invalid segmentation symbol");
                    }
                  }
                };
                return BitModel2;
              }();
              var Transform = function TransformClosure() {
                function Transform2() {
                }
                Transform2.prototype.calculate = function transformCalculate(subbands, u0, v0) {
                  var ll = subbands[0];
                  for (var i = 1, ii = subbands.length; i < ii; i++) {
                    ll = this.iterate(ll, subbands[i], u0, v0);
                  }
                  return ll;
                };
                Transform2.prototype.extend = function extend(buffer, offset, size) {
                  var i1 = offset - 1, j1 = offset + 1;
                  var i2 = offset + size - 2, j2 = offset + size;
                  buffer[i1--] = buffer[j1++];
                  buffer[j2++] = buffer[i2--];
                  buffer[i1--] = buffer[j1++];
                  buffer[j2++] = buffer[i2--];
                  buffer[i1--] = buffer[j1++];
                  buffer[j2++] = buffer[i2--];
                  buffer[i1] = buffer[j1];
                  buffer[j2] = buffer[i2];
                };
                Transform2.prototype.iterate = function Transform_iterate(ll, hl_lh_hh, u0, v0) {
                  var llWidth = ll.width, llHeight = ll.height, llItems = ll.items;
                  var width = hl_lh_hh.width;
                  var height = hl_lh_hh.height;
                  var items = hl_lh_hh.items;
                  var i, j, k, l, u, v;
                  for (k = 0, i = 0; i < llHeight; i++) {
                    l = i * 2 * width;
                    for (j = 0; j < llWidth; j++, k++, l += 2) {
                      items[l] = llItems[k];
                    }
                  }
                  llItems = ll.items = null;
                  var bufferPadding = 4;
                  var rowBuffer = new Float32Array(width + 2 * bufferPadding);
                  if (width === 1) {
                    if ((u0 & 1) !== 0) {
                      for (v = 0, k = 0; v < height; v++, k += width) {
                        items[k] *= 0.5;
                      }
                    }
                  } else {
                    for (v = 0, k = 0; v < height; v++, k += width) {
                      rowBuffer.set(items.subarray(k, k + width), bufferPadding);
                      this.extend(rowBuffer, bufferPadding, width);
                      this.filter(rowBuffer, bufferPadding, width);
                      items.set(rowBuffer.subarray(bufferPadding, bufferPadding + width), k);
                    }
                  }
                  var numBuffers = 16;
                  var colBuffers = [];
                  for (i = 0; i < numBuffers; i++) {
                    colBuffers.push(new Float32Array(height + 2 * bufferPadding));
                  }
                  var b, currentBuffer = 0;
                  ll = bufferPadding + height;
                  if (height === 1) {
                    if ((v0 & 1) !== 0) {
                      for (u = 0; u < width; u++) {
                        items[u] *= 0.5;
                      }
                    }
                  } else {
                    for (u = 0; u < width; u++) {
                      if (currentBuffer === 0) {
                        numBuffers = Math.min(width - u, numBuffers);
                        for (k = u, l = bufferPadding; l < ll; k += width, l++) {
                          for (b = 0; b < numBuffers; b++) {
                            colBuffers[b][l] = items[k + b];
                          }
                        }
                        currentBuffer = numBuffers;
                      }
                      currentBuffer--;
                      var buffer = colBuffers[currentBuffer];
                      this.extend(buffer, bufferPadding, height);
                      this.filter(buffer, bufferPadding, height);
                      if (currentBuffer === 0) {
                        k = u - numBuffers + 1;
                        for (l = bufferPadding; l < ll; k += width, l++) {
                          for (b = 0; b < numBuffers; b++) {
                            items[k + b] = colBuffers[b][l];
                          }
                        }
                      }
                    }
                  }
                  return {
                    width,
                    height,
                    items
                  };
                };
                return Transform2;
              }();
              var IrreversibleTransform = function IrreversibleTransformClosure() {
                function IrreversibleTransform2() {
                  Transform.call(this);
                }
                IrreversibleTransform2.prototype = Object.create(Transform.prototype);
                IrreversibleTransform2.prototype.filter = function irreversibleTransformFilter(x, offset, length) {
                  var len = length >> 1;
                  offset = offset | 0;
                  var j, n, current, next;
                  var alpha = -1.586134342059924;
                  var beta = -0.052980118572961;
                  var gamma = 0.882911075530934;
                  var delta = 0.443506852043971;
                  var K = 1.230174104914001;
                  var K_ = 1 / K;
                  j = offset - 3;
                  for (n = len + 4; n--; j += 2) {
                    x[j] *= K_;
                  }
                  j = offset - 2;
                  current = delta * x[j - 1];
                  for (n = len + 3; n--; j += 2) {
                    next = delta * x[j + 1];
                    x[j] = K * x[j] - current - next;
                    if (n--) {
                      j += 2;
                      current = delta * x[j + 1];
                      x[j] = K * x[j] - current - next;
                    } else {
                      break;
                    }
                  }
                  j = offset - 1;
                  current = gamma * x[j - 1];
                  for (n = len + 2; n--; j += 2) {
                    next = gamma * x[j + 1];
                    x[j] -= current + next;
                    if (n--) {
                      j += 2;
                      current = gamma * x[j + 1];
                      x[j] -= current + next;
                    } else {
                      break;
                    }
                  }
                  j = offset;
                  current = beta * x[j - 1];
                  for (n = len + 1; n--; j += 2) {
                    next = beta * x[j + 1];
                    x[j] -= current + next;
                    if (n--) {
                      j += 2;
                      current = beta * x[j + 1];
                      x[j] -= current + next;
                    } else {
                      break;
                    }
                  }
                  if (len !== 0) {
                    j = offset + 1;
                    current = alpha * x[j - 1];
                    for (n = len; n--; j += 2) {
                      next = alpha * x[j + 1];
                      x[j] -= current + next;
                      if (n--) {
                        j += 2;
                        current = alpha * x[j + 1];
                        x[j] -= current + next;
                      } else {
                        break;
                      }
                    }
                  }
                };
                return IrreversibleTransform2;
              }();
              var ReversibleTransform = function ReversibleTransformClosure() {
                function ReversibleTransform2() {
                  Transform.call(this);
                }
                ReversibleTransform2.prototype = Object.create(Transform.prototype);
                ReversibleTransform2.prototype.filter = function reversibleTransformFilter(x, offset, length) {
                  var len = length >> 1;
                  offset = offset | 0;
                  var j, n;
                  for (j = offset, n = len + 1; n--; j += 2) {
                    x[j] -= x[j - 1] + x[j + 1] + 2 >> 2;
                  }
                  for (j = offset + 1, n = len; n--; j += 2) {
                    x[j] += x[j - 1] + x[j + 1] >> 1;
                  }
                };
                return ReversibleTransform2;
              }();
              return JpxImage2;
            }();
            exports2.JpxImage = JpxImage;
          },
          /* 75 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var ArithmeticDecoder = function ArithmeticDecoderClosure() {
              var QeTable = [{
                qe: 22017,
                nmps: 1,
                nlps: 1,
                switchFlag: 1
              }, {
                qe: 13313,
                nmps: 2,
                nlps: 6,
                switchFlag: 0
              }, {
                qe: 6145,
                nmps: 3,
                nlps: 9,
                switchFlag: 0
              }, {
                qe: 2753,
                nmps: 4,
                nlps: 12,
                switchFlag: 0
              }, {
                qe: 1313,
                nmps: 5,
                nlps: 29,
                switchFlag: 0
              }, {
                qe: 545,
                nmps: 38,
                nlps: 33,
                switchFlag: 0
              }, {
                qe: 22017,
                nmps: 7,
                nlps: 6,
                switchFlag: 1
              }, {
                qe: 21505,
                nmps: 8,
                nlps: 14,
                switchFlag: 0
              }, {
                qe: 18433,
                nmps: 9,
                nlps: 14,
                switchFlag: 0
              }, {
                qe: 14337,
                nmps: 10,
                nlps: 14,
                switchFlag: 0
              }, {
                qe: 12289,
                nmps: 11,
                nlps: 17,
                switchFlag: 0
              }, {
                qe: 9217,
                nmps: 12,
                nlps: 18,
                switchFlag: 0
              }, {
                qe: 7169,
                nmps: 13,
                nlps: 20,
                switchFlag: 0
              }, {
                qe: 5633,
                nmps: 29,
                nlps: 21,
                switchFlag: 0
              }, {
                qe: 22017,
                nmps: 15,
                nlps: 14,
                switchFlag: 1
              }, {
                qe: 21505,
                nmps: 16,
                nlps: 14,
                switchFlag: 0
              }, {
                qe: 20737,
                nmps: 17,
                nlps: 15,
                switchFlag: 0
              }, {
                qe: 18433,
                nmps: 18,
                nlps: 16,
                switchFlag: 0
              }, {
                qe: 14337,
                nmps: 19,
                nlps: 17,
                switchFlag: 0
              }, {
                qe: 13313,
                nmps: 20,
                nlps: 18,
                switchFlag: 0
              }, {
                qe: 12289,
                nmps: 21,
                nlps: 19,
                switchFlag: 0
              }, {
                qe: 10241,
                nmps: 22,
                nlps: 19,
                switchFlag: 0
              }, {
                qe: 9217,
                nmps: 23,
                nlps: 20,
                switchFlag: 0
              }, {
                qe: 8705,
                nmps: 24,
                nlps: 21,
                switchFlag: 0
              }, {
                qe: 7169,
                nmps: 25,
                nlps: 22,
                switchFlag: 0
              }, {
                qe: 6145,
                nmps: 26,
                nlps: 23,
                switchFlag: 0
              }, {
                qe: 5633,
                nmps: 27,
                nlps: 24,
                switchFlag: 0
              }, {
                qe: 5121,
                nmps: 28,
                nlps: 25,
                switchFlag: 0
              }, {
                qe: 4609,
                nmps: 29,
                nlps: 26,
                switchFlag: 0
              }, {
                qe: 4353,
                nmps: 30,
                nlps: 27,
                switchFlag: 0
              }, {
                qe: 2753,
                nmps: 31,
                nlps: 28,
                switchFlag: 0
              }, {
                qe: 2497,
                nmps: 32,
                nlps: 29,
                switchFlag: 0
              }, {
                qe: 2209,
                nmps: 33,
                nlps: 30,
                switchFlag: 0
              }, {
                qe: 1313,
                nmps: 34,
                nlps: 31,
                switchFlag: 0
              }, {
                qe: 1089,
                nmps: 35,
                nlps: 32,
                switchFlag: 0
              }, {
                qe: 673,
                nmps: 36,
                nlps: 33,
                switchFlag: 0
              }, {
                qe: 545,
                nmps: 37,
                nlps: 34,
                switchFlag: 0
              }, {
                qe: 321,
                nmps: 38,
                nlps: 35,
                switchFlag: 0
              }, {
                qe: 273,
                nmps: 39,
                nlps: 36,
                switchFlag: 0
              }, {
                qe: 133,
                nmps: 40,
                nlps: 37,
                switchFlag: 0
              }, {
                qe: 73,
                nmps: 41,
                nlps: 38,
                switchFlag: 0
              }, {
                qe: 37,
                nmps: 42,
                nlps: 39,
                switchFlag: 0
              }, {
                qe: 21,
                nmps: 43,
                nlps: 40,
                switchFlag: 0
              }, {
                qe: 9,
                nmps: 44,
                nlps: 41,
                switchFlag: 0
              }, {
                qe: 5,
                nmps: 45,
                nlps: 42,
                switchFlag: 0
              }, {
                qe: 1,
                nmps: 45,
                nlps: 43,
                switchFlag: 0
              }, {
                qe: 22017,
                nmps: 46,
                nlps: 46,
                switchFlag: 0
              }];
              function ArithmeticDecoder2(data, start, end) {
                this.data = data;
                this.bp = start;
                this.dataEnd = end;
                this.chigh = data[start];
                this.clow = 0;
                this.byteIn();
                this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127;
                this.clow = this.clow << 7 & 65535;
                this.ct -= 7;
                this.a = 32768;
              }
              ArithmeticDecoder2.prototype = {
                byteIn: function ArithmeticDecoder_byteIn() {
                  var data = this.data;
                  var bp = this.bp;
                  if (data[bp] === 255) {
                    var b1 = data[bp + 1];
                    if (b1 > 143) {
                      this.clow += 65280;
                      this.ct = 8;
                    } else {
                      bp++;
                      this.clow += data[bp] << 9;
                      this.ct = 7;
                      this.bp = bp;
                    }
                  } else {
                    bp++;
                    this.clow += bp < this.dataEnd ? data[bp] << 8 : 65280;
                    this.ct = 8;
                    this.bp = bp;
                  }
                  if (this.clow > 65535) {
                    this.chigh += this.clow >> 16;
                    this.clow &= 65535;
                  }
                },
                readBit: function ArithmeticDecoder_readBit(contexts, pos) {
                  var cx_index = contexts[pos] >> 1, cx_mps = contexts[pos] & 1;
                  var qeTableIcx = QeTable[cx_index];
                  var qeIcx = qeTableIcx.qe;
                  var d;
                  var a = this.a - qeIcx;
                  if (this.chigh < qeIcx) {
                    if (a < qeIcx) {
                      a = qeIcx;
                      d = cx_mps;
                      cx_index = qeTableIcx.nmps;
                    } else {
                      a = qeIcx;
                      d = 1 ^ cx_mps;
                      if (qeTableIcx.switchFlag === 1) {
                        cx_mps = d;
                      }
                      cx_index = qeTableIcx.nlps;
                    }
                  } else {
                    this.chigh -= qeIcx;
                    if ((a & 32768) !== 0) {
                      this.a = a;
                      return cx_mps;
                    }
                    if (a < qeIcx) {
                      d = 1 ^ cx_mps;
                      if (qeTableIcx.switchFlag === 1) {
                        cx_mps = d;
                      }
                      cx_index = qeTableIcx.nlps;
                    } else {
                      d = cx_mps;
                      cx_index = qeTableIcx.nmps;
                    }
                  }
                  do {
                    if (this.ct === 0) {
                      this.byteIn();
                    }
                    a <<= 1;
                    this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1;
                    this.clow = this.clow << 1 & 65535;
                    this.ct--;
                  } while ((a & 32768) === 0);
                  this.a = a;
                  contexts[pos] = cx_index << 1 | cx_mps;
                  return d;
                }
              };
              return ArithmeticDecoder2;
            }();
            exports2.ArithmeticDecoder = ArithmeticDecoder;
          },
          /* 76 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.calculateSHA512 = exports2.calculateSHA384 = exports2.calculateSHA256 = exports2.calculateMD5 = exports2.PDF20 = exports2.PDF17 = exports2.CipherTransformFactory = exports2.ARCFourCipher = exports2.AES256Cipher = exports2.AES128Cipher = void 0;
            var _util = __w_pdfjs_require__(0);
            var _primitives = __w_pdfjs_require__(2);
            var _stream = __w_pdfjs_require__(5);
            var ARCFourCipher = function ARCFourCipherClosure() {
              function ARCFourCipher2(key) {
                this.a = 0;
                this.b = 0;
                var s = new Uint8Array(256);
                var i, j = 0, tmp, keyLength = key.length;
                for (i = 0; i < 256; ++i) {
                  s[i] = i;
                }
                for (i = 0; i < 256; ++i) {
                  tmp = s[i];
                  j = j + tmp + key[i % keyLength] & 255;
                  s[i] = s[j];
                  s[j] = tmp;
                }
                this.s = s;
              }
              ARCFourCipher2.prototype = {
                encryptBlock: function ARCFourCipher_encryptBlock(data) {
                  var i, n = data.length, tmp, tmp2;
                  var a = this.a, b = this.b, s = this.s;
                  var output = new Uint8Array(n);
                  for (i = 0; i < n; ++i) {
                    a = a + 1 & 255;
                    tmp = s[a];
                    b = b + tmp & 255;
                    tmp2 = s[b];
                    s[a] = tmp2;
                    s[b] = tmp;
                    output[i] = data[i] ^ s[tmp + tmp2 & 255];
                  }
                  this.a = a;
                  this.b = b;
                  return output;
                }
              };
              ARCFourCipher2.prototype.decryptBlock = ARCFourCipher2.prototype.encryptBlock;
              return ARCFourCipher2;
            }();
            var calculateMD5 = function calculateMD5Closure() {
              var r = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
              var k = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
              function hash(data, offset, length) {
                var h0 = 1732584193, h1 = -271733879, h2 = -1732584194, h3 = 271733878;
                var paddedLength = length + 72 & ~63;
                var padded = new Uint8Array(paddedLength);
                var i, j, n;
                for (i = 0; i < length; ++i) {
                  padded[i] = data[offset++];
                }
                padded[i++] = 128;
                n = paddedLength - 8;
                while (i < n) {
                  padded[i++] = 0;
                }
                padded[i++] = length << 3 & 255;
                padded[i++] = length >> 5 & 255;
                padded[i++] = length >> 13 & 255;
                padded[i++] = length >> 21 & 255;
                padded[i++] = length >>> 29 & 255;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                var w = new Int32Array(16);
                for (i = 0; i < paddedLength; ) {
                  for (j = 0; j < 16; ++j, i += 4) {
                    w[j] = padded[i] | padded[i + 1] << 8 | padded[i + 2] << 16 | padded[i + 3] << 24;
                  }
                  var a = h0, b = h1, c = h2, d = h3, f, g;
                  for (j = 0; j < 64; ++j) {
                    if (j < 16) {
                      f = b & c | ~b & d;
                      g = j;
                    } else if (j < 32) {
                      f = d & b | ~d & c;
                      g = 5 * j + 1 & 15;
                    } else if (j < 48) {
                      f = b ^ c ^ d;
                      g = 3 * j + 5 & 15;
                    } else {
                      f = c ^ (b | ~d);
                      g = 7 * j & 15;
                    }
                    var tmp = d, rotateArg = a + f + k[j] + w[g] | 0, rotate = r[j];
                    d = c;
                    c = b;
                    b = b + (rotateArg << rotate | rotateArg >>> 32 - rotate) | 0;
                    a = tmp;
                  }
                  h0 = h0 + a | 0;
                  h1 = h1 + b | 0;
                  h2 = h2 + c | 0;
                  h3 = h3 + d | 0;
                }
                return new Uint8Array([h0 & 255, h0 >> 8 & 255, h0 >> 16 & 255, h0 >>> 24 & 255, h1 & 255, h1 >> 8 & 255, h1 >> 16 & 255, h1 >>> 24 & 255, h2 & 255, h2 >> 8 & 255, h2 >> 16 & 255, h2 >>> 24 & 255, h3 & 255, h3 >> 8 & 255, h3 >> 16 & 255, h3 >>> 24 & 255]);
              }
              return hash;
            }();
            var Word64 = function Word64Closure() {
              function Word642(highInteger, lowInteger) {
                this.high = highInteger | 0;
                this.low = lowInteger | 0;
              }
              Word642.prototype = {
                and: function Word64_and(word) {
                  this.high &= word.high;
                  this.low &= word.low;
                },
                xor: function Word64_xor(word) {
                  this.high ^= word.high;
                  this.low ^= word.low;
                },
                or: function Word64_or(word) {
                  this.high |= word.high;
                  this.low |= word.low;
                },
                shiftRight: function Word64_shiftRight(places) {
                  if (places >= 32) {
                    this.low = this.high >>> places - 32 | 0;
                    this.high = 0;
                  } else {
                    this.low = this.low >>> places | this.high << 32 - places;
                    this.high = this.high >>> places | 0;
                  }
                },
                shiftLeft: function Word64_shiftLeft(places) {
                  if (places >= 32) {
                    this.high = this.low << places - 32;
                    this.low = 0;
                  } else {
                    this.high = this.high << places | this.low >>> 32 - places;
                    this.low = this.low << places;
                  }
                },
                rotateRight: function Word64_rotateRight(places) {
                  var low, high;
                  if (places & 32) {
                    high = this.low;
                    low = this.high;
                  } else {
                    low = this.low;
                    high = this.high;
                  }
                  places &= 31;
                  this.low = low >>> places | high << 32 - places;
                  this.high = high >>> places | low << 32 - places;
                },
                not: function Word64_not() {
                  this.high = ~this.high;
                  this.low = ~this.low;
                },
                add: function Word64_add(word) {
                  var lowAdd = (this.low >>> 0) + (word.low >>> 0);
                  var highAdd = (this.high >>> 0) + (word.high >>> 0);
                  if (lowAdd > 4294967295) {
                    highAdd += 1;
                  }
                  this.low = lowAdd | 0;
                  this.high = highAdd | 0;
                },
                copyTo: function Word64_copyTo(bytes, offset) {
                  bytes[offset] = this.high >>> 24 & 255;
                  bytes[offset + 1] = this.high >> 16 & 255;
                  bytes[offset + 2] = this.high >> 8 & 255;
                  bytes[offset + 3] = this.high & 255;
                  bytes[offset + 4] = this.low >>> 24 & 255;
                  bytes[offset + 5] = this.low >> 16 & 255;
                  bytes[offset + 6] = this.low >> 8 & 255;
                  bytes[offset + 7] = this.low & 255;
                },
                assign: function Word64_assign(word) {
                  this.high = word.high;
                  this.low = word.low;
                }
              };
              return Word642;
            }();
            var calculateSHA256 = /* @__PURE__ */ function calculateSHA256Closure() {
              function rotr(x, n) {
                return x >>> n | x << 32 - n;
              }
              function ch(x, y, z) {
                return x & y ^ ~x & z;
              }
              function maj(x, y, z) {
                return x & y ^ x & z ^ y & z;
              }
              function sigma(x) {
                return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
              }
              function sigmaPrime(x) {
                return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
              }
              function littleSigma(x) {
                return rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
              }
              function littleSigmaPrime(x) {
                return rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
              }
              var k = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
              function hash(data, offset, length) {
                var h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762, h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
                var paddedLength = Math.ceil((length + 9) / 64) * 64;
                var padded = new Uint8Array(paddedLength);
                var i, j, n;
                for (i = 0; i < length; ++i) {
                  padded[i] = data[offset++];
                }
                padded[i++] = 128;
                n = paddedLength - 8;
                while (i < n) {
                  padded[i++] = 0;
                }
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = length >>> 29 & 255;
                padded[i++] = length >> 21 & 255;
                padded[i++] = length >> 13 & 255;
                padded[i++] = length >> 5 & 255;
                padded[i++] = length << 3 & 255;
                var w = new Uint32Array(64);
                for (i = 0; i < paddedLength; ) {
                  for (j = 0; j < 16; ++j) {
                    w[j] = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
                    i += 4;
                  }
                  for (j = 16; j < 64; ++j) {
                    w[j] = littleSigmaPrime(w[j - 2]) + w[j - 7] + littleSigma(w[j - 15]) + w[j - 16] | 0;
                  }
                  var a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, t1, t2;
                  for (j = 0; j < 64; ++j) {
                    t1 = h + sigmaPrime(e) + ch(e, f, g) + k[j] + w[j];
                    t2 = sigma(a) + maj(a, b, c);
                    h = g;
                    g = f;
                    f = e;
                    e = d + t1 | 0;
                    d = c;
                    c = b;
                    b = a;
                    a = t1 + t2 | 0;
                  }
                  h0 = h0 + a | 0;
                  h1 = h1 + b | 0;
                  h2 = h2 + c | 0;
                  h3 = h3 + d | 0;
                  h4 = h4 + e | 0;
                  h5 = h5 + f | 0;
                  h6 = h6 + g | 0;
                  h7 = h7 + h | 0;
                }
                return new Uint8Array([h0 >> 24 & 255, h0 >> 16 & 255, h0 >> 8 & 255, h0 & 255, h1 >> 24 & 255, h1 >> 16 & 255, h1 >> 8 & 255, h1 & 255, h2 >> 24 & 255, h2 >> 16 & 255, h2 >> 8 & 255, h2 & 255, h3 >> 24 & 255, h3 >> 16 & 255, h3 >> 8 & 255, h3 & 255, h4 >> 24 & 255, h4 >> 16 & 255, h4 >> 8 & 255, h4 & 255, h5 >> 24 & 255, h5 >> 16 & 255, h5 >> 8 & 255, h5 & 255, h6 >> 24 & 255, h6 >> 16 & 255, h6 >> 8 & 255, h6 & 255, h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255]);
              }
              return hash;
            }();
            var calculateSHA512 = function calculateSHA512Closure() {
              function ch(result, x, y, z, tmp) {
                result.assign(x);
                result.and(y);
                tmp.assign(x);
                tmp.not();
                tmp.and(z);
                result.xor(tmp);
              }
              function maj(result, x, y, z, tmp) {
                result.assign(x);
                result.and(y);
                tmp.assign(x);
                tmp.and(z);
                result.xor(tmp);
                tmp.assign(y);
                tmp.and(z);
                result.xor(tmp);
              }
              function sigma(result, x, tmp) {
                result.assign(x);
                result.rotateRight(28);
                tmp.assign(x);
                tmp.rotateRight(34);
                result.xor(tmp);
                tmp.assign(x);
                tmp.rotateRight(39);
                result.xor(tmp);
              }
              function sigmaPrime(result, x, tmp) {
                result.assign(x);
                result.rotateRight(14);
                tmp.assign(x);
                tmp.rotateRight(18);
                result.xor(tmp);
                tmp.assign(x);
                tmp.rotateRight(41);
                result.xor(tmp);
              }
              function littleSigma(result, x, tmp) {
                result.assign(x);
                result.rotateRight(1);
                tmp.assign(x);
                tmp.rotateRight(8);
                result.xor(tmp);
                tmp.assign(x);
                tmp.shiftRight(7);
                result.xor(tmp);
              }
              function littleSigmaPrime(result, x, tmp) {
                result.assign(x);
                result.rotateRight(19);
                tmp.assign(x);
                tmp.rotateRight(61);
                result.xor(tmp);
                tmp.assign(x);
                tmp.shiftRight(6);
                result.xor(tmp);
              }
              var k = [new Word64(1116352408, 3609767458), new Word64(1899447441, 602891725), new Word64(3049323471, 3964484399), new Word64(3921009573, 2173295548), new Word64(961987163, 4081628472), new Word64(1508970993, 3053834265), new Word64(2453635748, 2937671579), new Word64(2870763221, 3664609560), new Word64(3624381080, 2734883394), new Word64(310598401, 1164996542), new Word64(607225278, 1323610764), new Word64(1426881987, 3590304994), new Word64(1925078388, 4068182383), new Word64(2162078206, 991336113), new Word64(2614888103, 633803317), new Word64(3248222580, 3479774868), new Word64(3835390401, 2666613458), new Word64(4022224774, 944711139), new Word64(264347078, 2341262773), new Word64(604807628, 2007800933), new Word64(770255983, 1495990901), new Word64(1249150122, 1856431235), new Word64(1555081692, 3175218132), new Word64(1996064986, 2198950837), new Word64(2554220882, 3999719339), new Word64(2821834349, 766784016), new Word64(2952996808, 2566594879), new Word64(3210313671, 3203337956), new Word64(3336571891, 1034457026), new Word64(3584528711, 2466948901), new Word64(113926993, 3758326383), new Word64(338241895, 168717936), new Word64(666307205, 1188179964), new Word64(773529912, 1546045734), new Word64(1294757372, 1522805485), new Word64(1396182291, 2643833823), new Word64(1695183700, 2343527390), new Word64(1986661051, 1014477480), new Word64(2177026350, 1206759142), new Word64(2456956037, 344077627), new Word64(2730485921, 1290863460), new Word64(2820302411, 3158454273), new Word64(3259730800, 3505952657), new Word64(3345764771, 106217008), new Word64(3516065817, 3606008344), new Word64(3600352804, 1432725776), new Word64(4094571909, 1467031594), new Word64(275423344, 851169720), new Word64(430227734, 3100823752), new Word64(506948616, 1363258195), new Word64(659060556, 3750685593), new Word64(883997877, 3785050280), new Word64(958139571, 3318307427), new Word64(1322822218, 3812723403), new Word64(1537002063, 2003034995), new Word64(1747873779, 3602036899), new Word64(1955562222, 1575990012), new Word64(2024104815, 1125592928), new Word64(2227730452, 2716904306), new Word64(2361852424, 442776044), new Word64(2428436474, 593698344), new Word64(2756734187, 3733110249), new Word64(3204031479, 2999351573), new Word64(3329325298, 3815920427), new Word64(3391569614, 3928383900), new Word64(3515267271, 566280711), new Word64(3940187606, 3454069534), new Word64(4118630271, 4000239992), new Word64(116418474, 1914138554), new Word64(174292421, 2731055270), new Word64(289380356, 3203993006), new Word64(460393269, 320620315), new Word64(685471733, 587496836), new Word64(852142971, 1086792851), new Word64(1017036298, 365543100), new Word64(1126000580, 2618297676), new Word64(1288033470, 3409855158), new Word64(1501505948, 4234509866), new Word64(1607167915, 987167468), new Word64(1816402316, 1246189591)];
              function hash(data, offset, length, mode384) {
                mode384 = !!mode384;
                var h0, h1, h2, h3, h4, h5, h6, h7;
                if (!mode384) {
                  h0 = new Word64(1779033703, 4089235720);
                  h1 = new Word64(3144134277, 2227873595);
                  h2 = new Word64(1013904242, 4271175723);
                  h3 = new Word64(2773480762, 1595750129);
                  h4 = new Word64(1359893119, 2917565137);
                  h5 = new Word64(2600822924, 725511199);
                  h6 = new Word64(528734635, 4215389547);
                  h7 = new Word64(1541459225, 327033209);
                } else {
                  h0 = new Word64(3418070365, 3238371032);
                  h1 = new Word64(1654270250, 914150663);
                  h2 = new Word64(2438529370, 812702999);
                  h3 = new Word64(355462360, 4144912697);
                  h4 = new Word64(1731405415, 4290775857);
                  h5 = new Word64(2394180231, 1750603025);
                  h6 = new Word64(3675008525, 1694076839);
                  h7 = new Word64(1203062813, 3204075428);
                }
                var paddedLength = Math.ceil((length + 17) / 128) * 128;
                var padded = new Uint8Array(paddedLength);
                var i, j, n;
                for (i = 0; i < length; ++i) {
                  padded[i] = data[offset++];
                }
                padded[i++] = 128;
                n = paddedLength - 16;
                while (i < n) {
                  padded[i++] = 0;
                }
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = 0;
                padded[i++] = length >>> 29 & 255;
                padded[i++] = length >> 21 & 255;
                padded[i++] = length >> 13 & 255;
                padded[i++] = length >> 5 & 255;
                padded[i++] = length << 3 & 255;
                var w = new Array(80);
                for (i = 0; i < 80; i++) {
                  w[i] = new Word64(0, 0);
                }
                var a = new Word64(0, 0), b = new Word64(0, 0), c = new Word64(0, 0);
                var d = new Word64(0, 0), e = new Word64(0, 0), f = new Word64(0, 0);
                var g = new Word64(0, 0), h = new Word64(0, 0);
                var t1 = new Word64(0, 0), t2 = new Word64(0, 0);
                var tmp1 = new Word64(0, 0), tmp2 = new Word64(0, 0), tmp3;
                for (i = 0; i < paddedLength; ) {
                  for (j = 0; j < 16; ++j) {
                    w[j].high = padded[i] << 24 | padded[i + 1] << 16 | padded[i + 2] << 8 | padded[i + 3];
                    w[j].low = padded[i + 4] << 24 | padded[i + 5] << 16 | padded[i + 6] << 8 | padded[i + 7];
                    i += 8;
                  }
                  for (j = 16; j < 80; ++j) {
                    tmp3 = w[j];
                    littleSigmaPrime(tmp3, w[j - 2], tmp2);
                    tmp3.add(w[j - 7]);
                    littleSigma(tmp1, w[j - 15], tmp2);
                    tmp3.add(tmp1);
                    tmp3.add(w[j - 16]);
                  }
                  a.assign(h0);
                  b.assign(h1);
                  c.assign(h2);
                  d.assign(h3);
                  e.assign(h4);
                  f.assign(h5);
                  g.assign(h6);
                  h.assign(h7);
                  for (j = 0; j < 80; ++j) {
                    t1.assign(h);
                    sigmaPrime(tmp1, e, tmp2);
                    t1.add(tmp1);
                    ch(tmp1, e, f, g, tmp2);
                    t1.add(tmp1);
                    t1.add(k[j]);
                    t1.add(w[j]);
                    sigma(t2, a, tmp2);
                    maj(tmp1, a, b, c, tmp2);
                    t2.add(tmp1);
                    tmp3 = h;
                    h = g;
                    g = f;
                    f = e;
                    d.add(t1);
                    e = d;
                    d = c;
                    c = b;
                    b = a;
                    tmp3.assign(t1);
                    tmp3.add(t2);
                    a = tmp3;
                  }
                  h0.add(a);
                  h1.add(b);
                  h2.add(c);
                  h3.add(d);
                  h4.add(e);
                  h5.add(f);
                  h6.add(g);
                  h7.add(h);
                }
                var result;
                if (!mode384) {
                  result = new Uint8Array(64);
                  h0.copyTo(result, 0);
                  h1.copyTo(result, 8);
                  h2.copyTo(result, 16);
                  h3.copyTo(result, 24);
                  h4.copyTo(result, 32);
                  h5.copyTo(result, 40);
                  h6.copyTo(result, 48);
                  h7.copyTo(result, 56);
                } else {
                  result = new Uint8Array(48);
                  h0.copyTo(result, 0);
                  h1.copyTo(result, 8);
                  h2.copyTo(result, 16);
                  h3.copyTo(result, 24);
                  h4.copyTo(result, 32);
                  h5.copyTo(result, 40);
                }
                return result;
              }
              return hash;
            }();
            var calculateSHA384 = /* @__PURE__ */ function calculateSHA384Closure() {
              function hash(data, offset, length) {
                return calculateSHA512(data, offset, length, true);
              }
              return hash;
            }();
            var NullCipher = function NullCipherClosure() {
              function NullCipher2() {
              }
              NullCipher2.prototype = {
                decryptBlock: function NullCipher_decryptBlock(data) {
                  return data;
                }
              };
              return NullCipher2;
            }();
            var AES128Cipher = function AES128CipherClosure() {
              var rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]);
              var s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]);
              var inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);
              var mixCol = new Uint8Array(256);
              for (var i = 0; i < 256; i++) {
                if (i < 128) {
                  mixCol[i] = i << 1;
                } else {
                  mixCol[i] = i << 1 ^ 27;
                }
              }
              var mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]);
              function expandKey128(cipherKey) {
                var b = 176, result = new Uint8Array(b);
                result.set(cipherKey);
                for (var j = 16, i2 = 1; j < b; ++i2) {
                  var t1 = result[j - 3], t2 = result[j - 2], t3 = result[j - 1], t4 = result[j - 4];
                  t1 = s[t1];
                  t2 = s[t2];
                  t3 = s[t3];
                  t4 = s[t4];
                  t1 = t1 ^ rcon[i2];
                  for (var n = 0; n < 4; ++n) {
                    result[j] = t1 ^= result[j - 16];
                    j++;
                    result[j] = t2 ^= result[j - 16];
                    j++;
                    result[j] = t3 ^= result[j - 16];
                    j++;
                    result[j] = t4 ^= result[j - 16];
                    j++;
                  }
                }
                return result;
              }
              function decrypt128(input, key) {
                var state = new Uint8Array(16);
                state.set(input);
                var i2, j, k;
                var t, u, v;
                for (j = 0, k = 160; j < 16; ++j, ++k) {
                  state[j] ^= key[k];
                }
                for (i2 = 9; i2 >= 1; --i2) {
                  t = state[13];
                  state[13] = state[9];
                  state[9] = state[5];
                  state[5] = state[1];
                  state[1] = t;
                  t = state[14];
                  u = state[10];
                  state[14] = state[6];
                  state[10] = state[2];
                  state[6] = t;
                  state[2] = u;
                  t = state[15];
                  u = state[11];
                  v = state[7];
                  state[15] = state[3];
                  state[11] = t;
                  state[7] = u;
                  state[3] = v;
                  for (j = 0; j < 16; ++j) {
                    state[j] = inv_s[state[j]];
                  }
                  for (j = 0, k = i2 * 16; j < 16; ++j, ++k) {
                    state[j] ^= key[k];
                  }
                  for (j = 0; j < 16; j += 4) {
                    var s0 = mix[state[j]], s1 = mix[state[j + 1]], s2 = mix[state[j + 2]], s3 = mix[state[j + 3]];
                    t = s0 ^ s1 >>> 8 ^ s1 << 24 ^ s2 >>> 16 ^ s2 << 16 ^ s3 >>> 24 ^ s3 << 8;
                    state[j] = t >>> 24 & 255;
                    state[j + 1] = t >> 16 & 255;
                    state[j + 2] = t >> 8 & 255;
                    state[j + 3] = t & 255;
                  }
                }
                t = state[13];
                state[13] = state[9];
                state[9] = state[5];
                state[5] = state[1];
                state[1] = t;
                t = state[14];
                u = state[10];
                state[14] = state[6];
                state[10] = state[2];
                state[6] = t;
                state[2] = u;
                t = state[15];
                u = state[11];
                v = state[7];
                state[15] = state[3];
                state[11] = t;
                state[7] = u;
                state[3] = v;
                for (j = 0; j < 16; ++j) {
                  state[j] = inv_s[state[j]];
                  state[j] ^= key[j];
                }
                return state;
              }
              function encrypt128(input, key) {
                var t, u, v, k;
                var state = new Uint8Array(16);
                state.set(input);
                for (j = 0; j < 16; ++j) {
                  state[j] ^= key[j];
                }
                for (i = 1; i < 10; i++) {
                  for (j = 0; j < 16; ++j) {
                    state[j] = s[state[j]];
                  }
                  v = state[1];
                  state[1] = state[5];
                  state[5] = state[9];
                  state[9] = state[13];
                  state[13] = v;
                  v = state[2];
                  u = state[6];
                  state[2] = state[10];
                  state[6] = state[14];
                  state[10] = v;
                  state[14] = u;
                  v = state[3];
                  u = state[7];
                  t = state[11];
                  state[3] = state[15];
                  state[7] = v;
                  state[11] = u;
                  state[15] = t;
                  for (var j = 0; j < 16; j += 4) {
                    var s0 = state[j + 0], s1 = state[j + 1];
                    var s2 = state[j + 2], s3 = state[j + 3];
                    t = s0 ^ s1 ^ s2 ^ s3;
                    state[j + 0] ^= t ^ mixCol[s0 ^ s1];
                    state[j + 1] ^= t ^ mixCol[s1 ^ s2];
                    state[j + 2] ^= t ^ mixCol[s2 ^ s3];
                    state[j + 3] ^= t ^ mixCol[s3 ^ s0];
                  }
                  for (j = 0, k = i * 16; j < 16; ++j, ++k) {
                    state[j] ^= key[k];
                  }
                }
                for (j = 0; j < 16; ++j) {
                  state[j] = s[state[j]];
                }
                v = state[1];
                state[1] = state[5];
                state[5] = state[9];
                state[9] = state[13];
                state[13] = v;
                v = state[2];
                u = state[6];
                state[2] = state[10];
                state[6] = state[14];
                state[10] = v;
                state[14] = u;
                v = state[3];
                u = state[7];
                t = state[11];
                state[3] = state[15];
                state[7] = v;
                state[11] = u;
                state[15] = t;
                for (j = 0, k = 160; j < 16; ++j, ++k) {
                  state[j] ^= key[k];
                }
                return state;
              }
              function AES128Cipher2(key) {
                this.key = expandKey128(key);
                this.buffer = new Uint8Array(16);
                this.bufferPosition = 0;
              }
              function decryptBlock2(data, finalize) {
                var i2, j, ii, sourceLength = data.length, buffer = this.buffer, bufferLength = this.bufferPosition, result = [], iv = this.iv;
                for (i2 = 0; i2 < sourceLength; ++i2) {
                  buffer[bufferLength] = data[i2];
                  ++bufferLength;
                  if (bufferLength < 16) {
                    continue;
                  }
                  var plain = decrypt128(buffer, this.key);
                  for (j = 0; j < 16; ++j) {
                    plain[j] ^= iv[j];
                  }
                  iv = buffer;
                  result.push(plain);
                  buffer = new Uint8Array(16);
                  bufferLength = 0;
                }
                this.buffer = buffer;
                this.bufferLength = bufferLength;
                this.iv = iv;
                if (result.length === 0) {
                  return new Uint8Array([]);
                }
                var outputLength = 16 * result.length;
                if (finalize) {
                  var lastBlock = result[result.length - 1];
                  var psLen = lastBlock[15];
                  if (psLen <= 16) {
                    for (i2 = 15, ii = 16 - psLen; i2 >= ii; --i2) {
                      if (lastBlock[i2] !== psLen) {
                        psLen = 0;
                        break;
                      }
                    }
                    outputLength -= psLen;
                    result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
                  }
                }
                var output = new Uint8Array(outputLength);
                for (i2 = 0, j = 0, ii = result.length; i2 < ii; ++i2, j += 16) {
                  output.set(result[i2], j);
                }
                return output;
              }
              AES128Cipher2.prototype = {
                decryptBlock: function AES128Cipher_decryptBlock(data, finalize) {
                  var i2, sourceLength = data.length;
                  var buffer = this.buffer, bufferLength = this.bufferPosition;
                  for (i2 = 0; bufferLength < 16 && i2 < sourceLength; ++i2, ++bufferLength) {
                    buffer[bufferLength] = data[i2];
                  }
                  if (bufferLength < 16) {
                    this.bufferLength = bufferLength;
                    return new Uint8Array([]);
                  }
                  this.iv = buffer;
                  this.buffer = new Uint8Array(16);
                  this.bufferLength = 0;
                  this.decryptBlock = decryptBlock2;
                  return this.decryptBlock(data.subarray(16), finalize);
                },
                encrypt: function AES128Cipher_encrypt(data, iv) {
                  var i2, j, ii, sourceLength = data.length, buffer = this.buffer, bufferLength = this.bufferPosition, result = [];
                  if (!iv) {
                    iv = new Uint8Array(16);
                  }
                  for (i2 = 0; i2 < sourceLength; ++i2) {
                    buffer[bufferLength] = data[i2];
                    ++bufferLength;
                    if (bufferLength < 16) {
                      continue;
                    }
                    for (j = 0; j < 16; ++j) {
                      buffer[j] ^= iv[j];
                    }
                    var cipher = encrypt128(buffer, this.key);
                    iv = cipher;
                    result.push(cipher);
                    buffer = new Uint8Array(16);
                    bufferLength = 0;
                  }
                  this.buffer = buffer;
                  this.bufferLength = bufferLength;
                  this.iv = iv;
                  if (result.length === 0) {
                    return new Uint8Array([]);
                  }
                  var outputLength = 16 * result.length;
                  var output = new Uint8Array(outputLength);
                  for (i2 = 0, j = 0, ii = result.length; i2 < ii; ++i2, j += 16) {
                    output.set(result[i2], j);
                  }
                  return output;
                }
              };
              return AES128Cipher2;
            }();
            var AES256Cipher = function AES256CipherClosure() {
              var s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]);
              var inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);
              var mixCol = new Uint8Array(256);
              for (var i = 0; i < 256; i++) {
                if (i < 128) {
                  mixCol[i] = i << 1;
                } else {
                  mixCol[i] = i << 1 ^ 27;
                }
              }
              var mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]);
              function expandKey256(cipherKey) {
                var b = 240, result = new Uint8Array(b);
                var r = 1;
                result.set(cipherKey);
                for (var j = 32, i2 = 1; j < b; ++i2) {
                  if (j % 32 === 16) {
                    t1 = s[t1];
                    t2 = s[t2];
                    t3 = s[t3];
                    t4 = s[t4];
                  } else if (j % 32 === 0) {
                    var t1 = result[j - 3], t2 = result[j - 2], t3 = result[j - 1], t4 = result[j - 4];
                    t1 = s[t1];
                    t2 = s[t2];
                    t3 = s[t3];
                    t4 = s[t4];
                    t1 = t1 ^ r;
                    if ((r <<= 1) >= 256) {
                      r = (r ^ 27) & 255;
                    }
                  }
                  for (var n = 0; n < 4; ++n) {
                    result[j] = t1 ^= result[j - 32];
                    j++;
                    result[j] = t2 ^= result[j - 32];
                    j++;
                    result[j] = t3 ^= result[j - 32];
                    j++;
                    result[j] = t4 ^= result[j - 32];
                    j++;
                  }
                }
                return result;
              }
              function decrypt256(input, key) {
                var state = new Uint8Array(16);
                state.set(input);
                var i2, j, k;
                var t, u, v;
                for (j = 0, k = 224; j < 16; ++j, ++k) {
                  state[j] ^= key[k];
                }
                for (i2 = 13; i2 >= 1; --i2) {
                  t = state[13];
                  state[13] = state[9];
                  state[9] = state[5];
                  state[5] = state[1];
                  state[1] = t;
                  t = state[14];
                  u = state[10];
                  state[14] = state[6];
                  state[10] = state[2];
                  state[6] = t;
                  state[2] = u;
                  t = state[15];
                  u = state[11];
                  v = state[7];
                  state[15] = state[3];
                  state[11] = t;
                  state[7] = u;
                  state[3] = v;
                  for (j = 0; j < 16; ++j) {
                    state[j] = inv_s[state[j]];
                  }
                  for (j = 0, k = i2 * 16; j < 16; ++j, ++k) {
                    state[j] ^= key[k];
                  }
                  for (j = 0; j < 16; j += 4) {
                    var s0 = mix[state[j]], s1 = mix[state[j + 1]], s2 = mix[state[j + 2]], s3 = mix[state[j + 3]];
                    t = s0 ^ s1 >>> 8 ^ s1 << 24 ^ s2 >>> 16 ^ s2 << 16 ^ s3 >>> 24 ^ s3 << 8;
                    state[j] = t >>> 24 & 255;
                    state[j + 1] = t >> 16 & 255;
                    state[j + 2] = t >> 8 & 255;
                    state[j + 3] = t & 255;
                  }
                }
                t = state[13];
                state[13] = state[9];
                state[9] = state[5];
                state[5] = state[1];
                state[1] = t;
                t = state[14];
                u = state[10];
                state[14] = state[6];
                state[10] = state[2];
                state[6] = t;
                state[2] = u;
                t = state[15];
                u = state[11];
                v = state[7];
                state[15] = state[3];
                state[11] = t;
                state[7] = u;
                state[3] = v;
                for (j = 0; j < 16; ++j) {
                  state[j] = inv_s[state[j]];
                  state[j] ^= key[j];
                }
                return state;
              }
              function encrypt256(input, key) {
                var t, u, v, k;
                var state = new Uint8Array(16);
                state.set(input);
                for (j = 0; j < 16; ++j) {
                  state[j] ^= key[j];
                }
                for (i = 1; i < 14; i++) {
                  for (j = 0; j < 16; ++j) {
                    state[j] = s[state[j]];
                  }
                  v = state[1];
                  state[1] = state[5];
                  state[5] = state[9];
                  state[9] = state[13];
                  state[13] = v;
                  v = state[2];
                  u = state[6];
                  state[2] = state[10];
                  state[6] = state[14];
                  state[10] = v;
                  state[14] = u;
                  v = state[3];
                  u = state[7];
                  t = state[11];
                  state[3] = state[15];
                  state[7] = v;
                  state[11] = u;
                  state[15] = t;
                  for (var j = 0; j < 16; j += 4) {
                    var s0 = state[j + 0], s1 = state[j + 1];
                    var s2 = state[j + 2], s3 = state[j + 3];
                    t = s0 ^ s1 ^ s2 ^ s3;
                    state[j + 0] ^= t ^ mixCol[s0 ^ s1];
                    state[j + 1] ^= t ^ mixCol[s1 ^ s2];
                    state[j + 2] ^= t ^ mixCol[s2 ^ s3];
                    state[j + 3] ^= t ^ mixCol[s3 ^ s0];
                  }
                  for (j = 0, k = i * 16; j < 16; ++j, ++k) {
                    state[j] ^= key[k];
                  }
                }
                for (j = 0; j < 16; ++j) {
                  state[j] = s[state[j]];
                }
                v = state[1];
                state[1] = state[5];
                state[5] = state[9];
                state[9] = state[13];
                state[13] = v;
                v = state[2];
                u = state[6];
                state[2] = state[10];
                state[6] = state[14];
                state[10] = v;
                state[14] = u;
                v = state[3];
                u = state[7];
                t = state[11];
                state[3] = state[15];
                state[7] = v;
                state[11] = u;
                state[15] = t;
                for (j = 0, k = 224; j < 16; ++j, ++k) {
                  state[j] ^= key[k];
                }
                return state;
              }
              function AES256Cipher2(key) {
                this.key = expandKey256(key);
                this.buffer = new Uint8Array(16);
                this.bufferPosition = 0;
              }
              function decryptBlock2(data, finalize) {
                var i2, j, ii, sourceLength = data.length, buffer = this.buffer, bufferLength = this.bufferPosition, result = [], iv = this.iv;
                for (i2 = 0; i2 < sourceLength; ++i2) {
                  buffer[bufferLength] = data[i2];
                  ++bufferLength;
                  if (bufferLength < 16) {
                    continue;
                  }
                  var plain = decrypt256(buffer, this.key);
                  for (j = 0; j < 16; ++j) {
                    plain[j] ^= iv[j];
                  }
                  iv = buffer;
                  result.push(plain);
                  buffer = new Uint8Array(16);
                  bufferLength = 0;
                }
                this.buffer = buffer;
                this.bufferLength = bufferLength;
                this.iv = iv;
                if (result.length === 0) {
                  return new Uint8Array([]);
                }
                var outputLength = 16 * result.length;
                if (finalize) {
                  var lastBlock = result[result.length - 1];
                  var psLen = lastBlock[15];
                  if (psLen <= 16) {
                    for (i2 = 15, ii = 16 - psLen; i2 >= ii; --i2) {
                      if (lastBlock[i2] !== psLen) {
                        psLen = 0;
                        break;
                      }
                    }
                    outputLength -= psLen;
                    result[result.length - 1] = lastBlock.subarray(0, 16 - psLen);
                  }
                }
                var output = new Uint8Array(outputLength);
                for (i2 = 0, j = 0, ii = result.length; i2 < ii; ++i2, j += 16) {
                  output.set(result[i2], j);
                }
                return output;
              }
              AES256Cipher2.prototype = {
                decryptBlock: function AES256Cipher_decryptBlock(data, finalize, iv) {
                  var i2, sourceLength = data.length;
                  var buffer = this.buffer, bufferLength = this.bufferPosition;
                  if (iv) {
                    this.iv = iv;
                  } else {
                    for (i2 = 0; bufferLength < 16 && i2 < sourceLength; ++i2, ++bufferLength) {
                      buffer[bufferLength] = data[i2];
                    }
                    if (bufferLength < 16) {
                      this.bufferLength = bufferLength;
                      return new Uint8Array([]);
                    }
                    this.iv = buffer;
                    data = data.subarray(16);
                  }
                  this.buffer = new Uint8Array(16);
                  this.bufferLength = 0;
                  this.decryptBlock = decryptBlock2;
                  return this.decryptBlock(data, finalize);
                },
                encrypt: function AES256Cipher_encrypt(data, iv) {
                  var i2, j, ii, sourceLength = data.length, buffer = this.buffer, bufferLength = this.bufferPosition, result = [];
                  if (!iv) {
                    iv = new Uint8Array(16);
                  }
                  for (i2 = 0; i2 < sourceLength; ++i2) {
                    buffer[bufferLength] = data[i2];
                    ++bufferLength;
                    if (bufferLength < 16) {
                      continue;
                    }
                    for (j = 0; j < 16; ++j) {
                      buffer[j] ^= iv[j];
                    }
                    var cipher = encrypt256(buffer, this.key);
                    this.iv = cipher;
                    result.push(cipher);
                    buffer = new Uint8Array(16);
                    bufferLength = 0;
                  }
                  this.buffer = buffer;
                  this.bufferLength = bufferLength;
                  this.iv = iv;
                  if (result.length === 0) {
                    return new Uint8Array([]);
                  }
                  var outputLength = 16 * result.length;
                  var output = new Uint8Array(outputLength);
                  for (i2 = 0, j = 0, ii = result.length; i2 < ii; ++i2, j += 16) {
                    output.set(result[i2], j);
                  }
                  return output;
                }
              };
              return AES256Cipher2;
            }();
            var PDF17 = function PDF17Closure() {
              function compareByteArrays(array1, array2) {
                if (array1.length !== array2.length) {
                  return false;
                }
                for (var i = 0; i < array1.length; i++) {
                  if (array1[i] !== array2[i]) {
                    return false;
                  }
                }
                return true;
              }
              function PDF172() {
              }
              PDF172.prototype = {
                checkOwnerPassword: function PDF17_checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
                  var hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerValidationSalt, password.length);
                  hashData.set(userBytes, password.length + ownerValidationSalt.length);
                  var result = calculateSHA256(hashData, 0, hashData.length);
                  return compareByteArrays(result, ownerPassword);
                },
                checkUserPassword: function PDF17_checkUserPassword(password, userValidationSalt, userPassword) {
                  var hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userValidationSalt, password.length);
                  var result = calculateSHA256(hashData, 0, hashData.length);
                  return compareByteArrays(result, userPassword);
                },
                getOwnerKey: function PDF17_getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
                  var hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerKeySalt, password.length);
                  hashData.set(userBytes, password.length + ownerKeySalt.length);
                  var key = calculateSHA256(hashData, 0, hashData.length);
                  var cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
                },
                getUserKey: function PDF17_getUserKey(password, userKeySalt, userEncryption) {
                  var hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userKeySalt, password.length);
                  var key = calculateSHA256(hashData, 0, hashData.length);
                  var cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
                }
              };
              return PDF172;
            }();
            var PDF20 = function PDF20Closure() {
              function concatArrays(array1, array2) {
                var t = new Uint8Array(array1.length + array2.length);
                t.set(array1, 0);
                t.set(array2, array1.length);
                return t;
              }
              function calculatePDF20Hash(password, input, userBytes) {
                var k = calculateSHA256(input, 0, input.length).subarray(0, 32);
                var e = [0];
                var i = 0;
                while (i < 64 || e[e.length - 1] > i - 32) {
                  var arrayLength = password.length + k.length + userBytes.length;
                  var k1 = new Uint8Array(arrayLength * 64);
                  var array = concatArrays(password, k);
                  array = concatArrays(array, userBytes);
                  for (var j = 0, pos = 0; j < 64; j++, pos += arrayLength) {
                    k1.set(array, pos);
                  }
                  var cipher = new AES128Cipher(k.subarray(0, 16));
                  e = cipher.encrypt(k1, k.subarray(16, 32));
                  var remainder = 0;
                  for (var z = 0; z < 16; z++) {
                    remainder *= 256 % 3;
                    remainder %= 3;
                    remainder += (e[z] >>> 0) % 3;
                    remainder %= 3;
                  }
                  if (remainder === 0) {
                    k = calculateSHA256(e, 0, e.length);
                  } else if (remainder === 1) {
                    k = calculateSHA384(e, 0, e.length);
                  } else if (remainder === 2) {
                    k = calculateSHA512(e, 0, e.length);
                  }
                  i++;
                }
                return k.subarray(0, 32);
              }
              function PDF202() {
              }
              function compareByteArrays(array1, array2) {
                if (array1.length !== array2.length) {
                  return false;
                }
                for (var i = 0; i < array1.length; i++) {
                  if (array1[i] !== array2[i]) {
                    return false;
                  }
                }
                return true;
              }
              PDF202.prototype = {
                hash: function PDF20_hash(password, concatBytes, userBytes) {
                  return calculatePDF20Hash(password, concatBytes, userBytes);
                },
                checkOwnerPassword: function PDF20_checkOwnerPassword(password, ownerValidationSalt, userBytes, ownerPassword) {
                  var hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerValidationSalt, password.length);
                  hashData.set(userBytes, password.length + ownerValidationSalt.length);
                  var result = calculatePDF20Hash(password, hashData, userBytes);
                  return compareByteArrays(result, ownerPassword);
                },
                checkUserPassword: function PDF20_checkUserPassword(password, userValidationSalt, userPassword) {
                  var hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userValidationSalt, password.length);
                  var result = calculatePDF20Hash(password, hashData, []);
                  return compareByteArrays(result, userPassword);
                },
                getOwnerKey: function PDF20_getOwnerKey(password, ownerKeySalt, userBytes, ownerEncryption) {
                  var hashData = new Uint8Array(password.length + 56);
                  hashData.set(password, 0);
                  hashData.set(ownerKeySalt, password.length);
                  hashData.set(userBytes, password.length + ownerKeySalt.length);
                  var key = calculatePDF20Hash(password, hashData, userBytes);
                  var cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(ownerEncryption, false, new Uint8Array(16));
                },
                getUserKey: function PDF20_getUserKey(password, userKeySalt, userEncryption) {
                  var hashData = new Uint8Array(password.length + 8);
                  hashData.set(password, 0);
                  hashData.set(userKeySalt, password.length);
                  var key = calculatePDF20Hash(password, hashData, []);
                  var cipher = new AES256Cipher(key);
                  return cipher.decryptBlock(userEncryption, false, new Uint8Array(16));
                }
              };
              return PDF202;
            }();
            var CipherTransform = function CipherTransformClosure() {
              function CipherTransform2(stringCipherConstructor, streamCipherConstructor) {
                this.StringCipherConstructor = stringCipherConstructor;
                this.StreamCipherConstructor = streamCipherConstructor;
              }
              CipherTransform2.prototype = {
                createStream: function CipherTransform_createStream(stream, length) {
                  var cipher = new this.StreamCipherConstructor();
                  return new _stream.DecryptStream(stream, length, function cipherTransformDecryptStream(data, finalize) {
                    return cipher.decryptBlock(data, finalize);
                  });
                },
                decryptString: function CipherTransform_decryptString(s) {
                  var cipher = new this.StringCipherConstructor();
                  var data = (0, _util.stringToBytes)(s);
                  data = cipher.decryptBlock(data, true);
                  return (0, _util.bytesToString)(data);
                }
              };
              return CipherTransform2;
            }();
            var CipherTransformFactory = function CipherTransformFactoryClosure() {
              var defaultPasswordBytes = new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]);
              function createEncryptionKey20(revision, password, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms) {
                if (password) {
                  var passwordLength = Math.min(127, password.length);
                  password = password.subarray(0, passwordLength);
                } else {
                  password = [];
                }
                var pdfAlgorithm;
                if (revision === 6) {
                  pdfAlgorithm = new PDF20();
                } else {
                  pdfAlgorithm = new PDF17();
                }
                if (pdfAlgorithm.checkUserPassword(password, userValidationSalt, userPassword)) {
                  return pdfAlgorithm.getUserKey(password, userKeySalt, userEncryption);
                } else if (password.length && pdfAlgorithm.checkOwnerPassword(password, ownerValidationSalt, uBytes, ownerPassword)) {
                  return pdfAlgorithm.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);
                }
                return null;
              }
              function prepareKeyData(fileId, password, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata) {
                var hashDataSize = 40 + ownerPassword.length + fileId.length;
                var hashData = new Uint8Array(hashDataSize), i = 0, j, n;
                if (password) {
                  n = Math.min(32, password.length);
                  for (; i < n; ++i) {
                    hashData[i] = password[i];
                  }
                }
                j = 0;
                while (i < 32) {
                  hashData[i++] = defaultPasswordBytes[j++];
                }
                for (j = 0, n = ownerPassword.length; j < n; ++j) {
                  hashData[i++] = ownerPassword[j];
                }
                hashData[i++] = flags & 255;
                hashData[i++] = flags >> 8 & 255;
                hashData[i++] = flags >> 16 & 255;
                hashData[i++] = flags >>> 24 & 255;
                for (j = 0, n = fileId.length; j < n; ++j) {
                  hashData[i++] = fileId[j];
                }
                if (revision >= 4 && !encryptMetadata) {
                  hashData[i++] = 255;
                  hashData[i++] = 255;
                  hashData[i++] = 255;
                  hashData[i++] = 255;
                }
                var hash = calculateMD5(hashData, 0, i);
                var keyLengthInBytes = keyLength >> 3;
                if (revision >= 3) {
                  for (j = 0; j < 50; ++j) {
                    hash = calculateMD5(hash, 0, keyLengthInBytes);
                  }
                }
                var encryptionKey = hash.subarray(0, keyLengthInBytes);
                var cipher, checkData;
                if (revision >= 3) {
                  for (i = 0; i < 32; ++i) {
                    hashData[i] = defaultPasswordBytes[i];
                  }
                  for (j = 0, n = fileId.length; j < n; ++j) {
                    hashData[i++] = fileId[j];
                  }
                  cipher = new ARCFourCipher(encryptionKey);
                  checkData = cipher.encryptBlock(calculateMD5(hashData, 0, i));
                  n = encryptionKey.length;
                  var derivedKey = new Uint8Array(n), k;
                  for (j = 1; j <= 19; ++j) {
                    for (k = 0; k < n; ++k) {
                      derivedKey[k] = encryptionKey[k] ^ j;
                    }
                    cipher = new ARCFourCipher(derivedKey);
                    checkData = cipher.encryptBlock(checkData);
                  }
                  for (j = 0, n = checkData.length; j < n; ++j) {
                    if (userPassword[j] !== checkData[j]) {
                      return null;
                    }
                  }
                } else {
                  cipher = new ARCFourCipher(encryptionKey);
                  checkData = cipher.encryptBlock(defaultPasswordBytes);
                  for (j = 0, n = checkData.length; j < n; ++j) {
                    if (userPassword[j] !== checkData[j]) {
                      return null;
                    }
                  }
                }
                return encryptionKey;
              }
              function decodeUserPassword(password, ownerPassword, revision, keyLength) {
                var hashData = new Uint8Array(32), i = 0, j, n;
                n = Math.min(32, password.length);
                for (; i < n; ++i) {
                  hashData[i] = password[i];
                }
                j = 0;
                while (i < 32) {
                  hashData[i++] = defaultPasswordBytes[j++];
                }
                var hash = calculateMD5(hashData, 0, i);
                var keyLengthInBytes = keyLength >> 3;
                if (revision >= 3) {
                  for (j = 0; j < 50; ++j) {
                    hash = calculateMD5(hash, 0, hash.length);
                  }
                }
                var cipher, userPassword;
                if (revision >= 3) {
                  userPassword = ownerPassword;
                  var derivedKey = new Uint8Array(keyLengthInBytes), k;
                  for (j = 19; j >= 0; j--) {
                    for (k = 0; k < keyLengthInBytes; ++k) {
                      derivedKey[k] = hash[k] ^ j;
                    }
                    cipher = new ARCFourCipher(derivedKey);
                    userPassword = cipher.encryptBlock(userPassword);
                  }
                } else {
                  cipher = new ARCFourCipher(hash.subarray(0, keyLengthInBytes));
                  userPassword = cipher.encryptBlock(ownerPassword);
                }
                return userPassword;
              }
              var identityName = _primitives.Name.get("Identity");
              function CipherTransformFactory2(dict, fileId, password) {
                var filter = dict.get("Filter");
                if (!(0, _primitives.isName)(filter, "Standard")) {
                  throw new _util.FormatError("unknown encryption method");
                }
                this.dict = dict;
                var algorithm = dict.get("V");
                if (!Number.isInteger(algorithm) || algorithm !== 1 && algorithm !== 2 && algorithm !== 4 && algorithm !== 5) {
                  throw new _util.FormatError("unsupported encryption algorithm");
                }
                this.algorithm = algorithm;
                var keyLength = dict.get("Length");
                if (!keyLength) {
                  if (algorithm <= 3) {
                    keyLength = 40;
                  } else {
                    var cfDict = dict.get("CF");
                    var streamCryptoName = dict.get("StmF");
                    if ((0, _primitives.isDict)(cfDict) && (0, _primitives.isName)(streamCryptoName)) {
                      cfDict.suppressEncryption = true;
                      var handlerDict = cfDict.get(streamCryptoName.name);
                      keyLength = handlerDict && handlerDict.get("Length") || 128;
                      if (keyLength < 40) {
                        keyLength <<= 3;
                      }
                    }
                  }
                }
                if (!Number.isInteger(keyLength) || keyLength < 40 || keyLength % 8 !== 0) {
                  throw new _util.FormatError("invalid key length");
                }
                var ownerPassword = (0, _util.stringToBytes)(dict.get("O")).subarray(0, 32);
                var userPassword = (0, _util.stringToBytes)(dict.get("U")).subarray(0, 32);
                var flags = dict.get("P");
                var revision = dict.get("R");
                var encryptMetadata = (algorithm === 4 || algorithm === 5) && dict.get("EncryptMetadata") !== false;
                this.encryptMetadata = encryptMetadata;
                var fileIdBytes = (0, _util.stringToBytes)(fileId);
                var passwordBytes;
                if (password) {
                  if (revision === 6) {
                    try {
                      password = (0, _util.utf8StringToString)(password);
                    } catch (ex) {
                      (0, _util.warn)("CipherTransformFactory: Unable to convert UTF8 encoded password.");
                    }
                  }
                  passwordBytes = (0, _util.stringToBytes)(password);
                }
                var encryptionKey;
                if (algorithm !== 5) {
                  encryptionKey = prepareKeyData(fileIdBytes, passwordBytes, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
                } else {
                  var ownerValidationSalt = (0, _util.stringToBytes)(dict.get("O")).subarray(32, 40);
                  var ownerKeySalt = (0, _util.stringToBytes)(dict.get("O")).subarray(40, 48);
                  var uBytes = (0, _util.stringToBytes)(dict.get("U")).subarray(0, 48);
                  var userValidationSalt = (0, _util.stringToBytes)(dict.get("U")).subarray(32, 40);
                  var userKeySalt = (0, _util.stringToBytes)(dict.get("U")).subarray(40, 48);
                  var ownerEncryption = (0, _util.stringToBytes)(dict.get("OE"));
                  var userEncryption = (0, _util.stringToBytes)(dict.get("UE"));
                  var perms = (0, _util.stringToBytes)(dict.get("Perms"));
                  encryptionKey = createEncryptionKey20(revision, passwordBytes, ownerPassword, ownerValidationSalt, ownerKeySalt, uBytes, userPassword, userValidationSalt, userKeySalt, ownerEncryption, userEncryption, perms);
                }
                if (!encryptionKey && !password) {
                  throw new _util.PasswordException("No password given", _util.PasswordResponses.NEED_PASSWORD);
                } else if (!encryptionKey && password) {
                  var decodedPassword = decodeUserPassword(passwordBytes, ownerPassword, revision, keyLength);
                  encryptionKey = prepareKeyData(fileIdBytes, decodedPassword, ownerPassword, userPassword, flags, revision, keyLength, encryptMetadata);
                }
                if (!encryptionKey) {
                  throw new _util.PasswordException("Incorrect Password", _util.PasswordResponses.INCORRECT_PASSWORD);
                }
                this.encryptionKey = encryptionKey;
                if (algorithm >= 4) {
                  var cf = dict.get("CF");
                  if ((0, _primitives.isDict)(cf)) {
                    cf.suppressEncryption = true;
                  }
                  this.cf = cf;
                  this.stmf = dict.get("StmF") || identityName;
                  this.strf = dict.get("StrF") || identityName;
                  this.eff = dict.get("EFF") || this.stmf;
                }
              }
              function buildObjectKey(num, gen, encryptionKey, isAes) {
                var key = new Uint8Array(encryptionKey.length + 9), i, n;
                for (i = 0, n = encryptionKey.length; i < n; ++i) {
                  key[i] = encryptionKey[i];
                }
                key[i++] = num & 255;
                key[i++] = num >> 8 & 255;
                key[i++] = num >> 16 & 255;
                key[i++] = gen & 255;
                key[i++] = gen >> 8 & 255;
                if (isAes) {
                  key[i++] = 115;
                  key[i++] = 65;
                  key[i++] = 108;
                  key[i++] = 84;
                }
                var hash = calculateMD5(key, 0, i);
                return hash.subarray(0, Math.min(encryptionKey.length + 5, 16));
              }
              function buildCipherConstructor(cf, name, num, gen, key) {
                if (!(0, _primitives.isName)(name)) {
                  throw new _util.FormatError("Invalid crypt filter name.");
                }
                var cryptFilter = cf.get(name.name);
                var cfm;
                if (cryptFilter !== null && cryptFilter !== void 0) {
                  cfm = cryptFilter.get("CFM");
                }
                if (!cfm || cfm.name === "None") {
                  return function cipherTransformFactoryBuildCipherConstructorNone() {
                    return new NullCipher();
                  };
                }
                if (cfm.name === "V2") {
                  return function cipherTransformFactoryBuildCipherConstructorV2() {
                    return new ARCFourCipher(buildObjectKey(num, gen, key, false));
                  };
                }
                if (cfm.name === "AESV2") {
                  return function cipherTransformFactoryBuildCipherConstructorAESV2() {
                    return new AES128Cipher(buildObjectKey(num, gen, key, true));
                  };
                }
                if (cfm.name === "AESV3") {
                  return function cipherTransformFactoryBuildCipherConstructorAESV3() {
                    return new AES256Cipher(key);
                  };
                }
                throw new _util.FormatError("Unknown crypto method");
              }
              CipherTransformFactory2.prototype = {
                createCipherTransform: function CipherTransformFactory_createCipherTransform(num, gen) {
                  if (this.algorithm === 4 || this.algorithm === 5) {
                    return new CipherTransform(buildCipherConstructor(this.cf, this.stmf, num, gen, this.encryptionKey), buildCipherConstructor(this.cf, this.strf, num, gen, this.encryptionKey));
                  }
                  var key = buildObjectKey(num, gen, this.encryptionKey, false);
                  var cipherConstructor = function buildCipherCipherConstructor() {
                    return new ARCFourCipher(key);
                  };
                  return new CipherTransform(cipherConstructor, cipherConstructor);
                }
              };
              return CipherTransformFactory2;
            }();
            exports2.AES128Cipher = AES128Cipher;
            exports2.AES256Cipher = AES256Cipher;
            exports2.ARCFourCipher = ARCFourCipher;
            exports2.CipherTransformFactory = CipherTransformFactory;
            exports2.PDF17 = PDF17;
            exports2.PDF20 = PDF20;
            exports2.calculateMD5 = calculateMD5;
            exports2.calculateSHA256 = calculateSHA256;
            exports2.calculateSHA384 = calculateSHA384;
            exports2.calculateSHA512 = calculateSHA512;
          },
          /* 77 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.PartialEvaluator = exports2.OperatorList = void 0;
            var _util = __w_pdfjs_require__(0);
            var _cmap = __w_pdfjs_require__(134);
            var _stream = __w_pdfjs_require__(5);
            var _primitives = __w_pdfjs_require__(2);
            var _fonts = __w_pdfjs_require__(135);
            var _encodings = __w_pdfjs_require__(28);
            var _unicode = __w_pdfjs_require__(80);
            var _standard_fonts = __w_pdfjs_require__(79);
            var _pattern = __w_pdfjs_require__(139);
            var _parser = __w_pdfjs_require__(34);
            var _bidi = __w_pdfjs_require__(140);
            var _colorspace = __w_pdfjs_require__(27);
            var _glyphlist = __w_pdfjs_require__(47);
            var _metrics = __w_pdfjs_require__(141);
            var _function = __w_pdfjs_require__(81);
            var _murmurhash = __w_pdfjs_require__(143);
            var _image = __w_pdfjs_require__(144);
            var PartialEvaluator = function PartialEvaluatorClosure() {
              var DefaultPartialEvaluatorOptions = {
                forceDataSchema: false,
                maxImageSize: -1,
                disableFontFace: false,
                nativeImageDecoderSupport: _util.NativeImageDecoding.DECODE,
                ignoreErrors: false,
                isEvalSupported: true
              };
              function NativeImageDecoder(_ref) {
                var xref = _ref.xref, resources = _ref.resources, handler = _ref.handler, _ref$forceDataSchema = _ref.forceDataSchema, forceDataSchema = _ref$forceDataSchema === void 0 ? false : _ref$forceDataSchema, pdfFunctionFactory = _ref.pdfFunctionFactory;
                this.xref = xref;
                this.resources = resources;
                this.handler = handler;
                this.forceDataSchema = forceDataSchema;
                this.pdfFunctionFactory = pdfFunctionFactory;
              }
              NativeImageDecoder.prototype = {
                canDecode: function canDecode(image) {
                  return image instanceof _stream.JpegStream && NativeImageDecoder.isDecodable(image, this.xref, this.resources, this.pdfFunctionFactory);
                },
                decode: function decode(image) {
                  var dict = image.dict;
                  var colorSpace = dict.get("ColorSpace", "CS");
                  colorSpace = _colorspace.ColorSpace.parse(colorSpace, this.xref, this.resources, this.pdfFunctionFactory);
                  var numComps = colorSpace.numComps;
                  var decodePromise = this.handler.sendWithPromise("JpegDecode", [image.getIR(this.forceDataSchema), numComps]);
                  return decodePromise.then(function(message) {
                    var data = message.data;
                    return new _stream.Stream(data, 0, data.length, image.dict);
                  });
                }
              };
              NativeImageDecoder.isSupported = function(image, xref, res, pdfFunctionFactory) {
                var dict = image.dict;
                if (dict.has("DecodeParms") || dict.has("DP")) {
                  return false;
                }
                var cs = _colorspace.ColorSpace.parse(dict.get("ColorSpace", "CS"), xref, res, pdfFunctionFactory);
                return (cs.name === "DeviceGray" || cs.name === "DeviceRGB") && cs.isDefaultDecode(dict.getArray("Decode", "D"));
              };
              NativeImageDecoder.isDecodable = function(image, xref, res, pdfFunctionFactory) {
                var dict = image.dict;
                if (dict.has("DecodeParms") || dict.has("DP")) {
                  return false;
                }
                var cs = _colorspace.ColorSpace.parse(dict.get("ColorSpace", "CS"), xref, res, pdfFunctionFactory);
                return (cs.numComps === 1 || cs.numComps === 3) && cs.isDefaultDecode(dict.getArray("Decode", "D"));
              };
              function PartialEvaluator2(_ref2) {
                var _this = this;
                var pdfManager = _ref2.pdfManager, xref = _ref2.xref, handler = _ref2.handler, pageIndex = _ref2.pageIndex, idFactory = _ref2.idFactory, fontCache = _ref2.fontCache, builtInCMapCache = _ref2.builtInCMapCache, _ref2$options = _ref2.options, options = _ref2$options === void 0 ? null : _ref2$options, pdfFunctionFactory = _ref2.pdfFunctionFactory;
                this.pdfManager = pdfManager;
                this.xref = xref;
                this.handler = handler;
                this.pageIndex = pageIndex;
                this.idFactory = idFactory;
                this.fontCache = fontCache;
                this.builtInCMapCache = builtInCMapCache;
                this.options = options || DefaultPartialEvaluatorOptions;
                this.pdfFunctionFactory = pdfFunctionFactory;
                this.fetchBuiltInCMap = function(name) {
                  var cachedCMap = _this.builtInCMapCache[name];
                  if (cachedCMap) {
                    return Promise.resolve(cachedCMap);
                  }
                  return _this.handler.sendWithPromise("FetchBuiltInCMap", { name }).then(function(data) {
                    if (data.compressionType !== _util.CMapCompressionType.NONE) {
                      _this.builtInCMapCache[name] = data;
                    }
                    return data;
                  });
                };
              }
              var TIME_SLOT_DURATION_MS = 20;
              var CHECK_TIME_EVERY = 100;
              function TimeSlotManager() {
                this.reset();
              }
              TimeSlotManager.prototype = {
                check: function TimeSlotManager_check() {
                  if (++this.checked < CHECK_TIME_EVERY) {
                    return false;
                  }
                  this.checked = 0;
                  return this.endTime <= Date.now();
                },
                reset: function TimeSlotManager_reset() {
                  this.endTime = Date.now() + TIME_SLOT_DURATION_MS;
                  this.checked = 0;
                }
              };
              function normalizeBlendMode(value) {
                if (!(0, _primitives.isName)(value)) {
                  return "source-over";
                }
                switch (value.name) {
                  case "Normal":
                  case "Compatible":
                    return "source-over";
                  case "Multiply":
                    return "multiply";
                  case "Screen":
                    return "screen";
                  case "Overlay":
                    return "overlay";
                  case "Darken":
                    return "darken";
                  case "Lighten":
                    return "lighten";
                  case "ColorDodge":
                    return "color-dodge";
                  case "ColorBurn":
                    return "color-burn";
                  case "HardLight":
                    return "hard-light";
                  case "SoftLight":
                    return "soft-light";
                  case "Difference":
                    return "difference";
                  case "Exclusion":
                    return "exclusion";
                  case "Hue":
                    return "hue";
                  case "Saturation":
                    return "saturation";
                  case "Color":
                    return "color";
                  case "Luminosity":
                    return "luminosity";
                }
                (0, _util.warn)("Unsupported blend mode: " + value.name);
                return "source-over";
              }
              var deferred = Promise.resolve();
              var TILING_PATTERN = 1, SHADING_PATTERN = 2;
              PartialEvaluator2.prototype = {
                clone: function clone() {
                  var newOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DefaultPartialEvaluatorOptions;
                  var newEvaluator = Object.create(this);
                  newEvaluator.options = newOptions;
                  return newEvaluator;
                },
                hasBlendModes: function PartialEvaluator_hasBlendModes(resources) {
                  if (!(0, _primitives.isDict)(resources)) {
                    return false;
                  }
                  var processed = /* @__PURE__ */ Object.create(null);
                  if (resources.objId) {
                    processed[resources.objId] = true;
                  }
                  var nodes = [resources], xref = this.xref;
                  while (nodes.length) {
                    var key, i, ii;
                    var node = nodes.shift();
                    var graphicStates = node.get("ExtGState");
                    if ((0, _primitives.isDict)(graphicStates)) {
                      var graphicStatesKeys = graphicStates.getKeys();
                      for (i = 0, ii = graphicStatesKeys.length; i < ii; i++) {
                        key = graphicStatesKeys[i];
                        var graphicState = graphicStates.get(key);
                        var bm = graphicState.get("BM");
                        if ((0, _primitives.isName)(bm) && bm.name !== "Normal") {
                          return true;
                        }
                      }
                    }
                    var xObjects = node.get("XObject");
                    if (!(0, _primitives.isDict)(xObjects)) {
                      continue;
                    }
                    var xObjectsKeys = xObjects.getKeys();
                    for (i = 0, ii = xObjectsKeys.length; i < ii; i++) {
                      key = xObjectsKeys[i];
                      var xObject = xObjects.getRaw(key);
                      if ((0, _primitives.isRef)(xObject)) {
                        if (processed[xObject.toString()]) {
                          continue;
                        }
                        xObject = xref.fetch(xObject);
                      }
                      if (!(0, _primitives.isStream)(xObject)) {
                        continue;
                      }
                      if (xObject.dict.objId) {
                        if (processed[xObject.dict.objId]) {
                          continue;
                        }
                        processed[xObject.dict.objId] = true;
                      }
                      var xResources = xObject.dict.get("Resources");
                      if ((0, _primitives.isDict)(xResources) && (!xResources.objId || !processed[xResources.objId])) {
                        nodes.push(xResources);
                        if (xResources.objId) {
                          processed[xResources.objId] = true;
                        }
                      }
                    }
                  }
                  return false;
                },
                buildFormXObject: function PartialEvaluator_buildFormXObject(resources, xobj, smask, operatorList, task, initialState) {
                  var dict = xobj.dict;
                  var matrix = dict.getArray("Matrix");
                  var bbox = dict.getArray("BBox");
                  var group = dict.get("Group");
                  if (group) {
                    var groupOptions = {
                      matrix,
                      bbox,
                      smask,
                      isolated: false,
                      knockout: false
                    };
                    var groupSubtype = group.get("S");
                    var colorSpace = null;
                    if ((0, _primitives.isName)(groupSubtype, "Transparency")) {
                      groupOptions.isolated = group.get("I") || false;
                      groupOptions.knockout = group.get("K") || false;
                      if (group.has("CS")) {
                        colorSpace = _colorspace.ColorSpace.parse(group.get("CS"), this.xref, resources, this.pdfFunctionFactory);
                      }
                    }
                    if (smask && smask.backdrop) {
                      colorSpace = colorSpace || _colorspace.ColorSpace.singletons.rgb;
                      smask.backdrop = colorSpace.getRgb(smask.backdrop, 0);
                    }
                    operatorList.addOp(_util.OPS.beginGroup, [groupOptions]);
                  }
                  operatorList.addOp(_util.OPS.paintFormXObjectBegin, [matrix, bbox]);
                  return this.getOperatorList({
                    stream: xobj,
                    task,
                    resources: dict.get("Resources") || resources,
                    operatorList,
                    initialState
                  }).then(function() {
                    operatorList.addOp(_util.OPS.paintFormXObjectEnd, []);
                    if (group) {
                      operatorList.addOp(_util.OPS.endGroup, [groupOptions]);
                    }
                  });
                },
                buildPaintImageXObject: function PartialEvaluator_buildPaintImageXObject(resources, image, inline, operatorList, cacheKey, imageCache) {
                  var _this2 = this;
                  var dict = image.dict;
                  var w = dict.get("Width", "W");
                  var h = dict.get("Height", "H");
                  if (!(w && (0, _util.isNum)(w)) || !(h && (0, _util.isNum)(h))) {
                    (0, _util.warn)("Image dimensions are missing, or not numbers.");
                    return;
                  }
                  var maxImageSize = this.options.maxImageSize;
                  if (maxImageSize !== -1 && w * h > maxImageSize) {
                    (0, _util.warn)("Image exceeded maximum allowed size and was removed.");
                    return;
                  }
                  var imageMask = dict.get("ImageMask", "IM") || false;
                  var imgData, args;
                  if (imageMask) {
                    var width = dict.get("Width", "W");
                    var height = dict.get("Height", "H");
                    var bitStrideLength = width + 7 >> 3;
                    var imgArray = image.getBytes(bitStrideLength * height);
                    var decode = dict.getArray("Decode", "D");
                    imgData = _image.PDFImage.createMask({
                      imgArray,
                      width,
                      height,
                      imageIsFromDecodeStream: image instanceof _stream.DecodeStream,
                      inverseDecode: !!decode && decode[0] > 0
                    });
                    imgData.cached = true;
                    args = [imgData];
                    operatorList.addOp(_util.OPS.paintImageMaskXObject, args);
                    if (cacheKey) {
                      imageCache[cacheKey] = {
                        fn: _util.OPS.paintImageMaskXObject,
                        args
                      };
                    }
                    return;
                  }
                  var softMask = dict.get("SMask", "SM") || false;
                  var mask = dict.get("Mask") || false;
                  var SMALL_IMAGE_DIMENSIONS = 200;
                  if (inline && !softMask && !mask && !(image instanceof _stream.JpegStream) && w + h < SMALL_IMAGE_DIMENSIONS) {
                    var imageObj = new _image.PDFImage({
                      xref: this.xref,
                      res: resources,
                      image,
                      pdfFunctionFactory: this.pdfFunctionFactory
                    });
                    imgData = imageObj.createImageData(true);
                    operatorList.addOp(_util.OPS.paintInlineImageXObject, [imgData]);
                    return;
                  }
                  var nativeImageDecoderSupport = this.options.nativeImageDecoderSupport;
                  var objId = "img_" + this.idFactory.createObjId();
                  operatorList.addDependency(objId);
                  args = [objId, w, h];
                  if (nativeImageDecoderSupport !== _util.NativeImageDecoding.NONE && !softMask && !mask && image instanceof _stream.JpegStream && NativeImageDecoder.isSupported(image, this.xref, resources, this.pdfFunctionFactory)) {
                    operatorList.addOp(_util.OPS.paintJpegXObject, args);
                    this.handler.send("obj", [objId, this.pageIndex, "JpegStream", image.getIR(this.options.forceDataSchema)]);
                    if (cacheKey) {
                      imageCache[cacheKey] = {
                        fn: _util.OPS.paintJpegXObject,
                        args
                      };
                    }
                    return;
                  }
                  var nativeImageDecoder = null;
                  if (nativeImageDecoderSupport === _util.NativeImageDecoding.DECODE && (image instanceof _stream.JpegStream || mask instanceof _stream.JpegStream || softMask instanceof _stream.JpegStream)) {
                    nativeImageDecoder = new NativeImageDecoder({
                      xref: this.xref,
                      resources,
                      handler: this.handler,
                      forceDataSchema: this.options.forceDataSchema,
                      pdfFunctionFactory: this.pdfFunctionFactory
                    });
                  }
                  _image.PDFImage.buildImage({
                    handler: this.handler,
                    xref: this.xref,
                    res: resources,
                    image,
                    nativeDecoder: nativeImageDecoder,
                    pdfFunctionFactory: this.pdfFunctionFactory
                  }).then(function(imageObj2) {
                    var imgData2 = imageObj2.createImageData(false);
                    _this2.handler.send("obj", [objId, _this2.pageIndex, "Image", imgData2], [imgData2.data.buffer]);
                  }).catch(function(reason) {
                    (0, _util.warn)("Unable to decode image: " + reason);
                    _this2.handler.send("obj", [objId, _this2.pageIndex, "Image", null]);
                  });
                  operatorList.addOp(_util.OPS.paintImageXObject, args);
                  if (cacheKey) {
                    imageCache[cacheKey] = {
                      fn: _util.OPS.paintImageXObject,
                      args
                    };
                  }
                },
                handleSMask: function PartialEvaluator_handleSmask(smask, resources, operatorList, task, stateManager) {
                  var smaskContent = smask.get("G");
                  var smaskOptions = {
                    subtype: smask.get("S").name,
                    backdrop: smask.get("BC")
                  };
                  var transferObj = smask.get("TR");
                  if ((0, _function.isPDFFunction)(transferObj)) {
                    var transferFn = this.pdfFunctionFactory.create(transferObj);
                    var transferMap = new Uint8Array(256);
                    var tmp = new Float32Array(1);
                    for (var i = 0; i < 256; i++) {
                      tmp[0] = i / 255;
                      transferFn(tmp, 0, tmp, 0);
                      transferMap[i] = tmp[0] * 255 | 0;
                    }
                    smaskOptions.transferMap = transferMap;
                  }
                  return this.buildFormXObject(resources, smaskContent, smaskOptions, operatorList, task, stateManager.state.clone());
                },
                handleTilingType: function handleTilingType(fn, args, resources, pattern, patternDict, operatorList, task) {
                  var _this3 = this;
                  var tilingOpList = new OperatorList();
                  var resourcesArray = [patternDict.get("Resources"), resources];
                  var patternResources = _primitives.Dict.merge(this.xref, resourcesArray);
                  return this.getOperatorList({
                    stream: pattern,
                    task,
                    resources: patternResources,
                    operatorList: tilingOpList
                  }).then(function() {
                    return (0, _pattern.getTilingPatternIR)({
                      fnArray: tilingOpList.fnArray,
                      argsArray: tilingOpList.argsArray
                    }, patternDict, args);
                  }).then(function(tilingPatternIR) {
                    operatorList.addDependencies(tilingOpList.dependencies);
                    operatorList.addOp(fn, tilingPatternIR);
                  }, function(reason) {
                    if (_this3.options.ignoreErrors) {
                      _this3.handler.send("UnsupportedFeature", { featureId: _util.UNSUPPORTED_FEATURES.unknown });
                      (0, _util.warn)('handleTilingType - ignoring pattern: "' + reason + '".');
                      return;
                    }
                    throw reason;
                  });
                },
                handleSetFont: function PartialEvaluator_handleSetFont(resources, fontArgs, fontRef, operatorList, task, state) {
                  var _this4 = this;
                  var fontName;
                  if (fontArgs) {
                    fontArgs = fontArgs.slice();
                    fontName = fontArgs[0].name;
                  }
                  return this.loadFont(fontName, fontRef, resources).then(function(translated) {
                    if (!translated.font.isType3Font) {
                      return translated;
                    }
                    return translated.loadType3Data(_this4, resources, operatorList, task).then(function() {
                      return translated;
                    }).catch(function(reason) {
                      _this4.handler.send("UnsupportedFeature", { featureId: _util.UNSUPPORTED_FEATURES.font });
                      return new TranslatedFont("g_font_error", new _fonts.ErrorFont("Type3 font load error: " + reason), translated.font);
                    });
                  }).then(function(translated) {
                    state.font = translated.font;
                    translated.send(_this4.handler);
                    return translated.loadedName;
                  });
                },
                handleText: function PartialEvaluator_handleText(chars, state) {
                  var _this5 = this;
                  var font = state.font;
                  var glyphs = font.charsToGlyphs(chars);
                  var isAddToPathSet = !!(state.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
                  if (font.data && (isAddToPathSet || this.options.disableFontFace)) {
                    var buildPath = function buildPath2(fontChar) {
                      if (!font.renderer.hasBuiltPath(fontChar)) {
                        var path = font.renderer.getPathJs(fontChar);
                        _this5.handler.send("commonobj", [font.loadedName + "_path_" + fontChar, "FontPath", path]);
                      }
                    };
                    for (var i = 0, ii = glyphs.length; i < ii; i++) {
                      var glyph = glyphs[i];
                      buildPath(glyph.fontChar);
                      var accent = glyph.accent;
                      if (accent && accent.fontChar) {
                        buildPath(accent.fontChar);
                      }
                    }
                  }
                  return glyphs;
                },
                setGState: function PartialEvaluator_setGState(resources, gState, operatorList, task, stateManager) {
                  var _this6 = this;
                  var gStateObj = [];
                  var gStateKeys = gState.getKeys();
                  var promise = Promise.resolve();
                  var _loop = function _loop2() {
                    var key = gStateKeys[i];
                    var value = gState.get(key);
                    switch (key) {
                      case "Type":
                        break;
                      case "LW":
                      case "LC":
                      case "LJ":
                      case "ML":
                      case "D":
                      case "RI":
                      case "FL":
                      case "CA":
                      case "ca":
                        gStateObj.push([key, value]);
                        break;
                      case "Font":
                        promise = promise.then(function() {
                          return _this6.handleSetFont(resources, null, value[0], operatorList, task, stateManager.state).then(function(loadedName) {
                            operatorList.addDependency(loadedName);
                            gStateObj.push([key, [loadedName, value[1]]]);
                          });
                        });
                        break;
                      case "BM":
                        gStateObj.push([key, normalizeBlendMode(value)]);
                        break;
                      case "SMask":
                        if ((0, _primitives.isName)(value, "None")) {
                          gStateObj.push([key, false]);
                          break;
                        }
                        if ((0, _primitives.isDict)(value)) {
                          promise = promise.then(function() {
                            return _this6.handleSMask(value, resources, operatorList, task, stateManager);
                          });
                          gStateObj.push([key, true]);
                        } else {
                          (0, _util.warn)("Unsupported SMask type");
                        }
                        break;
                      case "OP":
                      case "op":
                      case "OPM":
                      case "BG":
                      case "BG2":
                      case "UCR":
                      case "UCR2":
                      case "TR":
                      case "TR2":
                      case "HT":
                      case "SM":
                      case "SA":
                      case "AIS":
                      case "TK":
                        (0, _util.info)("graphic state operator " + key);
                        break;
                      default:
                        (0, _util.info)("Unknown graphic state operator " + key);
                        break;
                    }
                  };
                  for (var i = 0, ii = gStateKeys.length; i < ii; i++) {
                    _loop();
                  }
                  return promise.then(function() {
                    if (gStateObj.length > 0) {
                      operatorList.addOp(_util.OPS.setGState, [gStateObj]);
                    }
                  });
                },
                loadFont: function PartialEvaluator_loadFont(fontName, font, resources) {
                  var _this7 = this;
                  function errorFont() {
                    return Promise.resolve(new TranslatedFont("g_font_error", new _fonts.ErrorFont("Font " + fontName + " is not available"), font));
                  }
                  var fontRef, xref = this.xref;
                  if (font) {
                    if (!(0, _primitives.isRef)(font)) {
                      throw new Error('The "font" object should be a reference.');
                    }
                    fontRef = font;
                  } else {
                    var fontRes = resources.get("Font");
                    if (fontRes) {
                      fontRef = fontRes.getRaw(fontName);
                    } else {
                      (0, _util.warn)("fontRes not available");
                      return errorFont();
                    }
                  }
                  if (!fontRef) {
                    (0, _util.warn)("fontRef not available");
                    return errorFont();
                  }
                  if (this.fontCache.has(fontRef)) {
                    return this.fontCache.get(fontRef);
                  }
                  font = xref.fetchIfRef(fontRef);
                  if (!(0, _primitives.isDict)(font)) {
                    return errorFont();
                  }
                  if (font.translated) {
                    return font.translated;
                  }
                  var fontCapability = (0, _util.createPromiseCapability)();
                  var preEvaluatedFont = this.preEvaluateFont(font);
                  var descriptor = preEvaluatedFont.descriptor;
                  var fontRefIsRef = (0, _primitives.isRef)(fontRef), fontID;
                  if (fontRefIsRef) {
                    fontID = fontRef.toString();
                  }
                  if ((0, _primitives.isDict)(descriptor)) {
                    if (!descriptor.fontAliases) {
                      descriptor.fontAliases = /* @__PURE__ */ Object.create(null);
                    }
                    var fontAliases = descriptor.fontAliases;
                    var hash = preEvaluatedFont.hash;
                    if (fontAliases[hash]) {
                      var aliasFontRef = fontAliases[hash].aliasRef;
                      if (fontRefIsRef && aliasFontRef && this.fontCache.has(aliasFontRef)) {
                        this.fontCache.putAlias(fontRef, aliasFontRef);
                        return this.fontCache.get(fontRef);
                      }
                    } else {
                      fontAliases[hash] = { fontID: _fonts.Font.getFontID() };
                    }
                    if (fontRefIsRef) {
                      fontAliases[hash].aliasRef = fontRef;
                    }
                    fontID = fontAliases[hash].fontID;
                  }
                  if (fontRefIsRef) {
                    this.fontCache.put(fontRef, fontCapability.promise);
                  } else {
                    if (!fontID) {
                      fontID = this.idFactory.createObjId();
                    }
                    this.fontCache.put("id_" + fontID, fontCapability.promise);
                  }
                  (0, _util.assert)(fontID, 'The "fontID" must be defined.');
                  font.loadedName = "g_" + this.pdfManager.docId + "_f" + fontID;
                  font.translated = fontCapability.promise;
                  var translatedPromise;
                  try {
                    translatedPromise = this.translateFont(preEvaluatedFont);
                  } catch (e) {
                    translatedPromise = Promise.reject(e);
                  }
                  translatedPromise.then(function(translatedFont) {
                    if (translatedFont.fontType !== void 0) {
                      var xrefFontStats = xref.stats.fontTypes;
                      xrefFontStats[translatedFont.fontType] = true;
                    }
                    fontCapability.resolve(new TranslatedFont(font.loadedName, translatedFont, font));
                  }).catch(function(reason) {
                    _this7.handler.send("UnsupportedFeature", { featureId: _util.UNSUPPORTED_FEATURES.font });
                    try {
                      var descriptor2 = preEvaluatedFont.descriptor;
                      var fontFile3 = descriptor2 && descriptor2.get("FontFile3");
                      var subtype = fontFile3 && fontFile3.get("Subtype");
                      var fontType = (0, _fonts.getFontType)(preEvaluatedFont.type, subtype && subtype.name);
                      var xrefFontStats = xref.stats.fontTypes;
                      xrefFontStats[fontType] = true;
                    } catch (ex) {
                    }
                    fontCapability.resolve(new TranslatedFont(font.loadedName, new _fonts.ErrorFont(reason instanceof Error ? reason.message : reason), font));
                  });
                  return fontCapability.promise;
                },
                buildPath: function PartialEvaluator_buildPath(operatorList, fn, args) {
                  var lastIndex = operatorList.length - 1;
                  if (!args) {
                    args = [];
                  }
                  if (lastIndex < 0 || operatorList.fnArray[lastIndex] !== _util.OPS.constructPath) {
                    operatorList.addOp(_util.OPS.constructPath, [[fn], args]);
                  } else {
                    var opArgs = operatorList.argsArray[lastIndex];
                    opArgs[0].push(fn);
                    Array.prototype.push.apply(opArgs[1], args);
                  }
                },
                handleColorN: function PartialEvaluator_handleColorN(operatorList, fn, args, cs, patterns, resources, task) {
                  var patternName = args[args.length - 1];
                  var pattern;
                  if ((0, _primitives.isName)(patternName) && (pattern = patterns.get(patternName.name))) {
                    var dict = (0, _primitives.isStream)(pattern) ? pattern.dict : pattern;
                    var typeNum = dict.get("PatternType");
                    if (typeNum === TILING_PATTERN) {
                      var color = cs.base ? cs.base.getRgb(args, 0) : null;
                      return this.handleTilingType(fn, color, resources, pattern, dict, operatorList, task);
                    } else if (typeNum === SHADING_PATTERN) {
                      var shading = dict.get("Shading");
                      var matrix = dict.getArray("Matrix");
                      pattern = _pattern.Pattern.parseShading(shading, matrix, this.xref, resources, this.handler, this.pdfFunctionFactory);
                      operatorList.addOp(fn, pattern.getIR());
                      return Promise.resolve();
                    }
                    return Promise.reject(new Error("Unknown PatternType: " + typeNum));
                  }
                  operatorList.addOp(fn, args);
                  return Promise.resolve();
                },
                getOperatorList: function getOperatorList(_ref3) {
                  var _this8 = this;
                  var stream = _ref3.stream, task = _ref3.task, resources = _ref3.resources, operatorList = _ref3.operatorList, _ref3$initialState = _ref3.initialState, initialState = _ref3$initialState === void 0 ? null : _ref3$initialState;
                  resources = resources || _primitives.Dict.empty;
                  initialState = initialState || new EvalState();
                  if (!operatorList) {
                    throw new Error('getOperatorList: missing "operatorList" parameter');
                  }
                  var self2 = this;
                  var xref = this.xref;
                  var imageCache = /* @__PURE__ */ Object.create(null);
                  var xobjs = resources.get("XObject") || _primitives.Dict.empty;
                  var patterns = resources.get("Pattern") || _primitives.Dict.empty;
                  var stateManager = new StateManager(initialState);
                  var preprocessor = new EvaluatorPreprocessor(stream, xref, stateManager);
                  var timeSlotManager = new TimeSlotManager();
                  function closePendingRestoreOPS(argument) {
                    for (var i = 0, ii = preprocessor.savedStatesDepth; i < ii; i++) {
                      operatorList.addOp(_util.OPS.restore, []);
                    }
                  }
                  return new Promise(function promiseBody(resolve, reject) {
                    var next = function next2(promise) {
                      promise.then(function() {
                        try {
                          promiseBody(resolve, reject);
                        } catch (ex) {
                          reject(ex);
                        }
                      }, reject);
                    };
                    task.ensureNotTerminated();
                    timeSlotManager.reset();
                    var stop, operation = {}, i, ii, cs;
                    while (!(stop = timeSlotManager.check())) {
                      operation.args = null;
                      if (!preprocessor.read(operation)) {
                        break;
                      }
                      var args = operation.args;
                      var fn = operation.fn;
                      switch (fn | 0) {
                        case _util.OPS.paintXObject:
                          var name = args[0].name;
                          if (name && imageCache[name] !== void 0) {
                            operatorList.addOp(imageCache[name].fn, imageCache[name].args);
                            args = null;
                            continue;
                          }
                          next(new Promise(function(resolveXObject, rejectXObject) {
                            if (!name) {
                              throw new _util.FormatError("XObject must be referred to by name.");
                            }
                            var xobj = xobjs.get(name);
                            if (!xobj) {
                              operatorList.addOp(fn, args);
                              resolveXObject();
                              return;
                            }
                            if (!(0, _primitives.isStream)(xobj)) {
                              throw new _util.FormatError("XObject should be a stream");
                            }
                            var type = xobj.dict.get("Subtype");
                            if (!(0, _primitives.isName)(type)) {
                              throw new _util.FormatError("XObject should have a Name subtype");
                            }
                            if (type.name === "Form") {
                              stateManager.save();
                              self2.buildFormXObject(resources, xobj, null, operatorList, task, stateManager.state.clone()).then(function() {
                                stateManager.restore();
                                resolveXObject();
                              }, rejectXObject);
                              return;
                            } else if (type.name === "Image") {
                              self2.buildPaintImageXObject(resources, xobj, false, operatorList, name, imageCache);
                            } else if (type.name === "PS") {
                              (0, _util.info)("Ignored XObject subtype PS");
                            } else {
                              throw new _util.FormatError("Unhandled XObject subtype " + type.name);
                            }
                            resolveXObject();
                          }).catch(function(reason) {
                            if (self2.options.ignoreErrors) {
                              self2.handler.send("UnsupportedFeature", { featureId: _util.UNSUPPORTED_FEATURES.unknown });
                              (0, _util.warn)('getOperatorList - ignoring XObject: "' + reason + '".');
                              return;
                            }
                            throw reason;
                          }));
                          return;
                        case _util.OPS.setFont:
                          var fontSize = args[1];
                          next(self2.handleSetFont(resources, args, null, operatorList, task, stateManager.state).then(function(loadedName) {
                            operatorList.addDependency(loadedName);
                            operatorList.addOp(_util.OPS.setFont, [loadedName, fontSize]);
                          }));
                          return;
                        case _util.OPS.endInlineImage:
                          var cacheKey = args[0].cacheKey;
                          if (cacheKey) {
                            var cacheEntry = imageCache[cacheKey];
                            if (cacheEntry !== void 0) {
                              operatorList.addOp(cacheEntry.fn, cacheEntry.args);
                              args = null;
                              continue;
                            }
                          }
                          self2.buildPaintImageXObject(resources, args[0], true, operatorList, cacheKey, imageCache);
                          args = null;
                          continue;
                        case _util.OPS.showText:
                          args[0] = self2.handleText(args[0], stateManager.state);
                          break;
                        case _util.OPS.showSpacedText:
                          var arr = args[0];
                          var combinedGlyphs = [];
                          var arrLength = arr.length;
                          var state = stateManager.state;
                          for (i = 0; i < arrLength; ++i) {
                            var arrItem = arr[i];
                            if ((0, _util.isString)(arrItem)) {
                              Array.prototype.push.apply(combinedGlyphs, self2.handleText(arrItem, state));
                            } else if ((0, _util.isNum)(arrItem)) {
                              combinedGlyphs.push(arrItem);
                            }
                          }
                          args[0] = combinedGlyphs;
                          fn = _util.OPS.showText;
                          break;
                        case _util.OPS.nextLineShowText:
                          operatorList.addOp(_util.OPS.nextLine);
                          args[0] = self2.handleText(args[0], stateManager.state);
                          fn = _util.OPS.showText;
                          break;
                        case _util.OPS.nextLineSetSpacingShowText:
                          operatorList.addOp(_util.OPS.nextLine);
                          operatorList.addOp(_util.OPS.setWordSpacing, [args.shift()]);
                          operatorList.addOp(_util.OPS.setCharSpacing, [args.shift()]);
                          args[0] = self2.handleText(args[0], stateManager.state);
                          fn = _util.OPS.showText;
                          break;
                        case _util.OPS.setTextRenderingMode:
                          stateManager.state.textRenderingMode = args[0];
                          break;
                        case _util.OPS.setFillColorSpace:
                          stateManager.state.fillColorSpace = _colorspace.ColorSpace.parse(args[0], xref, resources, self2.pdfFunctionFactory);
                          continue;
                        case _util.OPS.setStrokeColorSpace:
                          stateManager.state.strokeColorSpace = _colorspace.ColorSpace.parse(args[0], xref, resources, self2.pdfFunctionFactory);
                          continue;
                        case _util.OPS.setFillColor:
                          cs = stateManager.state.fillColorSpace;
                          args = cs.getRgb(args, 0);
                          fn = _util.OPS.setFillRGBColor;
                          break;
                        case _util.OPS.setStrokeColor:
                          cs = stateManager.state.strokeColorSpace;
                          args = cs.getRgb(args, 0);
                          fn = _util.OPS.setStrokeRGBColor;
                          break;
                        case _util.OPS.setFillGray:
                          stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.gray;
                          args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
                          fn = _util.OPS.setFillRGBColor;
                          break;
                        case _util.OPS.setStrokeGray:
                          stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.gray;
                          args = _colorspace.ColorSpace.singletons.gray.getRgb(args, 0);
                          fn = _util.OPS.setStrokeRGBColor;
                          break;
                        case _util.OPS.setFillCMYKColor:
                          stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.cmyk;
                          args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
                          fn = _util.OPS.setFillRGBColor;
                          break;
                        case _util.OPS.setStrokeCMYKColor:
                          stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.cmyk;
                          args = _colorspace.ColorSpace.singletons.cmyk.getRgb(args, 0);
                          fn = _util.OPS.setStrokeRGBColor;
                          break;
                        case _util.OPS.setFillRGBColor:
                          stateManager.state.fillColorSpace = _colorspace.ColorSpace.singletons.rgb;
                          args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
                          break;
                        case _util.OPS.setStrokeRGBColor:
                          stateManager.state.strokeColorSpace = _colorspace.ColorSpace.singletons.rgb;
                          args = _colorspace.ColorSpace.singletons.rgb.getRgb(args, 0);
                          break;
                        case _util.OPS.setFillColorN:
                          cs = stateManager.state.fillColorSpace;
                          if (cs.name === "Pattern") {
                            next(self2.handleColorN(operatorLi