import {
  __commonJS,
  __esm,
  __glob,
  __require
} from "./chunk-PWCYJDAR.js";

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/node-ensure/browser.js
var require_browser = __commonJS({
  "node_modules/node-ensure/browser.js"(exports, module) {
    module.exports = function() {
      __require.ensure.apply(this, arguments);
    };
  }
});

// node_modules/pdf-parse/lib/pdf.js/v1.10.100/build/pdf.worker.js
var require_pdf_worker = __commonJS({
  "node_modules/pdf-parse/lib/pdf.js/v1.10.100/build/pdf.worker.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("pdfjs-dist/build/pdf.worker", [], factory);
      else if (typeof exports === "object")
        exports["pdfjs-dist/build/pdf.worker"] = factory();
      else
        root["pdfjs-dist/build/pdf.worker"] = root.pdfjsDistBuildPdfWorker = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __w_pdfjs_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __w_pdfjs_require__);
            module2.l = true;
            return module2.exports;
          }
          __w_pdfjs_require__.m = modules;
          __w_pdfjs_require__.c = installedModules;
          __w_pdfjs_require__.d = function(exports2, name, getter) {
            if (!__w_pdfjs_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __w_pdfjs_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __w_pdfjs_require__.d(getter, "a", getter);
            return getter;
          };
          __w_pdfjs_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __w_pdfjs_require__.p = "";
          return __w_pdfjs_require__(__w_pdfjs_require__.s = 82);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.unreachable = exports2.warn = exports2.utf8StringToString = exports2.stringToUTF8String = exports2.stringToPDFString = exports2.stringToBytes = exports2.string32 = exports2.shadow = exports2.setVerbosityLevel = exports2.ReadableStream = exports2.removeNullCharacters = exports2.readUint32 = exports2.readUint16 = exports2.readInt8 = exports2.log2 = exports2.loadJpegStream = exports2.isEvalSupported = exports2.isLittleEndian = exports2.createValidAbsoluteUrl = exports2.isSameOrigin = exports2.isNodeJS = exports2.isSpace = exports2.isString = exports2.isNum = exports2.isEmptyObj = exports2.isBool = exports2.isArrayBuffer = exports2.info = exports2.getVerbosityLevel = exports2.getLookupTableFactory = exports2.deprecated = exports2.createObjectURL = exports2.createPromiseCapability = exports2.createBlob = exports2.bytesToString = exports2.assert = exports2.arraysToBytes = exports2.arrayByteLength = exports2.FormatError = exports2.XRefParseException = exports2.Util = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.TextRenderingMode = exports2.StreamType = exports2.StatTimer = exports2.PasswordResponses = exports2.PasswordException = exports2.PageViewport = exports2.NotImplementedException = exports2.NativeImageDecoding = exports2.MissingPDFException = exports2.MissingDataException = exports2.MessageHandler = exports2.InvalidPDFException = exports2.AbortException = exports2.CMapCompressionType = exports2.ImageKind = exports2.FontType = exports2.AnnotationType = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationBorderStyleType = exports2.UNSUPPORTED_FEATURES = exports2.VERBOSITY_LEVELS = exports2.OPS = exports2.IDENTITY_MATRIX = exports2.FONT_IDENTITY_MATRIX = void 0;
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            __w_pdfjs_require__(84);
            var _streams_polyfill = __w_pdfjs_require__(125);
            var FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
            var NativeImageDecoding = {
              NONE: "none",
              DECODE: "decode",
              DISPLAY: "display"
            };
            var TextRenderingMode = {
              FILL: 0,
              STROKE: 1,
              FILL_STROKE: 2,
              INVISIBLE: 3,
              FILL_ADD_TO_PATH: 4,
              STROKE_ADD_TO_PATH: 5,
              FILL_STROKE_ADD_TO_PATH: 6,
              ADD_TO_PATH: 7,
              FILL_STROKE_MASK: 3,
              ADD_TO_PATH_FLAG: 4
            };
            var ImageKind = {
              GRAYSCALE_1BPP: 1,
              RGB_24BPP: 2,
              RGBA_32BPP: 3
            };
            var AnnotationType = {
              TEXT: 1,
              LINK: 2,
              FREETEXT: 3,
              LINE: 4,
              SQUARE: 5,
              CIRCLE: 6,
              POLYGON: 7,
              POLYLINE: 8,
              HIGHLIGHT: 9,
              UNDERLINE: 10,
              SQUIGGLY: 11,
              STRIKEOUT: 12,
              STAMP: 13,
              CARET: 14,
              INK: 15,
              POPUP: 16,
              FILEATTACHMENT: 17,
              SOUND: 18,
              MOVIE: 19,
              WIDGET: 20,
              SCREEN: 21,
              PRINTERMARK: 22,
              TRAPNET: 23,
              WATERMARK: 24,
              THREED: 25,
              REDACT: 26
            };
            var AnnotationFlag = {
              INVISIBLE: 1,
              HIDDEN: 2,
              PRINT: 4,
              NOZOOM: 8,
              NOROTATE: 16,
              NOVIEW: 32,
              READONLY: 64,
              LOCKED: 128,
              TOGGLENOVIEW: 256,
              LOCKEDCONTENTS: 512
            };
            var AnnotationFieldFlag = {
              READONLY: 1,
              REQUIRED: 2,
              NOEXPORT: 4,
              MULTILINE: 4096,
              PASSWORD: 8192,
              NOTOGGLETOOFF: 16384,
              RADIO: 32768,
              PUSHBUTTON: 65536,
              COMBO: 131072,
              EDIT: 262144,
              SORT: 524288,
              FILESELECT: 1048576,
              MULTISELECT: 2097152,
              DONOTSPELLCHECK: 4194304,
              DONOTSCROLL: 8388608,
              COMB: 16777216,
              RICHTEXT: 33554432,
              RADIOSINUNISON: 33554432,
              COMMITONSELCHANGE: 67108864
            };
            var AnnotationBorderStyleType = {
              SOLID: 1,
              DASHED: 2,
              BEVELED: 3,
              INSET: 4,
              UNDERLINE: 5
            };
            var StreamType = {
              UNKNOWN: 0,
              FLATE: 1,
              LZW: 2,
              DCT: 3,
              JPX: 4,
              JBIG: 5,
              A85: 6,
              AHX: 7,
              CCF: 8,
              RL: 9
            };
            var FontType = {
              UNKNOWN: 0,
              TYPE1: 1,
              TYPE1C: 2,
              CIDFONTTYPE0: 3,
              CIDFONTTYPE0C: 4,
              TRUETYPE: 5,
              CIDFONTTYPE2: 6,
              TYPE3: 7,
              OPENTYPE: 8,
              TYPE0: 9,
              MMTYPE1: 10
            };
            var VERBOSITY_LEVELS = {
              errors: 0,
              warnings: 1,
              infos: 5
            };
            var CMapCompressionType = {
              NONE: 0,
              BINARY: 1,
              STREAM: 2
            };
            var OPS = {
              dependency: 1,
              setLineWidth: 2,
              setLineCap: 3,
              setLineJoin: 4,
              setMiterLimit: 5,
              setDash: 6,
              setRenderingIntent: 7,
              setFlatness: 8,
              setGState: 9,
              save: 10,
              restore: 11,
              transform: 12,
              moveTo: 13,
              lineTo: 14,
              curveTo: 15,
              curveTo2: 16,
              curveTo3: 17,
              closePath: 18,
              rectangle: 19,
              stroke: 20,
              closeStroke: 21,
              fill: 22,
              eoFill: 23,
              fillStroke: 24,
              eoFillStroke: 25,
              closeFillStroke: 26,
              closeEOFillStroke: 27,
              endPath: 28,
              clip: 29,
              eoClip: 30,
              beginText: 31,
              endText: 32,
              setCharSpacing: 33,
              setWordSpacing: 34,
              setHScale: 35,
              setLeading: 36,
              setFont: 37,
              setTextRenderingMode: 38,
              setTextRise: 39,
              moveText: 40,
              setLeadingMoveText: 41,
              setTextMatrix: 42,
              nextLine: 43,
              showText: 44,
              showSpacedText: 45,
              nextLineShowText: 46,
              nextLineSetSpacingShowText: 47,
              setCharWidth: 48,
              setCharWidthAndBounds: 49,
              setStrokeColorSpace: 50,
              setFillColorSpace: 51,
              setStrokeColor: 52,
              setStrokeColorN: 53,
              setFillColor: 54,
              setFillColorN: 55,
              setStrokeGray: 56,
              setFillGray: 57,
              setStrokeRGBColor: 58,
              setFillRGBColor: 59,
              setStrokeCMYKColor: 60,
              setFillCMYKColor: 61,
              shadingFill: 62,
              beginInlineImage: 63,
              beginImageData: 64,
              endInlineImage: 65,
              paintXObject: 66,
              markPoint: 67,
              markPointProps: 68,
              beginMarkedContent: 69,
              beginMarkedContentProps: 70,
              endMarkedContent: 71,
              beginCompat: 72,
              endCompat: 73,
              paintFormXObjectBegin: 74,
              paintFormXObjectEnd: 75,
              beginGroup: 76,
              endGroup: 77,
              beginAnnotations: 78,
              endAnnotations: 79,
              beginAnnotation: 80,
              endAnnotation: 81,
              paintJpegXObject: 82,
              paintImageMaskXObject: 83,
              paintImageMaskXObjectGroup: 84,
              paintImageXObject: 85,
              paintInlineImageXObject: 86,
              paintInlineImageXObjectGroup: 87,
              paintImageXObjectRepeat: 88,
              paintImageMaskXObjectRepeat: 89,
              paintSolidColorImageMask: 90,
              constructPath: 91
            };
            var verbosity = VERBOSITY_LEVELS.warnings;
            function setVerbosityLevel(level) {
              verbosity = level;
            }
            function getVerbosityLevel() {
              return verbosity;
            }
            function info(msg) {
              if (verbosity >= VERBOSITY_LEVELS.infos) {
                console.log("Info: " + msg);
              }
            }
            function warn(msg) {
              if (verbosity >= VERBOSITY_LEVELS.warnings) {
                console.log("Warning: " + msg);
              }
            }
            function deprecated(details) {
              console.log("Deprecated API usage: " + details);
            }
            function unreachable(msg) {
              throw new Error(msg);
            }
            function assert(cond, msg) {
              if (!cond) {
                unreachable(msg);
              }
            }
            var UNSUPPORTED_FEATURES = {
              unknown: "unknown",
              forms: "forms",
              javaScript: "javaScript",
              smask: "smask",
              shadingPattern: "shadingPattern",
              font: "font"
            };
            function isSameOrigin(baseUrl, otherUrl) {
              try {
                var base = new URL(baseUrl);
                if (!base.origin || base.origin === "null") {
                  return false;
                }
              } catch (e) {
                return false;
              }
              var other = new URL(otherUrl, base);
              return base.origin === other.origin;
            }
            function isValidProtocol(url) {
              if (!url) {
                return false;
              }
              switch (url.protocol) {
                case "http:":
                case "https:":
                case "ftp:":
                case "mailto:":
                case "tel:":
                  return true;
                default:
                  return false;
              }
            }
            function createValidAbsoluteUrl(url, baseUrl) {
              if (!url) {
                return null;
              }
              try {
                var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);
                if (isValidProtocol(absoluteUrl)) {
                  return absoluteUrl;
                }
              } catch (ex) {
              }
              return null;
            }
            function shadow(obj, prop, value) {
              Object.defineProperty(obj, prop, {
                value,
                enumerable: true,
                configurable: true,
                writable: false
              });
              return value;
            }
            function getLookupTableFactory(initializer) {
              var lookup;
              return function() {
                if (initializer) {
                  lookup = /* @__PURE__ */ Object.create(null);
                  initializer(lookup);
                  initializer = null;
                }
                return lookup;
              };
            }
            var PasswordResponses = {
              NEED_PASSWORD: 1,
              INCORRECT_PASSWORD: 2
            };
            var PasswordException = function PasswordExceptionClosure() {
              function PasswordException2(msg, code) {
                this.name = "PasswordException";
                this.message = msg;
                this.code = code;
              }
              PasswordException2.prototype = new Error();
              PasswordException2.constructor = PasswordException2;
              return PasswordException2;
            }();
            var UnknownErrorException = function UnknownErrorExceptionClosure() {
              function UnknownErrorException2(msg, details) {
                this.name = "UnknownErrorException";
                this.message = msg;
                this.details = details;
              }
              UnknownErrorException2.prototype = new Error();
              UnknownErrorException2.constructor = UnknownErrorException2;
              return UnknownErrorException2;
            }();
            var InvalidPDFException = function InvalidPDFExceptionClosure() {
              function InvalidPDFException2(msg) {
                this.name = "InvalidPDFException";
                this.message = msg;
              }
              InvalidPDFException2.prototype = new Error();
              InvalidPDFException2.constructor = InvalidPDFException2;
              return InvalidPDFException2;
            }();
            var MissingPDFException = function MissingPDFExceptionClosure() {
              function MissingPDFException2(msg) {
                this.name = "MissingPDFException";
                this.message = msg;
              }
              MissingPDFException2.prototype = new Error();
              MissingPDFException2.constructor = MissingPDFException2;
              return MissingPDFException2;
            }();
            var UnexpectedResponseException = function UnexpectedResponseExceptionClosure() {
              function UnexpectedResponseException2(msg, status) {
                this.name = "UnexpectedResponseException";
                this.message = msg;
                this.status = status;
              }
              UnexpectedResponseException2.prototype = new Error();
              UnexpectedResponseException2.constructor = UnexpectedResponseException2;
              return UnexpectedResponseException2;
            }();
            var NotImplementedException = function NotImplementedExceptionClosure() {
              function NotImplementedException2(msg) {
                this.message = msg;
              }
              NotImplementedException2.prototype = new Error();
              NotImplementedException2.prototype.name = "NotImplementedException";
              NotImplementedException2.constructor = NotImplementedException2;
              return NotImplementedException2;
            }();
            var MissingDataException = function MissingDataExceptionClosure() {
              function MissingDataException2(begin, end) {
                this.begin = begin;
                this.end = end;
                this.message = "Missing data [" + begin + ", " + end + ")";
              }
              MissingDataException2.prototype = new Error();
              MissingDataException2.prototype.name = "MissingDataException";
              MissingDataException2.constructor = MissingDataException2;
              return MissingDataException2;
            }();
            var XRefParseException = function XRefParseExceptionClosure() {
              function XRefParseException2(msg) {
                this.message = msg;
              }
              XRefParseException2.prototype = new Error();
              XRefParseException2.prototype.name = "XRefParseException";
              XRefParseException2.constructor = XRefParseException2;
              return XRefParseException2;
            }();
            var FormatError = function FormatErrorClosure() {
              function FormatError2(msg) {
                this.message = msg;
              }
              FormatError2.prototype = new Error();
              FormatError2.prototype.name = "FormatError";
              FormatError2.constructor = FormatError2;
              return FormatError2;
            }();
            var AbortException = function AbortExceptionClosure() {
              function AbortException2(msg) {
                this.name = "AbortException";
                this.message = msg;
              }
              AbortException2.prototype = new Error();
              AbortException2.constructor = AbortException2;
              return AbortException2;
            }();
            var NullCharactersRegExp = /\x00/g;
            function removeNullCharacters(str) {
              if (typeof str !== "string") {
                warn("The argument for removeNullCharacters must be a string.");
                return str;
              }
              return str.replace(NullCharactersRegExp, "");
            }
            function bytesToString(bytes) {
              assert(bytes !== null && (typeof bytes === "undefined" ? "undefined" : _typeof(bytes)) === "object" && bytes.length !== void 0, "Invalid argument for bytesToString");
              var length = bytes.length;
              var MAX_ARGUMENT_COUNT = 8192;
              if (length < MAX_ARGUMENT_COUNT) {
                return String.fromCharCode.apply(null, bytes);
              }
              var strBuf = [];
              for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
                var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
                var chunk = bytes.subarray(i, chunkEnd);
                strBuf.push(String.fromCharCode.apply(null, chunk));
              }
              return strBuf.join("");
            }
            function stringToBytes(str) {
              assert(typeof str === "string", "Invalid argument for stringToBytes");
              var length = str.length;
              var bytes = new Uint8Array(length);
              for (var i = 0; i < length; ++i) {
                bytes[i] = str.charCodeAt(i) & 255;
              }
              return bytes;
            }
            function arrayByteLength(arr) {
              if (arr.length !== void 0) {
                return arr.length;
              }
              assert(arr.byteLength !== void 0);
              return arr.byteLength;
            }
            function arraysToBytes(arr) {
              if (arr.length === 1 && arr[0] instanceof Uint8Array) {
                return arr[0];
              }
              var resultLength = 0;
              var i, ii = arr.length;
              var item, itemLength;
              for (i = 0; i < ii; i++) {
                item = arr[i];
                itemLength = arrayByteLength(item);
                resultLength += itemLength;
              }
              var pos = 0;
              var data = new Uint8Array(resultLength);
              for (i = 0; i < ii; i++) {
                item = arr[i];
                if (!(item instanceof Uint8Array)) {
                  if (typeof item === "string") {
                    item = stringToBytes(item);
                  } else {
                    item = new Uint8Array(item);
                  }
                }
                itemLength = item.byteLength;
                data.set(item, pos);
                pos += itemLength;
              }
              return data;
            }
            function string32(value) {
              return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
            }
            function log2(x) {
              var n = 1, i = 0;
              while (x > n) {
                n <<= 1;
                i++;
              }
              return i;
            }
            function readInt8(data, start) {
              return data[start] << 24 >> 24;
            }
            function readUint16(data, offset) {
              return data[offset] << 8 | data[offset + 1];
            }
            function readUint32(data, offset) {
              return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
            }
            function isLittleEndian() {
              var buffer8 = new Uint8Array(4);
              buffer8[0] = 1;
              var view32 = new Uint32Array(buffer8.buffer, 0, 1);
              return view32[0] === 1;
            }
            function isEvalSupported() {
              try {
                new Function("");
                return true;
              } catch (e) {
                return false;
              }
            }
            var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
            var Util = function UtilClosure() {
              function Util2() {
              }
              var rgbBuf = ["rgb(", 0, ",", 0, ",", 0, ")"];
              Util2.makeCssRgb = function Util_makeCssRgb(r, g, b) {
                rgbBuf[1] = r;
                rgbBuf[3] = g;
                rgbBuf[5] = b;
                return rgbBuf.join("");
              };
              Util2.transform = function Util_transform(m1, m2) {
                return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
              };
              Util2.applyTransform = function Util_applyTransform(p, m) {
                var xt = p[0] * m[0] + p[1] * m[2] + m[4];
                var yt = p[0] * m[1] + p[1] * m[3] + m[5];
                return [xt, yt];
              };
              Util2.applyInverseTransform = function Util_applyInverseTransform(p, m) {
                var d = m[0] * m[3] - m[1] * m[2];
                var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                return [xt, yt];
              };
              Util2.getAxialAlignedBoundingBox = function Util_getAxialAlignedBoundingBox(r, m) {
                var p1 = Util2.applyTransform(r, m);
                var p2 = Util2.applyTransform(r.slice(2, 4), m);
                var p3 = Util2.applyTransform([r[0], r[3]], m);
                var p4 = Util2.applyTransform([r[2], r[1]], m);
                return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
              };
              Util2.inverseTransform = function Util_inverseTransform(m) {
                var d = m[0] * m[3] - m[1] * m[2];
                return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
              };
              Util2.apply3dTransform = function Util_apply3dTransform(m, v) {
                return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
              };
              Util2.singularValueDecompose2dScale = function Util_singularValueDecompose2dScale(m) {
                var transpose = [m[0], m[2], m[1], m[3]];
                var a = m[0] * transpose[0] + m[1] * transpose[2];
                var b = m[0] * transpose[1] + m[1] * transpose[3];
                var c = m[2] * transpose[0] + m[3] * transpose[2];
                var d = m[2] * transpose[1] + m[3] * transpose[3];
                var first = (a + d) / 2;
                var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
                var sx = first + second || 1;
                var sy = first - second || 1;
                return [Math.sqrt(sx), Math.sqrt(sy)];
              };
              Util2.normalizeRect = function Util_normalizeRect(rect) {
                var r = rect.slice(0);
                if (rect[0] > rect[2]) {
                  r[0] = rect[2];
                  r[2] = rect[0];
                }
                if (rect[1] > rect[3]) {
                  r[1] = rect[3];
                  r[3] = rect[1];
                }
                return r;
              };
              Util2.intersect = function Util_intersect(rect1, rect2) {
                function compare(a, b) {
                  return a - b;
                }
                var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare), orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare), result = [];
                rect1 = Util2.normalizeRect(rect1);
                rect2 = Util2.normalizeRect(rect2);
                if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
                  result[0] = orderedX[1];
                  result[2] = orderedX[2];
                } else {
                  return false;
                }
                if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
                  result[1] = orderedY[1];
                  result[3] = orderedY[2];
                } else {
                  return false;
                }
                return result;
              };
              var ROMAN_NUMBER_MAP = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
              Util2.toRoman = function Util_toRoman(number, lowerCase) {
                assert(Number.isInteger(number) && number > 0, "The number should be a positive integer.");
                var pos, romanBuf = [];
                while (number >= 1e3) {
                  number -= 1e3;
                  romanBuf.push("M");
                }
                pos = number / 100 | 0;
                number %= 100;
                romanBuf.push(ROMAN_NUMBER_MAP[pos]);
                pos = number / 10 | 0;
                number %= 10;
                romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
                romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
                var romanStr = romanBuf.join("");
                return lowerCase ? romanStr.toLowerCase() : romanStr;
              };
              Util2.appendToArray = function Util_appendToArray(arr1, arr2) {
                Array.prototype.push.apply(arr1, arr2);
              };
              Util2.prependToArray = function Util_prependToArray(arr1, arr2) {
                Array.prototype.unshift.apply(arr1, arr2);
              };
              Util2.extendObj = function extendObj(obj1, obj2) {
                for (var key in obj2) {
                  obj1[key] = obj2[key];
                }
              };
              Util2.getInheritableProperty = function Util_getInheritableProperty(dict, name, getArray) {
                while (dict && !dict.has(name)) {
                  dict = dict.get("Parent");
                }
                if (!dict) {
                  return null;
                }
                return getArray ? dict.getArray(name) : dict.get(name);
              };
              Util2.inherit = function Util_inherit(sub, base, prototype) {
                sub.prototype = Object.create(base.prototype);
                sub.prototype.constructor = sub;
                for (var prop in prototype) {
                  sub.prototype[prop] = prototype[prop];
                }
              };
              Util2.loadScript = function Util_loadScript(src, callback) {
                var script = document.createElement("script");
                var loaded = false;
                script.setAttribute("src", src);
                if (callback) {
                  script.onload = function() {
                    if (!loaded) {
                      callback();
                    }
                    loaded = true;
                  };
                }
                document.getElementsByTagName("head")[0].appendChild(script);
              };
              return Util2;
            }();
            var PageViewport = function PageViewportClosure() {
              function PageViewport2(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {
                this.viewBox = viewBox;
                this.scale = scale;
                this.rotation = rotation;
                this.offsetX = offsetX;
                this.offsetY = offsetY;
                var centerX = (viewBox[2] + viewBox[0]) / 2;
                var centerY = (viewBox[3] + viewBox[1]) / 2;
                var rotateA, rotateB, rotateC, rotateD;
                rotation = rotation % 360;
                rotation = rotation < 0 ? rotation + 360 : rotation;
                switch (rotation) {
                  case 180:
                    rotateA = -1;
                    rotateB = 0;
                    rotateC = 0;
                    rotateD = 1;
                    break;
                  case 90:
                    rotateA = 0;
                    rotateB = 1;
                    rotateC = 1;
                    rotateD = 0;
                    break;
                  case 270:
                    rotateA = 0;
                    rotateB = -1;
                    rotateC = -1;
                    rotateD = 0;
                    break;
                  default:
                    rotateA = 1;
                    rotateB = 0;
                    rotateC = 0;
                    rotateD = -1;
                    break;
                }
                if (dontFlip) {
                  rotateC = -rotateC;
                  rotateD = -rotateD;
                }
                var offsetCanvasX, offsetCanvasY;
                var width, height;
                if (rotateA === 0) {
                  offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
                  offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
                  width = Math.abs(viewBox[3] - viewBox[1]) * scale;
                  height = Math.abs(viewBox[2] - viewBox[0]) * scale;
                } else {
                  offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
                  offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
                  width = Math.abs(viewBox[2] - viewBox[0]) * scale;
                  height = Math.abs(viewBox[3] - viewBox[1]) * scale;
                }
                this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
                this.width = width;
                this.height = height;
                this.fontScale = scale;
              }
              PageViewport2.prototype = {
                clone: function PageViewPort_clone(args) {
                  args = args || {};
                  var scale = "scale" in args ? args.scale : this.scale;
                  var rotation = "rotation" in args ? args.rotation : this.rotation;
                  return new PageViewport2(this.viewBox.slice(), scale, rotation, this.offsetX, this.offsetY, args.dontFlip);
                },
                convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
                  return Util.applyTransform([x, y], this.transform);
                },
                convertToViewportRectangle: function PageViewport_convertToViewportRectangle(rect) {
                  var tl = Util.applyTransform([rect[0], rect[1]], this.transform);
                  var br = Util.applyTransform([rect[2], rect[3]], this.transform);
                  return [tl[0], tl[1], br[0], br[1]];
                },
                convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
                  return Util.applyInverseTransform([x, y], this.transform);
                }
              };
              return PageViewport2;
            }();
            var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
            function stringToPDFString(str) {
              var i, n = str.length, strBuf = [];
              if (str[0] === "þ" && str[1] === "ÿ") {
                for (i = 2; i < n; i += 2) {
                  strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
                }
              } else {
                for (i = 0; i < n; ++i) {
                  var code = PDFStringTranslateTable[str.charCodeAt(i)];
                  strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
                }
              }
              return strBuf.join("");
            }
            function stringToUTF8String(str) {
              return decodeURIComponent(escape(str));
            }
            function utf8StringToString(str) {
              return unescape(encodeURIComponent(str));
            }
            function isEmptyObj(obj) {
              for (var key in obj) {
                return false;
              }
              return true;
            }
            function isBool(v) {
              return typeof v === "boolean";
            }
            function isNum(v) {
              return typeof v === "number";
            }
            function isString(v) {
              return typeof v === "string";
            }
            function isArrayBuffer(v) {
              return (typeof v === "undefined" ? "undefined" : _typeof(v)) === "object" && v !== null && v.byteLength !== void 0;
            }
            function isSpace(ch) {
              return ch === 32 || ch === 9 || ch === 13 || ch === 10;
            }
            function isNodeJS() {
              return (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process + "" === "[object process]";
            }
            function createPromiseCapability() {
              var capability = {};
              capability.promise = new Promise(function(resolve, reject) {
                capability.resolve = resolve;
                capability.reject = reject;
              });
              return capability;
            }
            var StatTimer = function StatTimerClosure() {
              function rpad(str, pad, length) {
                while (str.length < length) {
                  str += pad;
                }
                return str;
              }
              function StatTimer2() {
                this.started = /* @__PURE__ */ Object.create(null);
                this.times = [];
                this.enabled = true;
              }
              StatTimer2.prototype = {
                time: function StatTimer_time(name) {
                  if (!this.enabled) {
                    return;
                  }
                  if (name in this.started) {
                    warn("Timer is already running for " + name);
                  }
                  this.started[name] = Date.now();
                },
                timeEnd: function StatTimer_timeEnd(name) {
                  if (!this.enabled) {
                    return;
                  }
                  if (!(name in this.started)) {
                    warn("Timer has not been started for " + name);
                  }
                  this.times.push({
                    "name": name,
                    "start": this.started[name],
                    "end": Date.now()
                  });
                  delete this.started[name];
                },
                toString: function StatTimer_toString() {
                  var i, ii;
                  var times = this.times;
                  var out = "";
                  var longest = 0;
                  for (i = 0, ii = times.length; i < ii; ++i) {
                    var name = times[i]["name"];
                    if (name.length > longest) {
                      longest = name.length;
                    }
                  }
                  for (i = 0, ii = times.length; i < ii; ++i) {
                    var span = times[i];
                    var duration = span.end - span.start;
                    out += rpad(span["name"], " ", longest) + " " + duration + "ms\n";
                  }
                  return out;
                }
              };
              return StatTimer2;
            }();
            var createBlob = function createBlob2(data, contentType) {
              if (typeof Blob !== "undefined") {
                return new Blob([data], { type: contentType });
              }
              throw new Error('The "Blob" constructor is not supported.');
            };
            var createObjectURL = /* @__PURE__ */ function createObjectURLClosure() {
              var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              return function createObjectURL2(data, contentType) {
                var forceDataSchema = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                if (!forceDataSchema && URL.createObjectURL) {
                  var blob = createBlob(data, contentType);
                  return URL.createObjectURL(blob);
                }
                var buffer = "data:" + contentType + ";base64,";
                for (var i = 0, ii = data.length; i < ii; i += 3) {
                  var b1 = data[i] & 255;
                  var b2 = data[i + 1] & 255;
                  var b3 = data[i + 2] & 255;
                  var d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                  var d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                  var d4 = i + 2 < ii ? b3 & 63 : 64;
                  buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                }
                return buffer;
              };
            }();
            function resolveCall(fn, args) {
              var thisArg = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              if (!fn) {
                return Promise.resolve(void 0);
              }
              return new Promise(function(resolve, reject) {
                resolve(fn.apply(thisArg, args));
              });
            }
            function wrapReason(reason) {
              if ((typeof reason === "undefined" ? "undefined" : _typeof(reason)) !== "object") {
                return reason;
              }
              switch (reason.name) {
                case "AbortException":
                  return new AbortException(reason.message);
                case "MissingPDFException":
                  return new MissingPDFException(reason.message);
                case "UnexpectedResponseException":
                  return new UnexpectedResponseException(reason.message, reason.status);
                default:
                  return new UnknownErrorException(reason.message, reason.details);
              }
            }
            function makeReasonSerializable(reason) {
              if (!(reason instanceof Error) || reason instanceof AbortException || reason instanceof MissingPDFException || reason instanceof UnexpectedResponseException || reason instanceof UnknownErrorException) {
                return reason;
              }
              return new UnknownErrorException(reason.message, reason.toString());
            }
            function resolveOrReject(capability, success, reason) {
              if (success) {
                capability.resolve();
              } else {
                capability.reject(reason);
              }
            }
            function finalize(promise) {
              return Promise.resolve(promise).catch(function() {
              });
            }
            function MessageHandler(sourceName, targetName, comObj) {
              var _this = this;
              this.sourceName = sourceName;
              this.targetName = targetName;
              this.comObj = comObj;
              this.callbackId = 1;
              this.streamId = 1;
              this.postMessageTransfers = true;
              this.streamSinks = /* @__PURE__ */ Object.create(null);
              this.streamControllers = /* @__PURE__ */ Object.create(null);
              var callbacksCapabilities = this.callbacksCapabilities = /* @__PURE__ */ Object.create(null);
              var ah = this.actionHandler = /* @__PURE__ */ Object.create(null);
              this._onComObjOnMessage = function(event) {
                var data = event.data;
                if (data.targetName !== _this.sourceName) {
                  return;
                }
                if (data.stream) {
                  _this._processStreamMessage(data);
                } else if (data.isReply) {
                  var callbackId = data.callbackId;
                  if (data.callbackId in callbacksCapabilities) {
                    var callback = callbacksCapabilities[callbackId];
                    delete callbacksCapabilities[callbackId];
                    if ("error" in data) {
                      callback.reject(wrapReason(data.error));
                    } else {
                      callback.resolve(data.data);
                    }
                  } else {
                    throw new Error("Cannot resolve callback " + callbackId);
                  }
                } else if (data.action in ah) {
                  var action = ah[data.action];
                  if (data.callbackId) {
                    var _sourceName = _this.sourceName;
                    var _targetName = data.sourceName;
                    Promise.resolve().then(function() {
                      return action[0].call(action[1], data.data);
                    }).then(function(result) {
                      comObj.postMessage({
                        sourceName: _sourceName,
                        targetName: _targetName,
                        isReply: true,
                        callbackId: data.callbackId,
                        data: result
                      });
                    }, function(reason) {
                      comObj.postMessage({
                        sourceName: _sourceName,
                        targetName: _targetName,
                        isReply: true,
                        callbackId: data.callbackId,
                        error: makeReasonSerializable(reason)
                      });
                    });
                  } else if (data.streamId) {
                    _this._createStreamSink(data);
                  } else {
                    action[0].call(action[1], data.data);
                  }
                } else {
                  throw new Error("Unknown action from worker: " + data.action);
                }
              };
              comObj.addEventListener("message", this._onComObjOnMessage);
            }
            MessageHandler.prototype = {
              on: function on(actionName, handler, scope) {
                var ah = this.actionHandler;
                if (ah[actionName]) {
                  throw new Error('There is already an actionName called "' + actionName + '"');
                }
                ah[actionName] = [handler, scope];
              },
              send: function send(actionName, data, transfers) {
                var message = {
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: actionName,
                  data
                };
                this.postMessage(message, transfers);
              },
              sendWithPromise: function sendWithPromise(actionName, data, transfers) {
                var callbackId = this.callbackId++;
                var message = {
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: actionName,
                  data,
                  callbackId
                };
                var capability = createPromiseCapability();
                this.callbacksCapabilities[callbackId] = capability;
                try {
                  this.postMessage(message, transfers);
                } catch (e) {
                  capability.reject(e);
                }
                return capability.promise;
              },
              sendWithStream: function sendWithStream(actionName, data, queueingStrategy, transfers) {
                var _this2 = this;
                var streamId = this.streamId++;
                var sourceName = this.sourceName;
                var targetName = this.targetName;
                return new _streams_polyfill.ReadableStream({
                  start: function start(controller) {
                    var startCapability = createPromiseCapability();
                    _this2.streamControllers[streamId] = {
                      controller,
                      startCall: startCapability,
                      isClosed: false
                    };
                    _this2.postMessage({
                      sourceName,
                      targetName,
                      action: actionName,
                      streamId,
                      data,
                      desiredSize: controller.desiredSize
                    });
                    return startCapability.promise;
                  },
                  pull: function pull(controller) {
                    var pullCapability = createPromiseCapability();
                    _this2.streamControllers[streamId].pullCall = pullCapability;
                    _this2.postMessage({
                      sourceName,
                      targetName,
                      stream: "pull",
                      streamId,
                      desiredSize: controller.desiredSize
                    });
                    return pullCapability.promise;
                  },
                  cancel: function cancel(reason) {
                    var cancelCapability = createPromiseCapability();
                    _this2.streamControllers[streamId].cancelCall = cancelCapability;
                    _this2.streamControllers[streamId].isClosed = true;
                    _this2.postMessage({
                      sourceName,
                      targetName,
                      stream: "cancel",
                      reason,
                      streamId
                    });
                    return cancelCapability.promise;
                  }
                }, queueingStrategy);
              },
              _createStreamSink: function _createStreamSink(data) {
                var _this3 = this;
                var self2 = this;
                var action = this.actionHandler[data.action];
                var streamId = data.streamId;
                var desiredSize = data.desiredSize;
                var sourceName = this.sourceName;
                var targetName = data.sourceName;
                var capability = createPromiseCapability();
                var sendStreamRequest = function sendStreamRequest2(_ref) {
                  var stream = _ref.stream, chunk = _ref.chunk, transfers = _ref.transfers, success = _ref.success, reason = _ref.reason;
                  _this3.postMessage({
                    sourceName,
                    targetName,
                    stream,
                    streamId,
                    chunk,
                    success,
                    reason
                  }, transfers);
                };
                var streamSink = {
                  enqueue: function enqueue(chunk) {
                    var size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
                    var transfers = arguments[2];
                    if (this.isCancelled) {
                      return;
                    }
                    var lastDesiredSize = this.desiredSize;
                    this.desiredSize -= size;
                    if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                      this.sinkCapability = createPromiseCapability();
                      this.ready = this.sinkCapability.promise;
                    }
                    sendStreamRequest({
                      stream: "enqueue",
                      chunk,
                      transfers
                    });
                  },
                  close: function close() {
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    sendStreamRequest({ stream: "close" });
                    delete self2.streamSinks[streamId];
                  },
                  error: function error(reason) {
                    if (this.isCancelled) {
                      return;
                    }
                    this.isCancelled = true;
                    sendStreamRequest({
                      stream: "error",
                      reason
                    });
                  },
                  sinkCapability: capability,
                  onPull: null,
                  onCancel: null,
                  isCancelled: false,
                  desiredSize,
                  ready: null
                };
                streamSink.sinkCapability.resolve();
                streamSink.ready = streamSink.sinkCapability.promise;
                this.streamSinks[streamId] = streamSink;
                resolveCall(action[0], [data.data, streamSink], action[1]).then(function() {
                  sendStreamRequest({
                    stream: "start_complete",
                    success: true
                  });
                }, function(reason) {
                  sendStreamRequest({
                    stream: "start_complete",
                    success: false,
                    reason
                  });
                });
              },
              _processStreamMessage: function _processStreamMessage(data) {
                var _this4 = this;
                var sourceName = this.sourceName;
                var targetName = data.sourceName;
                var streamId = data.streamId;
                var sendStreamResponse = function sendStreamResponse2(_ref2) {
                  var stream = _ref2.stream, success = _ref2.success, reason = _ref2.reason;
                  _this4.comObj.postMessage({
                    sourceName,
                    targetName,
                    stream,
                    success,
                    streamId,
                    reason
                  });
                };
                var deleteStreamController = function deleteStreamController2() {
                  Promise.all([_this4.streamControllers[data.streamId].startCall, _this4.streamControllers[data.streamId].pullCall, _this4.streamControllers[data.streamId].cancelCall].map(function(capability) {
                    return capability && finalize(capability.promise);
                  })).then(function() {
                    delete _this4.streamControllers[data.streamId];
                  });
                };
                switch (data.stream) {
                  case "start_complete":
                    resolveOrReject(this.streamControllers[data.streamId].startCall, data.success, wrapReason(data.reason));
                    break;
                  case "pull_complete":
                    resolveOrReject(this.streamControllers[data.streamId].pullCall, data.success, wrapReason(data.reason));
                    break;
                  case "pull":
                    if (!this.streamSinks[data.streamId]) {
                      sendStreamResponse({
                        stream: "pull_complete",
                        success: true
                      });
                      break;
                    }
                    if (this.streamSinks[data.streamId].desiredSize <= 0 && data.desiredSize > 0) {
                      this.streamSinks[data.streamId].sinkCapability.resolve();
                    }
                    this.streamSinks[data.streamId].desiredSize = data.desiredSize;
                    resolveCall(this.streamSinks[data.streamId].onPull).then(function() {
                      sendStreamResponse({
                        stream: "pull_complete",
                        success: true
                      });
                    }, function(reason) {
                      sendStreamResponse({
                        stream: "pull_complete",
                        success: false,
                        reason
                      });
                    });
                    break;
                  case "enqueue":
                    assert(this.streamControllers[data.streamId], "enqueue should have stream controller");
                    if (!this.streamControllers[data.streamId].isClosed) {
                      this.streamControllers[data.streamId].controller.enqueue(data.chunk);
                    }
                    break;
                  case "close":
                    assert(this.streamControllers[data.streamId], "close should have stream controller");
                    if (this.streamControllers[data.streamId].isClosed) {
                      break;
                    }
                    this.streamControllers[data.streamId].isClosed = true;
                    this.streamControllers[data.streamId].controller.close();
                    deleteStreamController();
                    break;
                  case "error":
                    assert(this.streamControllers[data.streamId], "error should have stream controller");
                    this.streamControllers[data.streamId].controller.error(wrapReason(data.reason));
                    deleteStreamController();
                    break;
                  case "cancel_complete":
                    resolveOrReject(this.streamControllers[data.streamId].cancelCall, data.success, wrapReason(data.reason));
                    deleteStreamController();
                    break;
                  case "cancel":
                    if (!this.streamSinks[data.streamId]) {
                      break;
                    }
                    resolveCall(this.streamSinks[data.streamId].onCancel, [wrapReason(data.reason)]).then(function() {
                      sendStreamResponse({
                        stream: "cancel_complete",
                        success: true
                      });
                    }, function(reason) {
                      sendStreamResponse({
                        stream: "cancel_complete",
                        success: false,
                        reason
                      });
                    });
                    this.streamSinks[data.streamId].sinkCapability.reject(wrapReason(data.reason));
                    this.streamSinks[data.streamId].isCancelled = true;
                    delete this.streamSinks[data.streamId];
                    break;
                  default:
                    throw new Error("Unexpected stream case");
                }
              },
              postMessage: function postMessage2(message, transfers) {
                if (transfers && this.postMessageTransfers) {
                  this.comObj.postMessage(message, transfers);
                } else {
                  this.comObj.postMessage(message);
                }
              },
              destroy: function destroy() {
                this.comObj.removeEventListener("message", this._onComObjOnMessage);
              }
            };
            function loadJpegStream(id, imageUrl, objs) {
              var img = new Image();
              img.onload = function loadJpegStream_onloadClosure() {
                objs.resolve(id, img);
              };
              img.onerror = function loadJpegStream_onerrorClosure() {
                objs.resolve(id, null);
                warn("Error during JPEG image loading");
              };
              img.src = imageUrl;
            }
            exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
            exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
            exports2.OPS = OPS;
            exports2.VERBOSITY_LEVELS = VERBOSITY_LEVELS;
            exports2.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
            exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
            exports2.AnnotationFieldFlag = AnnotationFieldFlag;
            exports2.AnnotationFlag = AnnotationFlag;
            exports2.AnnotationType = AnnotationType;
            exports2.FontType = FontType;
            exports2.ImageKind = ImageKind;
            exports2.CMapCompressionType = CMapCompressionType;
            exports2.AbortException = AbortException;
            exports2.InvalidPDFException = InvalidPDFException;
            exports2.MessageHandler = MessageHandler;
            exports2.MissingDataException = MissingDataException;
            exports2.MissingPDFException = MissingPDFException;
            exports2.NativeImageDecoding = NativeImageDecoding;
            exports2.NotImplementedException = NotImplementedException;
            exports2.PageViewport = PageViewport;
            exports2.PasswordException = PasswordException;
            exports2.PasswordResponses = PasswordResponses;
            exports2.StatTimer = StatTimer;
            exports2.StreamType = StreamType;
            exports2.TextRenderingMode = TextRenderingMode;
            exports2.UnexpectedResponseException = UnexpectedResponseException;
            exports2.UnknownErrorException = UnknownErrorException;
            exports2.Util = Util;
            exports2.XRefParseException = XRefParseException;
            exports2.FormatError = FormatError;
            exports2.arrayByteLength = arrayByteLength;
            exports2.arraysToBytes = arraysToBytes;
            exports2.assert = assert;
            exports2.bytesToString = bytesToString;
            exports2.createBlob = createBlob;
            exports2.createPromiseCapability = createPromiseCapability;
            exports2.createObjectURL = createObjectURL;
            exports2.deprecated = deprecated;
            exports2.getLookupTableFactory = getLookupTableFactory;
            exports2.getVerbosityLevel = getVerbosityLevel;
            exports2.info = info;
            exports2.isArrayBuffer = isArrayBuffer;
            exports2.isBool = isBool;
            exports2.isEmptyObj = isEmptyObj;
            exports2.isNum = isNum;
            exports2.isString = isString;
            exports2.isSpace = isSpace;
            exports2.isNodeJS = isNodeJS;
            exports2.isSameOrigin = isSameOrigin;
            exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
            exports2.isLittleEndian = isLittleEndian;
            exports2.isEvalSupported = isEvalSupported;
            exports2.loadJpegStream = loadJpegStream;
            exports2.log2 = log2;
            exports2.readInt8 = readInt8;
            exports2.readUint16 = readUint16;
            exports2.readUint32 = readUint32;
            exports2.removeNullCharacters = removeNullCharacters;
            exports2.ReadableStream = _streams_polyfill.ReadableStream;
            exports2.setVerbosityLevel = setVerbosityLevel;
            exports2.shadow = shadow;
            exports2.string32 = string32;
            exports2.stringToBytes = stringToBytes;
            exports2.stringToPDFString = stringToPDFString;
            exports2.stringToUTF8String = stringToUTF8String;
            exports2.utf8StringToString = utf8StringToString;
            exports2.warn = warn;
            exports2.unreachable = unreachable;
          },
          /* 1 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var global2 = module2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
            if (typeof __g == "number") __g = global2;
          },
          /* 2 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var EOF = {};
            var Name = function NameClosure() {
              function Name2(name) {
                this.name = name;
              }
              Name2.prototype = {};
              var nameCache = /* @__PURE__ */ Object.create(null);
              Name2.get = function Name_get(name) {
                var nameValue = nameCache[name];
                return nameValue ? nameValue : nameCache[name] = new Name2(name);
              };
              return Name2;
            }();
            var Cmd = function CmdClosure() {
              function Cmd2(cmd) {
                this.cmd = cmd;
              }
              Cmd2.prototype = {};
              var cmdCache = /* @__PURE__ */ Object.create(null);
              Cmd2.get = function Cmd_get(cmd) {
                var cmdValue = cmdCache[cmd];
                return cmdValue ? cmdValue : cmdCache[cmd] = new Cmd2(cmd);
              };
              return Cmd2;
            }();
            var Dict = function DictClosure() {
              var nonSerializable = function nonSerializableClosure() {
                return nonSerializable;
              };
              function Dict2(xref) {
                this._map = /* @__PURE__ */ Object.create(null);
                this.xref = xref;
                this.objId = null;
                this.suppressEncryption = false;
                this.__nonSerializable__ = nonSerializable;
              }
              Dict2.prototype = {
                assignXref: function Dict_assignXref(newXref) {
                  this.xref = newXref;
                },
                get: function Dict_get(key1, key2, key3) {
                  var value;
                  var xref = this.xref, suppressEncryption = this.suppressEncryption;
                  if (typeof (value = this._map[key1]) !== "undefined" || key1 in this._map || typeof key2 === "undefined") {
                    return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
                  }
                  if (typeof (value = this._map[key2]) !== "undefined" || key2 in this._map || typeof key3 === "undefined") {
                    return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
                  }
                  value = this._map[key3] || null;
                  return xref ? xref.fetchIfRef(value, suppressEncryption) : value;
                },
                getAsync: function Dict_getAsync(key1, key2, key3) {
                  var value;
                  var xref = this.xref, suppressEncryption = this.suppressEncryption;
                  if (typeof (value = this._map[key1]) !== "undefined" || key1 in this._map || typeof key2 === "undefined") {
                    if (xref) {
                      return xref.fetchIfRefAsync(value, suppressEncryption);
                    }
                    return Promise.resolve(value);
                  }
                  if (typeof (value = this._map[key2]) !== "undefined" || key2 in this._map || typeof key3 === "undefined") {
                    if (xref) {
                      return xref.fetchIfRefAsync(value, suppressEncryption);
                    }
                    return Promise.resolve(value);
                  }
                  value = this._map[key3] || null;
                  if (xref) {
                    return xref.fetchIfRefAsync(value, suppressEncryption);
                  }
                  return Promise.resolve(value);
                },
                getArray: function Dict_getArray(key1, key2, key3) {
                  var value = this.get(key1, key2, key3);
                  var xref = this.xref, suppressEncryption = this.suppressEncryption;
                  if (!Array.isArray(value) || !xref) {
                    return value;
                  }
                  value = value.slice();
                  for (var i = 0, ii = value.length; i < ii; i++) {
                    if (!isRef(value[i])) {
                      continue;
                    }
                    value[i] = xref.fetch(value[i], suppressEncryption);
                  }
                  return value;
                },
                getRaw: function Dict_getRaw(key) {
                  return this._map[key];
                },
                getKeys: function Dict_getKeys() {
                  return Object.keys(this._map);
                },
                set: function Dict_set(key, value) {
                  this._map[key] = value;
                },
                has: function Dict_has(key) {
                  return key in this._map;
                },
                forEach: function Dict_forEach(callback) {
                  for (var key in this._map) {
                    callback(key, this.get(key));
                  }
                }
              };
              Dict2.empty = new Dict2(null);
              Dict2.merge = function(xref, dictArray) {
                var mergedDict = new Dict2(xref);
                for (var i = 0, ii = dictArray.length; i < ii; i++) {
                  var dict = dictArray[i];
                  if (!isDict(dict)) {
                    continue;
                  }
                  for (var keyName in dict._map) {
                    if (mergedDict._map[keyName] !== void 0) {
                      continue;
                    }
                    mergedDict._map[keyName] = dict._map[keyName];
                  }
                }
                return mergedDict;
              };
              return Dict2;
            }();
            var Ref = function RefClosure() {
              function Ref2(num, gen) {
                this.num = num;
                this.gen = gen;
              }
              Ref2.prototype = {
                toString: function Ref_toString() {
                  var str = this.num + "R";
                  if (this.gen !== 0) {
                    str += this.gen;
                  }
                  return str;
                }
              };
              return Ref2;
            }();
            var RefSet = function RefSetClosure() {
              function RefSet2() {
                this.dict = /* @__PURE__ */ Object.create(null);
              }
              RefSet2.prototype = {
                has: function RefSet_has(ref) {
                  return ref.toString() in this.dict;
                },
                put: function RefSet_put(ref) {
                  this.dict[ref.toString()] = true;
                },
                remove: function RefSet_remove(ref) {
                  delete this.dict[ref.toString()];
                }
              };
              return RefSet2;
            }();
            var RefSetCache = function RefSetCacheClosure() {
              function RefSetCache2() {
                this.dict = /* @__PURE__ */ Object.create(null);
              }
              RefSetCache2.prototype = {
                get: function RefSetCache_get(ref) {
                  return this.dict[ref.toString()];
                },
                has: function RefSetCache_has(ref) {
                  return ref.toString() in this.dict;
                },
                put: function RefSetCache_put(ref, obj) {
                  this.dict[ref.toString()] = obj;
                },
                putAlias: function RefSetCache_putAlias(ref, aliasRef) {
                  this.dict[ref.toString()] = this.get(aliasRef);
                },
                forEach: function RefSetCache_forEach(fn, thisArg) {
                  for (var i in this.dict) {
                    fn.call(thisArg, this.dict[i]);
                  }
                },
                clear: function RefSetCache_clear() {
                  this.dict = /* @__PURE__ */ Object.create(null);
                }
              };
              return RefSetCache2;
            }();
            function isEOF(v) {
              return v === EOF;
            }
            function isName(v, name) {
              return v instanceof Name && (name === void 0 || v.name === name);
            }
            function isCmd(v, cmd) {
              return v instanceof Cmd && (cmd === void 0 || v.cmd === cmd);
            }
            function isDict(v, type) {
              return v instanceof Dict && (type === void 0 || isName(v.get("Type"), type));
            }
            function isRef(v) {
              return v instanceof Ref;
            }
            function isRefsEqual(v1, v2) {
              return v1.num === v2.num && v1.gen === v2.gen;
            }
            function isStream(v) {
              return (typeof v === "undefined" ? "undefined" : _typeof(v)) === "object" && v !== null && v.getBytes !== void 0;
            }
            exports2.EOF = EOF;
            exports2.Cmd = Cmd;
            exports2.Dict = Dict;
            exports2.Name = Name;
            exports2.Ref = Ref;
            exports2.RefSet = RefSet;
            exports2.RefSetCache = RefSetCache;
            exports2.isEOF = isEOF;
            exports2.isCmd = isCmd;
            exports2.isDict = isDict;
            exports2.isName = isName;
            exports2.isRef = isRef;
            exports2.isRefsEqual = isRefsEqual;
            exports2.isStream = isStream;
          },
          /* 3 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            module2.exports = function(it) {
              return (typeof it === "undefined" ? "undefined" : _typeof(it)) === "object" ? it !== null : typeof it === "function";
            };
          },
          /* 4 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var store = __w_pdfjs_require__(54)("wks");
            var uid = __w_pdfjs_require__(17);
            var _Symbol = __w_pdfjs_require__(1).Symbol;
            var USE_SYMBOL = typeof _Symbol == "function";
            var $exports = module2.exports = function(name) {
              return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)("Symbol." + name));
            };
            $exports.store = store;
          },
          /* 5 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.LZWStream = exports2.StringStream = exports2.StreamsSequenceStream = exports2.Stream = exports2.RunLengthStream = exports2.PredictorStream = exports2.NullStream = exports2.JpxStream = exports2.JpegStream = exports2.FlateStream = exports2.DecodeStream = exports2.DecryptStream = exports2.AsciiHexStream = exports2.Ascii85Stream = void 0;
            var _util = __w_pdfjs_require__(0);
            var _primitives = __w_pdfjs_require__(2);
            var _jpg = __w_pdfjs_require__(129);
            var _jpx = __w_pdfjs_require__(74);
            var Stream = function StreamClosure() {
              function Stream2(arrayBuffer, start, length, dict) {
                this.bytes = arrayBuffer instanceof Uint8Array ? arrayBuffer : new Uint8Array(arrayBuffer);
                this.start = start || 0;
                this.pos = this.start;
                this.end = start + length || this.bytes.length;
                this.dict = dict;
              }
              Stream2.prototype = {
                get length() {
                  return this.end - this.start;
                },
                get isEmpty() {
                  return this.length === 0;
                },
                getByte: function Stream_getByte() {
                  if (this.pos >= this.end) {
                    return -1;
                  }
                  return this.bytes[this.pos++];
                },
                getUint16: function Stream_getUint16() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  if (b0 === -1 || b1 === -1) {
                    return -1;
                  }
                  return (b0 << 8) + b1;
                },
                getInt32: function Stream_getInt32() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  var b2 = this.getByte();
                  var b3 = this.getByte();
                  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                },
                getBytes: function Stream_getBytes(length) {
                  var bytes = this.bytes;
                  var pos = this.pos;
                  var strEnd = this.end;
                  if (!length) {
                    return bytes.subarray(pos, strEnd);
                  }
                  var end = pos + length;
                  if (end > strEnd) {
                    end = strEnd;
                  }
                  this.pos = end;
                  return bytes.subarray(pos, end);
                },
                peekByte: function Stream_peekByte() {
                  var peekedByte = this.getByte();
                  this.pos--;
                  return peekedByte;
                },
                peekBytes: function Stream_peekBytes(length) {
                  var bytes = this.getBytes(length);
                  this.pos -= bytes.length;
                  return bytes;
                },
                skip: function Stream_skip(n) {
                  if (!n) {
                    n = 1;
                  }
                  this.pos += n;
                },
                reset: function Stream_reset() {
                  this.pos = this.start;
                },
                moveStart: function Stream_moveStart() {
                  this.start = this.pos;
                },
                makeSubStream: function Stream_makeSubStream(start, length, dict) {
                  return new Stream2(this.bytes.buffer, start, length, dict);
                }
              };
              return Stream2;
            }();
            var StringStream = function StringStreamClosure() {
              function StringStream2(str) {
                var bytes = (0, _util.stringToBytes)(str);
                Stream.call(this, bytes);
              }
              StringStream2.prototype = Stream.prototype;
              return StringStream2;
            }();
            var DecodeStream = function DecodeStreamClosure() {
              var emptyBuffer = new Uint8Array(0);
              function DecodeStream2(maybeMinBufferLength) {
                this.pos = 0;
                this.bufferLength = 0;
                this.eof = false;
                this.buffer = emptyBuffer;
                this.minBufferLength = 512;
                if (maybeMinBufferLength) {
                  while (this.minBufferLength < maybeMinBufferLength) {
                    this.minBufferLength *= 2;
                  }
                }
              }
              DecodeStream2.prototype = {
                get isEmpty() {
                  while (!this.eof && this.bufferLength === 0) {
                    this.readBlock();
                  }
                  return this.bufferLength === 0;
                },
                ensureBuffer: function DecodeStream_ensureBuffer(requested) {
                  var buffer = this.buffer;
                  if (requested <= buffer.byteLength) {
                    return buffer;
                  }
                  var size = this.minBufferLength;
                  while (size < requested) {
                    size *= 2;
                  }
                  var buffer2 = new Uint8Array(size);
                  buffer2.set(buffer);
                  return this.buffer = buffer2;
                },
                getByte: function DecodeStream_getByte() {
                  var pos = this.pos;
                  while (this.bufferLength <= pos) {
                    if (this.eof) {
                      return -1;
                    }
                    this.readBlock();
                  }
                  return this.buffer[this.pos++];
                },
                getUint16: function DecodeStream_getUint16() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  if (b0 === -1 || b1 === -1) {
                    return -1;
                  }
                  return (b0 << 8) + b1;
                },
                getInt32: function DecodeStream_getInt32() {
                  var b0 = this.getByte();
                  var b1 = this.getByte();
                  var b2 = this.getByte();
                  var b3 = this.getByte();
                  return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
                },
                getBytes: function DecodeStream_getBytes(length) {
                  var end, pos = this.pos;
                  if (length) {
                    this.ensureBuffer(pos + length);
                    end = pos + length;
                    while (!this.eof && this.bufferLength < end) {
                      this.readBlock();
                    }
                    var bufEnd = this.bufferLength;
                    if (end > bufEnd) {
                      end = bufEnd;
                    }
                  } else {
                    while (!this.eof) {
                      this.readBlock();
                    }
                    end = this.bufferLength;
                  }
                  this.pos = end;
                  return this.buffer.subarray(pos, end);
                },
                peekByte: function DecodeStream_peekByte() {
                  var peekedByte = this.getByte();
                  this.pos--;
                  return peekedByte;
                },
                peekBytes: function DecodeStream_peekBytes(length) {
                  var bytes = this.getBytes(length);
                  this.pos -= bytes.length;
                  return bytes;
                },
                makeSubStream: function DecodeStream_makeSubStream(start, length, dict) {
                  var end = start + length;
                  while (this.bufferLength <= end && !this.eof) {
                    this.readBlock();
                  }
                  return new Stream(this.buffer, start, length, dict);
                },
                skip: function DecodeStream_skip(n) {
                  if (!n) {
                    n = 1;
                  }
                  this.pos += n;
                },
                reset: function DecodeStream_reset() {
                  this.pos = 0;
                },
                getBaseStreams: function DecodeStream_getBaseStreams() {
                  if (this.str && this.str.getBaseStreams) {
                    return this.str.getBaseStreams();
                  }
                  return [];
                }
              };
              return DecodeStream2;
            }();
            var StreamsSequenceStream = function StreamsSequenceStreamClosure() {
              function StreamsSequenceStream2(streams) {
                this.streams = streams;
                DecodeStream.call(this, null);
              }
              StreamsSequenceStream2.prototype = Object.create(DecodeStream.prototype);
              StreamsSequenceStream2.prototype.readBlock = function streamSequenceStreamReadBlock() {
                var streams = this.streams;
                if (streams.length === 0) {
                  this.eof = true;
                  return;
                }
                var stream = streams.shift();
                var chunk = stream.getBytes();
                var bufferLength = this.bufferLength;
                var newLength = bufferLength + chunk.length;
                var buffer = this.ensureBuffer(newLength);
                buffer.set(chunk, bufferLength);
                this.bufferLength = newLength;
              };
              StreamsSequenceStream2.prototype.getBaseStreams = function StreamsSequenceStream_getBaseStreams() {
                var baseStreams = [];
                for (var i = 0, ii = this.streams.length; i < ii; i++) {
                  var stream = this.streams[i];
                  if (stream.getBaseStreams) {
                    _util.Util.appendToArray(baseStreams, stream.getBaseStreams());
                  }
                }
                return baseStreams;
              };
              return StreamsSequenceStream2;
            }();
            var FlateStream = function FlateStreamClosure() {
              var codeLenCodeMap = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
              var lengthDecode = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]);
              var distDecode = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]);
              var fixedLitCodeTab = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9];
              var fixedDistCodeTab = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
              function FlateStream2(str, maybeLength) {
                this.str = str;
                this.dict = str.dict;
                var cmf = str.getByte();
                var flg = str.getByte();
                if (cmf === -1 || flg === -1) {
                  throw new _util.FormatError("Invalid header in flate stream: " + cmf + ", " + flg);
                }
                if ((cmf & 15) !== 8) {
                  throw new _util.FormatError("Unknown compression method in flate stream: " + cmf + ", " + flg);
                }
                if (((cmf << 8) + flg) % 31 !== 0) {
                  throw new _util.FormatError("Bad FCHECK in flate stream: " + cmf + ", " + flg);
                }
                if (flg & 32) {
                  throw new _util.FormatError("FDICT bit set in flate stream: " + cmf + ", " + flg);
                }
                this.codeSize = 0;
                this.codeBuf = 0;
                DecodeStream.call(this, maybeLength);
              }
              FlateStream2.prototype = Object.create(DecodeStream.prototype);
              FlateStream2.prototype.getBits = function FlateStream_getBits(bits) {
                var str = this.str;
                var codeSize = this.codeSize;
                var codeBuf = this.codeBuf;
                var b;
                while (codeSize < bits) {
                  if ((b = str.getByte()) === -1) {
                    throw new _util.FormatError("Bad encoding in flate stream");
                  }
                  codeBuf |= b << codeSize;
                  codeSize += 8;
                }
                b = codeBuf & (1 << bits) - 1;
                this.codeBuf = codeBuf >> bits;
                this.codeSize = codeSize -= bits;
                return b;
              };
              FlateStream2.prototype.getCode = function FlateStream_getCode(table) {
                var str = this.str;
                var codes = table[0];
                var maxLen = table[1];
                var codeSize = this.codeSize;
                var codeBuf = this.codeBuf;
                var b;
                while (codeSize < maxLen) {
                  if ((b = str.getByte()) === -1) {
                    break;
                  }
                  codeBuf |= b << codeSize;
                  codeSize += 8;
                }
                var code = codes[codeBuf & (1 << maxLen) - 1];
                var codeLen = code >> 16;
                var codeVal = code & 65535;
                if (codeLen < 1 || codeSize < codeLen) {
                  throw new _util.FormatError("Bad encoding in flate stream");
                }
                this.codeBuf = codeBuf >> codeLen;
                this.codeSize = codeSize - codeLen;
                return codeVal;
              };
              FlateStream2.prototype.generateHuffmanTable = function flateStreamGenerateHuffmanTable(lengths) {
                var n = lengths.length;
                var maxLen = 0;
                var i;
                for (i = 0; i < n; ++i) {
                  if (lengths[i] > maxLen) {
                    maxLen = lengths[i];
                  }
                }
                var size = 1 << maxLen;
                var codes = new Int32Array(size);
                for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
                  for (var val = 0; val < n; ++val) {
                    if (lengths[val] === len) {
                      var code2 = 0;
                      var t = code;
                      for (i = 0; i < len; ++i) {
                        code2 = code2 << 1 | t & 1;
                        t >>= 1;
                      }
                      for (i = code2; i < size; i += skip) {
                        codes[i] = len << 16 | val;
                      }
                      ++code;
                    }
                  }
                }
                return [codes, maxLen];
              };
              FlateStream2.prototype.readBlock = function FlateStream_readBlock() {
                var buffer, len;
                var str = this.str;
                var hdr = this.getBits(3);
                if (hdr & 1) {
                  this.eof = true;
                }
                hdr >>= 1;
                if (hdr === 0) {
                  var b;
                  if ((b = str.getByte()) === -1) {
                    throw new _util.FormatError("Bad block header in flate stream");
                  }
                  var blockLen = b;
                  if ((b = str.getByte()) === -1) {
                    throw new _util.FormatError("Bad block header in flate stream");
                  }
                  blockLen |= b << 8;
                  if ((b = str.getByte()) === -1) {
                    throw new _util.FormatError("Bad block header in flate stream");
                  }
                  var check = b;
                  if ((b = str.getByte()) === -1) {
                    throw new _util.FormatError("Bad block header in flate stream");
                  }
                  check |= b << 8;
                  if (check !== (~blockLen & 65535) && (blockLen !== 0 || check !== 0)) {
                    throw new _util.FormatError("Bad uncompressed block length in flate stream");
                  }
                  this.codeBuf = 0;
                  this.codeSize = 0;
                  var bufferLength = this.bufferLength;
                  buffer = this.ensureBuffer(bufferLength + blockLen);
                  var end = bufferLength + blockLen;
                  this.bufferLength = end;
                  if (blockLen === 0) {
                    if (str.peekByte() === -1) {
                      this.eof = true;
                    }
                  } else {
                    for (var n = bufferLength; n < end; ++n) {
                      if ((b = str.getByte()) === -1) {
                        this.eof = true;
                        break;
                      }
                      buffer[n] = b;
                    }
                  }
                  return;
                }
                var litCodeTable;
                var distCodeTable;
                if (hdr === 1) {
                  litCodeTable = fixedLitCodeTab;
                  distCodeTable = fixedDistCodeTab;
                } else if (hdr === 2) {
                  var numLitCodes = this.getBits(5) + 257;
                  var numDistCodes = this.getBits(5) + 1;
                  var numCodeLenCodes = this.getBits(4) + 4;
                  var codeLenCodeLengths = new Uint8Array(codeLenCodeMap.length);
                  var i;
                  for (i = 0; i < numCodeLenCodes; ++i) {
                    codeLenCodeLengths[codeLenCodeMap[i]] = this.getBits(3);
                  }
                  var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
                  len = 0;
                  i = 0;
                  var codes = numLitCodes + numDistCodes;
                  var codeLengths = new Uint8Array(codes);
                  var bitsLength, bitsOffset, what;
                  while (i < codes) {
                    var code = this.getCode(codeLenCodeTab);
                    if (code === 16) {
                      bitsLength = 2;
                      bitsOffset = 3;
                      what = len;
                    } else if (code === 17) {
                      bitsLength = 3;
                      bitsOffset = 3;
                      what = len = 0;
                    } else if (code === 18) {
                      bitsLength = 7;
                      bitsOffset = 11;
                      what = len = 0;
                    } else {
                      codeLengths[i++] = len = code;
                      continue;
                    }
                    var repeatLength = this.getBits(bitsLength) + bitsOffset;
                    while (repeatLength-- > 0) {
                      codeLengths[i++] = what;
                    }
                  }
                  litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
                  distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
                } else {
                  throw new _util.FormatError("Unknown block type in flate stream");
                }
                buffer = this.buffer;
                var limit = buffer ? buffer.length : 0;
                var pos = this.bufferLength;
                while (true) {
                  var code1 = this.getCode(litCodeTable);
                  if (code1 < 256) {
                    if (pos + 1 >= limit) {
                      buffer = this.ensureBuffer(pos + 1);
                      limit = buffer.length;
                    }
                    buffer[pos++] = code1;
                    continue;
                  }
                  if (code1 === 256) {
                    this.bufferLength = pos;
                    return;
                  }
                  code1 -= 257;
                  code1 = lengthDecode[code1];
                  var code2 = code1 >> 16;
                  if (code2 > 0) {
                    code2 = this.getBits(code2);
                  }
                  len = (code1 & 65535) + code2;
                  code1 = this.getCode(distCodeTable);
                  code1 = distDecode[code1];
                  code2 = code1 >> 16;
                  if (code2 > 0) {
                    code2 = this.getBits(code2);
                  }
                  var dist = (code1 & 65535) + code2;
                  if (pos + len >= limit) {
                    buffer = this.ensureBuffer(pos + len);
                    limit = buffer.length;
                  }
                  for (var k = 0; k < len; ++k, ++pos) {
                    buffer[pos] = buffer[pos - dist];
                  }
                }
              };
              return FlateStream2;
            }();
            var PredictorStream = function PredictorStreamClosure() {
              function PredictorStream2(str, maybeLength, params) {
                if (!(0, _primitives.isDict)(params)) {
                  return str;
                }
                var predictor = this.predictor = params.get("Predictor") || 1;
                if (predictor <= 1) {
                  return str;
                }
                if (predictor !== 2 && (predictor < 10 || predictor > 15)) {
                  throw new _util.FormatError("Unsupported predictor: " + predictor);
                }
                if (predictor === 2) {
                  this.readBlock = this.readBlockTiff;
                } else {
                  this.readBlock = this.readBlockPng;
                }
                this.str = str;
                this.dict = str.dict;
                var colors = this.colors = params.get("Colors") || 1;
                var bits = this.bits = params.get("BitsPerComponent") || 8;
                var columns = this.columns = params.get("Columns") || 1;
                this.pixBytes = colors * bits + 7 >> 3;
                this.rowBytes = columns * colors * bits + 7 >> 3;
                DecodeStream.call(this, maybeLength);
                return this;
              }
              PredictorStream2.prototype = Object.create(DecodeStream.prototype);
              PredictorStream2.prototype.readBlockTiff = function predictorStreamReadBlockTiff() {
                var rowBytes = this.rowBytes;
                var bufferLength = this.bufferLength;
                var buffer = this.ensureBuffer(bufferLength + rowBytes);
                var bits = this.bits;
                var colors = this.colors;
                var rawBytes = this.str.getBytes(rowBytes);
                this.eof = !rawBytes.length;
                if (this.eof) {
                  return;
                }
                var inbuf = 0, outbuf = 0;
                var inbits = 0, outbits = 0;
                var pos = bufferLength;
                var i;
                if (bits === 1 && colors === 1) {
                  for (i = 0; i < rowBytes; ++i) {
                    var c = rawBytes[i] ^ inbuf;
                    c ^= c >> 1;
                    c ^= c >> 2;
                    c ^= c >> 4;
                    inbuf = (c & 1) << 7;
                    buffer[pos++] = c;
                  }
                } else if (bits === 8) {
                  for (i = 0; i < colors; ++i) {
                    buffer[pos++] = rawBytes[i];
                  }
                  for (; i < rowBytes; ++i) {
                    buffer[pos] = buffer[pos - colors] + rawBytes[i];
                    pos++;
                  }
                } else if (bits === 16) {
                  var bytesPerPixel = colors * 2;
                  for (i = 0; i < bytesPerPixel; ++i) {
                    buffer[pos++] = rawBytes[i];
                  }
                  for (; i < rowBytes; i += 2) {
                    var sum = ((rawBytes[i] & 255) << 8) + (rawBytes[i + 1] & 255) + ((buffer[pos - bytesPerPixel] & 255) << 8) + (buffer[pos - bytesPerPixel + 1] & 255);
                    buffer[pos++] = sum >> 8 & 255;
                    buffer[pos++] = sum & 255;
                  }
                } else {
                  var compArray = new Uint8Array(colors + 1);
                  var bitMask = (1 << bits) - 1;
                  var j = 0, k = bufferLength;
                  var columns = this.columns;
                  for (i = 0; i < columns; ++i) {
                    for (var kk = 0; kk < colors; ++kk) {
                      if (inbits < bits) {
                        inbuf = inbuf << 8 | rawBytes[j++] & 255;
                        inbits += 8;
                      }
                      compArray[kk] = compArray[kk] + (inbuf >> inbits - bits) & bitMask;
                      inbits -= bits;
                      outbuf = outbuf << bits | compArray[kk];
                      outbits += bits;
                      if (outbits >= 8) {
                        buffer[k++] = outbuf >> outbits - 8 & 255;
                        outbits -= 8;
                      }
                    }
                  }
                  if (outbits > 0) {
                    buffer[k++] = (outbuf << 8 - outbits) + (inbuf & (1 << 8 - outbits) - 1);
                  }
                }
                this.bufferLength += rowBytes;
              };
              PredictorStream2.prototype.readBlockPng = function predictorStreamReadBlockPng() {
                var rowBytes = this.rowBytes;
                var pixBytes = this.pixBytes;
                var predictor = this.str.getByte();
                var rawBytes = this.str.getBytes(rowBytes);
                this.eof = !rawBytes.length;
                if (this.eof) {
                  return;
                }
                var bufferLength = this.bufferLength;
                var buffer = this.ensureBuffer(bufferLength + rowBytes);
                var prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);
                if (prevRow.length === 0) {
                  prevRow = new Uint8Array(rowBytes);
                }
                var i, j = bufferLength, up, c;
                switch (predictor) {
                  case 0:
                    for (i = 0; i < rowBytes; ++i) {
                      buffer[j++] = rawBytes[i];
                    }
                    break;
                  case 1:
                    for (i = 0; i < pixBytes; ++i) {
                      buffer[j++] = rawBytes[i];
                    }
                    for (; i < rowBytes; ++i) {
                      buffer[j] = buffer[j - pixBytes] + rawBytes[i] & 255;
                      j++;
                    }
                    break;
                  case 2:
                    for (i = 0; i < rowBytes; ++i) {
                      buffer[j++] = prevRow[i] + rawBytes[i] & 255;
                    }
                    break;
                  case 3:
                    for (i = 0; i < pixBytes; ++i) {
                      buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];
                    }
                    for (; i < rowBytes; ++i) {
                      buffer[j] = (prevRow[i] + buffer[j - pixBytes] >> 1) + rawBytes[i] & 255;
                      j++;
                    }
                    break;
                  case 4:
                    for (i = 0; i < pixBytes; ++i) {
                      up = prevRow[i];
                      c = rawBytes[i];
                      buffer[j++] = up + c;
                    }
                    for (; i < rowBytes; ++i) {
                      up = prevRow[i];
                      var upLeft = prevRow[i - pixBytes];
                      var left = buffer[j - pixBytes];
                      var p = left + up - upLeft;
                      var pa = p - left;
                      if (pa < 0) {
                        pa = -pa;
                      }
                      var pb = p - up;
                      if (pb < 0) {
                        pb = -pb;
                      }
                      var pc = p - upLeft;
                      if (pc < 0) {
                        pc = -pc;
                      }
                      c = rawBytes[i];
                      if (pa <= pb && pa <= pc) {
                        buffer[j++] = left + c;
                      } else if (pb <= pc) {
                        buffer[j++] = up + c;
                      } else {
                        buffer[j++] = upLeft + c;
                      }
                    }
                    break;
                  default:
                    throw new _util.FormatError("Unsupported predictor: " + predictor);
                }
                this.bufferLength += rowBytes;
              };
              return PredictorStream2;
            }();
            var JpegStream = function JpegStreamClosure() {
              function JpegStream2(stream, maybeLength, dict, params) {
                var ch;
                while ((ch = stream.getByte()) !== -1) {
                  if (ch === 255) {
                    stream.skip(-1);
                    break;
                  }
                }
                this.stream = stream;
                this.maybeLength = maybeLength;
                this.dict = dict;
                this.params = params;
                DecodeStream.call(this, maybeLength);
              }
              JpegStream2.prototype = Object.create(DecodeStream.prototype);
              Object.defineProperty(JpegStream2.prototype, "bytes", {
                get: function JpegStream_bytes() {
                  return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                },
                configurable: true
              });
              JpegStream2.prototype.ensureBuffer = function JpegStream_ensureBuffer(req) {
                if (this.bufferLength) {
                  return;
                }
                var jpegImage = new _jpg.JpegImage();
                var decodeArr = this.dict.getArray("Decode", "D");
                if (this.forceRGB && Array.isArray(decodeArr)) {
                  var bitsPerComponent = this.dict.get("BitsPerComponent") || 8;
                  var decodeArrLength = decodeArr.length;
                  var transform = new Int32Array(decodeArrLength);
                  var transformNeeded = false;
                  var maxValue = (1 << bitsPerComponent) - 1;
                  for (var i = 0; i < decodeArrLength; i += 2) {
                    transform[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0;
                    transform[i + 1] = decodeArr[i] * maxValue | 0;
                    if (transform[i] !== 256 || transform[i + 1] !== 0) {
                      transformNeeded = true;
                    }
                  }
                  if (transformNeeded) {
                    jpegImage.decodeTransform = transform;
                  }
                }
                if ((0, _primitives.isDict)(this.params)) {
                  var colorTransform = this.params.get("ColorTransform");
                  if (Number.isInteger(colorTransform)) {
                    jpegImage.colorTransform = colorTransform;
                  }
                }
                jpegImage.parse(this.bytes);
                var data = jpegImage.getData(this.drawWidth, this.drawHeight, this.forceRGB);
                this.buffer = data;
                this.bufferLength = data.length;
                this.eof = true;
              };
              JpegStream2.prototype.getBytes = function JpegStream_getBytes(length) {
                this.ensureBuffer();
                return this.buffer;
              };
              JpegStream2.prototype.getIR = function JpegStream_getIR(forceDataSchema) {
                return (0, _util.createObjectURL)(this.bytes, "image/jpeg", forceDataSchema);
              };
              return JpegStream2;
            }();
            var JpxStream = function JpxStreamClosure() {
              function JpxStream2(stream, maybeLength, dict, params) {
                this.stream = stream;
                this.maybeLength = maybeLength;
                this.dict = dict;
                this.params = params;
                DecodeStream.call(this, maybeLength);
              }
              JpxStream2.prototype = Object.create(DecodeStream.prototype);
              Object.defineProperty(JpxStream2.prototype, "bytes", {
                get: function JpxStream_bytes() {
                  return (0, _util.shadow)(this, "bytes", this.stream.getBytes(this.maybeLength));
                },
                configurable: true
              });
              JpxStream2.prototype.ensureBuffer = function JpxStream_ensureBuffer(req) {
                if (this.bufferLength) {
                  return;
                }
                var jpxImage = new _jpx.JpxImage();
                jpxImage.parse(this.bytes);
                var width = jpxImage.width;
                var height = jpxImage.height;
                var componentsCount = jpxImage.componentsCount;
                var tileCount = jpxImage.tiles.length;
                if (tileCount === 1) {
                  this.buffer = jpxImage.tiles[0].items;
                } else {
                  var data = new Uint8ClampedArray(width * height * componentsCount);
                  for (var k = 0; k < tileCount; k++) {
                    var tileComponents = jpxImage.tiles[k];
                    var tileWidth = tileComponents.width;
                    var tileHeight = tileComponents.height;
                    var tileLeft = tileComponents.left;
                    var tileTop = tileComponents.top;
                    var src = tileComponents.items;
                    var srcPosition = 0;
                    var dataPosition = (width * tileTop + tileLeft) * componentsCount;
                    var imgRowSize = width * componentsCount;
                    var tileRowSize = tileWidth * componentsCount;
                    for (var j = 0; j < tileHeight; j++) {
                      var rowBytes = src.subarray(srcPosition, srcPosition + tileRowSize);
                      data.set(rowBytes, dataPosition);
                      srcPosition += tileRowSize;
                      dataPosition += imgRowSize;
                    }
                  }
                  this.buffer = data;
                }
                this.bufferLength = this.buffer.length;
                this.eof = true;
              };
              return JpxStream2;
            }();
            var DecryptStream = function DecryptStreamClosure() {
              function DecryptStream2(str, maybeLength, decrypt) {
                this.str = str;
                this.dict = str.dict;
                this.decrypt = decrypt;
                this.nextChunk = null;
                this.initialized = false;
                DecodeStream.call(this, maybeLength);
              }
              var chunkSize = 512;
              DecryptStream2.prototype = Object.create(DecodeStream.prototype);
              DecryptStream2.prototype.readBlock = function DecryptStream_readBlock() {
                var chunk;
                if (this.initialized) {
                  chunk = this.nextChunk;
                } else {
                  chunk = this.str.getBytes(chunkSize);
                  this.initialized = true;
                }
                if (!chunk || chunk.length === 0) {
                  this.eof = true;
                  return;
                }
                this.nextChunk = this.str.getBytes(chunkSize);
                var hasMoreData = this.nextChunk && this.nextChunk.length > 0;
                var decrypt = this.decrypt;
                chunk = decrypt(chunk, !hasMoreData);
                var bufferLength = this.bufferLength;
                var i, n = chunk.length;
                var buffer = this.ensureBuffer(bufferLength + n);
                for (i = 0; i < n; i++) {
                  buffer[bufferLength++] = chunk[i];
                }
                this.bufferLength = bufferLength;
              };
              return DecryptStream2;
            }();
            var Ascii85Stream = function Ascii85StreamClosure() {
              function Ascii85Stream2(str, maybeLength) {
                this.str = str;
                this.dict = str.dict;
                this.input = new Uint8Array(5);
                if (maybeLength) {
                  maybeLength = 0.8 * maybeLength;
                }
                DecodeStream.call(this, maybeLength);
              }
              Ascii85Stream2.prototype = Object.create(DecodeStream.prototype);
              Ascii85Stream2.prototype.readBlock = function Ascii85Stream_readBlock() {
                var TILDA_CHAR = 126;
                var Z_LOWER_CHAR = 122;
                var EOF = -1;
                var str = this.str;
                var c = str.getByte();
                while ((0, _util.isSpace)(c)) {
                  c = str.getByte();
                }
                if (c === EOF || c === TILDA_CHAR) {
                  this.eof = true;
                  return;
                }
                var bufferLength = this.bufferLength, buffer;
                var i;
                if (c === Z_LOWER_CHAR) {
                  buffer = this.ensureBuffer(bufferLength + 4);
                  for (i = 0; i < 4; ++i) {
                    buffer[bufferLength + i] = 0;
                  }
                  this.bufferLength += 4;
                } else {
                  var input = this.input;
                  input[0] = c;
                  for (i = 1; i < 5; ++i) {
                    c = str.getByte();
                    while ((0, _util.isSpace)(c)) {
                      c = str.getByte();
                    }
                    input[i] = c;
                    if (c === EOF || c === TILDA_CHAR) {
                      break;
                    }
                  }
                  buffer = this.ensureBuffer(bufferLength + i - 1);
                  this.bufferLength += i - 1;
                  if (i < 5) {
                    for (; i < 5; ++i) {
                      input[i] = 33 + 84;
                    }
                    this.eof = true;
                  }
                  var t = 0;
                  for (i = 0; i < 5; ++i) {
                    t = t * 85 + (input[i] - 33);
                  }
                  for (i = 3; i >= 0; --i) {
                    buffer[bufferLength + i] = t & 255;
                    t >>= 8;
                  }
                }
              };
              return Ascii85Stream2;
            }();
            var AsciiHexStream = function AsciiHexStreamClosure() {
              function AsciiHexStream2(str, maybeLength) {
                this.str = str;
                this.dict = str.dict;
                this.firstDigit = -1;
                if (maybeLength) {
                  maybeLength = 0.5 * maybeLength;
                }
                DecodeStream.call(this, maybeLength);
              }
              AsciiHexStream2.prototype = Object.create(DecodeStream.prototype);
              AsciiHexStream2.prototype.readBlock = function AsciiHexStream_readBlock() {
                var UPSTREAM_BLOCK_SIZE = 8e3;
                var bytes = this.str.getBytes(UPSTREAM_BLOCK_SIZE);
                if (!bytes.length) {
                  this.eof = true;
                  return;
                }
                var maxDecodeLength = bytes.length + 1 >> 1;
                var buffer = this.ensureBuffer(this.bufferLength + maxDecodeLength);
                var bufferLength = this.bufferLength;
                var firstDigit = this.firstDigit;
                for (var i = 0, ii = bytes.length; i < ii; i++) {
                  var ch = bytes[i], digit;
                  if (ch >= 48 && ch <= 57) {
                    digit = ch & 15;
                  } else if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
                    digit = (ch & 15) + 9;
                  } else if (ch === 62) {
                    this.eof = true;
                    break;
                  } else {
                    continue;
                  }
                  if (firstDigit < 0) {
                    firstDigit = digit;
                  } else {
                    buffer[bufferLength++] = firstDigit << 4 | digit;
                    firstDigit = -1;
                  }
                }
                if (firstDigit >= 0 && this.eof) {
                  buffer[bufferLength++] = firstDigit << 4;
                  firstDigit = -1;
                }
                this.firstDigit = firstDigit;
                this.bufferLength = bufferLength;
              };
              return AsciiHexStream2;
            }();
            var RunLengthStream = function RunLengthStreamClosure() {
              function RunLengthStream2(str, maybeLength) {
                this.str = str;
                this.dict = str.dict;
                DecodeStream.call(this, maybeLength);
              }
              RunLengthStream2.prototype = Object.create(DecodeStream.prototype);
              RunLengthStream2.prototype.readBlock = function RunLengthStream_readBlock() {
                var repeatHeader = this.str.getBytes(2);
                if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {
                  this.eof = true;
                  return;
                }
                var buffer;
                var bufferLength = this.bufferLength;
                var n = repeatHeader[0];
                if (n < 128) {
                  buffer = this.ensureBuffer(bufferLength + n + 1);
                  buffer[bufferLength++] = repeatHeader[1];
                  if (n > 0) {
                    var source = this.str.getBytes(n);
                    buffer.set(source, bufferLength);
                    bufferLength += n;
                  }
                } else {
                  n = 257 - n;
                  var b = repeatHeader[1];
                  buffer = this.ensureBuffer(bufferLength + n + 1);
                  for (var i = 0; i < n; i++) {
                    buffer[bufferLength++] = b;
                  }
                }
                this.bufferLength = bufferLength;
              };
              return RunLengthStream2;
            }();
            var LZWStream = function LZWStreamClosure() {
              function LZWStream2(str, maybeLength, earlyChange) {
                this.str = str;
                this.dict = str.dict;
                this.cachedData = 0;
                this.bitsCached = 0;
                var maxLzwDictionarySize = 4096;
                var lzwState = {
                  earlyChange,
                  codeLength: 9,
                  nextCode: 258,
                  dictionaryValues: new Uint8Array(maxLzwDictionarySize),
                  dictionaryLengths: new Uint16Array(maxLzwDictionarySize),
                  dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),
                  currentSequence: new Uint8Array(maxLzwDictionarySize),
                  currentSequenceLength: 0
                };
                for (var i = 0; i < 256; ++i) {
                  lzwState.dictionaryValues[i] = i;
                  lzwState.dictionaryLengths[i] = 1;
                }
                this.lzwState = lzwState;
                DecodeStream.call(this, maybeLength);
              }
              LZWStream2.prototype = Object.create(DecodeStream.prototype);
              LZWStream2.prototype.readBits = function LZWStream_readBits(n) {
                var bitsCached = this.bitsCached;
                var cachedData = this.cachedData;
                while (bitsCached < n) {
                  var c = this.str.getByte();
                  if (c === -1) {
                    this.eof = true;
                    return null;
                  }
                  cachedData = cachedData << 8 | c;
                  bitsCached += 8;
                }
                this.bitsCached = bitsCached -= n;
                this.cachedData = cachedData;
                this.lastCode = null;
                return cachedData >>> bitsCached & (1 << n) - 1;
              };
              LZWStream2.prototype.readBlock = function LZWStream_readBlock() {
                var blockSize = 512;
                var estimatedDecodedSize = blockSize * 2, decodedSizeDelta = blockSize;
                var i, j, q;
                var lzwState = this.lzwState;
                if (!lzwState) {
                  return;
                }
                var earlyChange = lzwState.earlyChange;
                var nextCode = lzwState.nextCode;
                var dictionaryValues = lzwState.dictionaryValues;
                var dictionaryLengths = lzwState.dictionaryLengths;
                var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;
                var codeLength = lzwState.codeLength;
                var prevCode = lzwState.prevCode;
                var currentSequence = lzwState.currentSequence;
                var currentSequenceLength = lzwState.currentSequenceLength;
                var decodedLength = 0;
                var currentBufferLength = this.bufferLength;
                var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                for (i = 0; i < blockSize; i++) {
                  var code = this.readBits(codeLength);
                  var hasPrev = currentSequenceLength > 0;
                  if (code < 256) {
                    currentSequence[0] = code;
                    currentSequenceLength = 1;
                  } else if (code >= 258) {
                    if (code < nextCode) {
                      currentSequenceLength = dictionaryLengths[code];
                      for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {
                        currentSequence[j] = dictionaryValues[q];
                        q = dictionaryPrevCodes[q];
                      }
                    } else {
                      currentSequence[currentSequenceLength++] = currentSequence[0];
                    }
                  } else if (code === 256) {
                    codeLength = 9;
                    nextCode = 258;
                    currentSequenceLength = 0;
                    continue;
                  } else {
                    this.eof = true;
                    delete this.lzwState;
                    break;
                  }
                  if (hasPrev) {
                    dictionaryPrevCodes[nextCode] = prevCode;
                    dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;
                    dictionaryValues[nextCode] = currentSequence[0];
                    nextCode++;
                    codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;
                  }
                  prevCode = code;
                  decodedLength += currentSequenceLength;
                  if (estimatedDecodedSize < decodedLength) {
                    do {
                      estimatedDecodedSize += decodedSizeDelta;
                    } while (estimatedDecodedSize < decodedLength);
                    buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);
                  }
                  for (j = 0; j < currentSequenceLength; j++) {
                    buffer[currentBufferLength++] = currentSequence[j];
                  }
                }
                lzwState.nextCode = nextCode;
                lzwState.codeLength = codeLength;
                lzwState.prevCode = prevCode;
                lzwState.currentSequenceLength = currentSequenceLength;
                this.bufferLength = currentBufferLength;
              };
              return LZWStream2;
            }();
            var NullStream = function NullStreamClosure() {
              function NullStream2() {
                Stream.call(this, new Uint8Array(0));
              }
              NullStream2.prototype = Stream.prototype;
              return NullStream2;
            }();
            exports2.Ascii85Stream = Ascii85Stream;
            exports2.AsciiHexStream = AsciiHexStream;
            exports2.DecryptStream = DecryptStream;
            exports2.DecodeStream = DecodeStream;
            exports2.FlateStream = FlateStream;
            exports2.JpegStream = JpegStream;
            exports2.JpxStream = JpxStream;
            exports2.NullStream = NullStream;
            exports2.PredictorStream = PredictorStream;
            exports2.RunLengthStream = RunLengthStream;
            exports2.Stream = Stream;
            exports2.StreamsSequenceStream = StreamsSequenceStream;
            exports2.StringStream = StringStream;
            exports2.LZWStream = LZWStream;
          },
          /* 6 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var core = module2.exports = { version: "2.5.7" };
            if (typeof __e == "number") __e = core;
          },
          /* 7 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(1);
            var core = __w_pdfjs_require__(6);
            var hide = __w_pdfjs_require__(8);
            var redefine = __w_pdfjs_require__(16);
            var ctx = __w_pdfjs_require__(13);
            var PROTOTYPE = "prototype";
            var $export = function $export2(type, name, source) {
              var IS_FORCED = type & $export2.F;
              var IS_GLOBAL = type & $export2.G;
              var IS_STATIC = type & $export2.S;
              var IS_PROTO = type & $export2.P;
              var IS_BIND = type & $export2.B;
              var target = IS_GLOBAL ? global2 : IS_STATIC ? global2[name] || (global2[name] = {}) : (global2[name] || {})[PROTOTYPE];
              var exports3 = IS_GLOBAL ? core : core[name] || (core[name] = {});
              var expProto = exports3[PROTOTYPE] || (exports3[PROTOTYPE] = {});
              var key, own, out, exp;
              if (IS_GLOBAL) source = name;
              for (key in source) {
                own = !IS_FORCED && target && target[key] !== void 0;
                out = (own ? target : source)[key];
                exp = IS_BIND && own ? ctx(out, global2) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
                if (target) redefine(target, key, out, type & $export2.U);
                if (exports3[key] != out) hide(exports3, key, exp);
                if (IS_PROTO && expProto[key] != out) expProto[key] = out;
              }
            };
            global2.core = core;
            $export.F = 1;
            $export.G = 2;
            $export.S = 4;
            $export.P = 8;
            $export.B = 16;
            $export.W = 32;
            $export.U = 64;
            $export.R = 128;
            module2.exports = $export;
          },
          /* 8 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var dP = __w_pdfjs_require__(15);
            var createDesc = __w_pdfjs_require__(29);
            module2.exports = __w_pdfjs_require__(10) ? function(object, key, value) {
              return dP.f(object, key, createDesc(1, value));
            } : function(object, key, value) {
              object[key] = value;
              return object;
            };
          },
          /* 9 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(3);
            module2.exports = function(it) {
              if (!isObject(it)) throw TypeError(it + " is not an object!");
              return it;
            };
          },
          /* 10 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = !__w_pdfjs_require__(11)(function() {
              return Object.defineProperty({}, "a", {
                get: function get() {
                  return 7;
                }
              }).a != 7;
            });
          },
          /* 11 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = function(exec) {
              try {
                return !!exec();
              } catch (e) {
                return true;
              }
            };
          },
          /* 12 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var hasOwnProperty = {}.hasOwnProperty;
            module2.exports = function(it, key) {
              return hasOwnProperty.call(it, key);
            };
          },
          /* 13 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var aFunction = __w_pdfjs_require__(22);
            module2.exports = function(fn, that, length) {
              aFunction(fn);
              if (that === void 0) return fn;
              switch (length) {
                case 1:
                  return function(a) {
                    return fn.call(that, a);
                  };
                case 2:
                  return function(a, b) {
                    return fn.call(that, a, b);
                  };
                case 3:
                  return function(a, b, c) {
                    return fn.call(that, a, b, c);
                  };
              }
              return function() {
                return fn.apply(that, arguments);
              };
            };
          },
          /* 14 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var toInteger = __w_pdfjs_require__(18);
            var min = Math.min;
            module2.exports = function(it) {
              return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
            };
          },
          /* 15 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var anObject = __w_pdfjs_require__(9);
            var IE8_DOM_DEFINE = __w_pdfjs_require__(48);
            var toPrimitive = __w_pdfjs_require__(36);
            var dP = Object.defineProperty;
            exports2.f = __w_pdfjs_require__(10) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
              anObject(O);
              P = toPrimitive(P, true);
              anObject(Attributes);
              if (IE8_DOM_DEFINE) try {
                return dP(O, P, Attributes);
              } catch (e) {
              }
              if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
              if ("value" in Attributes) O[P] = Attributes.value;
              return O;
            };
          },
          /* 16 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var global2 = __w_pdfjs_require__(1);
            var hide = __w_pdfjs_require__(8);
            var has = __w_pdfjs_require__(12);
            var SRC = __w_pdfjs_require__(17)("src");
            var TO_STRING = "toString";
            var $toString = Function[TO_STRING];
            var TPL = ("" + $toString).split(TO_STRING);
            __w_pdfjs_require__(6).inspectSource = function(it) {
              return $toString.call(it);
            };
            (module2.exports = function(O, key, val, safe) {
              var isFunction = typeof val == "function";
              if (isFunction) has(val, "name") || hide(val, "name", key);
              if (O[key] === val) return;
              if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? "" + O[key] : TPL.join(String(key)));
              if (O === global2) {
                O[key] = val;
              } else if (!safe) {
                delete O[key];
                hide(O, key, val);
              } else if (O[key]) {
                O[key] = val;
              } else {
                hide(O, key, val);
              }
            })(Function.prototype, TO_STRING, function toString() {
              return typeof this == "function" && this[SRC] || $toString.call(this);
            });
          },
          /* 17 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var id = 0;
            var px = Math.random();
            module2.exports = function(key) {
              return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
            };
          },
          /* 18 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var ceil = Math.ceil;
            var floor = Math.floor;
            module2.exports = function(it) {
              return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
            };
          },
          /* 19 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var defined = __w_pdfjs_require__(38);
            module2.exports = function(it) {
              return Object(defined(it));
            };
          },
          /* 20 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = {};
          },
          /* 21 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = false;
          },
          /* 22 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = function(it) {
              if (typeof it != "function") throw TypeError(it + " is not a function!");
              return it;
            };
          },
          /* 23 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var redefine = __w_pdfjs_require__(16);
            module2.exports = function(target, src, safe) {
              for (var key in src) {
                redefine(target, key, src[key], safe);
              }
              return target;
            };
          },
          /* 24 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = function(it, Constructor, name, forbiddenField) {
              if (!(it instanceof Constructor) || forbiddenField !== void 0 && forbiddenField in it) {
                throw TypeError(name + ": incorrect invocation!");
              }
              return it;
            };
          },
          /* 25 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var toString = {}.toString;
            module2.exports = function(it) {
              return toString.call(it).slice(8, -1);
            };
          },
          /* 26 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var def = __w_pdfjs_require__(15).f;
            var has = __w_pdfjs_require__(12);
            var TAG = __w_pdfjs_require__(4)("toStringTag");
            module2.exports = function(it, tag, stat) {
              if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
                configurable: true,
                value: tag
              });
            };
          },
          /* 27 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.ColorSpace = void 0;
            var _util = __w_pdfjs_require__(0);
            var _primitives = __w_pdfjs_require__(2);
            var ColorSpace = function ColorSpaceClosure() {
              function resizeRgbImage(src, bpc, w1, h1, w2, h2, alpha01, dest) {
                var COMPONENTS = 3;
                alpha01 = alpha01 !== 1 ? 0 : alpha01;
                var xRatio = w1 / w2;
                var yRatio = h1 / h2;
                var i, j, py, newIndex = 0, oldIndex;
                var xScaled = new Uint16Array(w2);
                var w1Scanline = w1 * COMPONENTS;
                for (i = 0; i < w2; i++) {
                  xScaled[i] = Math.floor(i * xRatio) * COMPONENTS;
                }
                for (i = 0; i < h2; i++) {
                  py = Math.floor(i * yRatio) * w1Scanline;
                  for (j = 0; j < w2; j++) {
                    oldIndex = py + xScaled[j];
                    dest[newIndex++] = src[oldIndex++];
                    dest[newIndex++] = src[oldIndex++];
                    dest[newIndex++] = src[oldIndex++];
                    newIndex += alpha01;
                  }
                }
              }
              function ColorSpace2() {
                throw new Error("should not call ColorSpace constructor");
              }
              ColorSpace2.prototype = {
                getRgb: function ColorSpace_getRgb(src, srcOffset) {
                  var rgb = new Uint8Array(3);
                  this.getRgbItem(src, srcOffset, rgb, 0);
                  return rgb;
                },
                getRgbItem: function ColorSpace_getRgbItem(src, srcOffset, dest, destOffset) {
                  throw new Error("Should not call ColorSpace.getRgbItem");
                },
                getRgbBuffer: function ColorSpace_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  throw new Error("Should not call ColorSpace.getRgbBuffer");
                },
                getOutputLength: function ColorSpace_getOutputLength(inputLength, alpha01) {
                  throw new Error("Should not call ColorSpace.getOutputLength");
                },
                isPassthrough: function ColorSpace_isPassthrough(bits) {
                  return false;
                },
                fillRgb: function ColorSpace_fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) {
                  var count = originalWidth * originalHeight;
                  var rgbBuf = null;
                  var numComponentColors = 1 << bpc;
                  var needsResizing = originalHeight !== height || originalWidth !== width;
                  var i, ii;
                  if (this.isPassthrough(bpc)) {
                    rgbBuf = comps;
                  } else if (this.numComps === 1 && count > numComponentColors && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
                    var allColors = bpc <= 8 ? new Uint8Array(numComponentColors) : new Uint16Array(numComponentColors);
                    var key;
                    for (i = 0; i < numComponentColors; i++) {
                      allColors[i] = i;
                    }
                    var colorMap = new Uint8Array(numComponentColors * 3);
                    this.getRgbBuffer(allColors, 0, numComponentColors, colorMap, 0, bpc, 0);
                    var destPos, rgbPos;
                    if (!needsResizing) {
                      destPos = 0;
                      for (i = 0; i < count; ++i) {
                        key = comps[i] * 3;
                        dest[destPos++] = colorMap[key];
                        dest[destPos++] = colorMap[key + 1];
                        dest[destPos++] = colorMap[key + 2];
                        destPos += alpha01;
                      }
                    } else {
                      rgbBuf = new Uint8Array(count * 3);
                      rgbPos = 0;
                      for (i = 0; i < count; ++i) {
                        key = comps[i] * 3;
                        rgbBuf[rgbPos++] = colorMap[key];
                        rgbBuf[rgbPos++] = colorMap[key + 1];
                        rgbBuf[rgbPos++] = colorMap[key + 2];
                      }
                    }
                  } else {
                    if (!needsResizing) {
                      this.getRgbBuffer(comps, 0, width * actualHeight, dest, 0, bpc, alpha01);
                    } else {
                      rgbBuf = new Uint8Array(count * 3);
                      this.getRgbBuffer(comps, 0, count, rgbBuf, 0, bpc, 0);
                    }
                  }
                  if (rgbBuf) {
                    if (needsResizing) {
                      resizeRgbImage(rgbBuf, bpc, originalWidth, originalHeight, width, height, alpha01, dest);
                    } else {
                      rgbPos = 0;
                      destPos = 0;
                      for (i = 0, ii = width * actualHeight; i < ii; i++) {
                        dest[destPos++] = rgbBuf[rgbPos++];
                        dest[destPos++] = rgbBuf[rgbPos++];
                        dest[destPos++] = rgbBuf[rgbPos++];
                        destPos += alpha01;
                      }
                    }
                  }
                },
                usesZeroToOneRange: true
              };
              ColorSpace2.parse = function(cs, xref, res, pdfFunctionFactory) {
                var IR = ColorSpace2.parseToIR(cs, xref, res, pdfFunctionFactory);
                return ColorSpace2.fromIR(IR);
              };
              ColorSpace2.fromIR = function(IR) {
                var name = Array.isArray(IR) ? IR[0] : IR;
                var whitePoint, blackPoint, gamma;
                switch (name) {
                  case "DeviceGrayCS":
                    return this.singletons.gray;
                  case "DeviceRgbCS":
                    return this.singletons.rgb;
                  case "DeviceCmykCS":
                    return this.singletons.cmyk;
                  case "CalGrayCS":
                    whitePoint = IR[1];
                    blackPoint = IR[2];
                    gamma = IR[3];
                    return new CalGrayCS(whitePoint, blackPoint, gamma);
                  case "CalRGBCS":
                    whitePoint = IR[1];
                    blackPoint = IR[2];
                    gamma = IR[3];
                    var matrix = IR[4];
                    return new CalRGBCS(whitePoint, blackPoint, gamma, matrix);
                  case "PatternCS":
                    var basePatternCS = IR[1];
                    if (basePatternCS) {
                      basePatternCS = ColorSpace2.fromIR(basePatternCS);
                    }
                    return new PatternCS(basePatternCS);
                  case "IndexedCS":
                    var baseIndexedCS = IR[1];
                    var hiVal = IR[2];
                    var lookup = IR[3];
                    return new IndexedCS(ColorSpace2.fromIR(baseIndexedCS), hiVal, lookup);
                  case "AlternateCS":
                    var numComps = IR[1];
                    var alt = IR[2];
                    var tintFn = IR[3];
                    return new AlternateCS(numComps, ColorSpace2.fromIR(alt), tintFn);
                  case "LabCS":
                    whitePoint = IR[1];
                    blackPoint = IR[2];
                    var range = IR[3];
                    return new LabCS(whitePoint, blackPoint, range);
                  default:
                    throw new _util.FormatError("Unknown colorspace name: " + name);
                }
              };
              ColorSpace2.parseToIR = function(cs, xref, res, pdfFunctionFactory) {
                if ((0, _primitives.isName)(cs)) {
                  var colorSpaces = res.get("ColorSpace");
                  if ((0, _primitives.isDict)(colorSpaces)) {
                    var refcs = colorSpaces.get(cs.name);
                    if (refcs) {
                      cs = refcs;
                    }
                  }
                }
                cs = xref.fetchIfRef(cs);
                if ((0, _primitives.isName)(cs)) {
                  switch (cs.name) {
                    case "DeviceGray":
                    case "G":
                      return "DeviceGrayCS";
                    case "DeviceRGB":
                    case "RGB":
                      return "DeviceRgbCS";
                    case "DeviceCMYK":
                    case "CMYK":
                      return "DeviceCmykCS";
                    case "Pattern":
                      return ["PatternCS", null];
                    default:
                      throw new _util.FormatError("unrecognized colorspace " + cs.name);
                  }
                }
                if (Array.isArray(cs)) {
                  var mode = xref.fetchIfRef(cs[0]).name;
                  var numComps, params, alt, whitePoint, blackPoint, gamma;
                  switch (mode) {
                    case "DeviceGray":
                    case "G":
                      return "DeviceGrayCS";
                    case "DeviceRGB":
                    case "RGB":
                      return "DeviceRgbCS";
                    case "DeviceCMYK":
                    case "CMYK":
                      return "DeviceCmykCS";
                    case "CalGray":
                      params = xref.fetchIfRef(cs[1]);
                      whitePoint = params.getArray("WhitePoint");
                      blackPoint = params.getArray("BlackPoint");
                      gamma = params.get("Gamma");
                      return ["CalGrayCS", whitePoint, blackPoint, gamma];
                    case "CalRGB":
                      params = xref.fetchIfRef(cs[1]);
                      whitePoint = params.getArray("WhitePoint");
                      blackPoint = params.getArray("BlackPoint");
                      gamma = params.getArray("Gamma");
                      var matrix = params.getArray("Matrix");
                      return ["CalRGBCS", whitePoint, blackPoint, gamma, matrix];
                    case "ICCBased":
                      var stream = xref.fetchIfRef(cs[1]);
                      var dict = stream.dict;
                      numComps = dict.get("N");
                      alt = dict.get("Alternate");
                      if (alt) {
                        var altIR = ColorSpace2.parseToIR(alt, xref, res, pdfFunctionFactory);
                        var altCS = ColorSpace2.fromIR(altIR, pdfFunctionFactory);
                        if (altCS.numComps === numComps) {
                          return altIR;
                        }
                        (0, _util.warn)("ICCBased color space: Ignoring incorrect /Alternate entry.");
                      }
                      if (numComps === 1) {
                        return "DeviceGrayCS";
                      } else if (numComps === 3) {
                        return "DeviceRgbCS";
                      } else if (numComps === 4) {
                        return "DeviceCmykCS";
                      }
                      break;
                    case "Pattern":
                      var basePatternCS = cs[1] || null;
                      if (basePatternCS) {
                        basePatternCS = ColorSpace2.parseToIR(basePatternCS, xref, res, pdfFunctionFactory);
                      }
                      return ["PatternCS", basePatternCS];
                    case "Indexed":
                    case "I":
                      var baseIndexedCS = ColorSpace2.parseToIR(cs[1], xref, res, pdfFunctionFactory);
                      var hiVal = xref.fetchIfRef(cs[2]) + 1;
                      var lookup = xref.fetchIfRef(cs[3]);
                      if ((0, _primitives.isStream)(lookup)) {
                        lookup = lookup.getBytes();
                      }
                      return ["IndexedCS", baseIndexedCS, hiVal, lookup];
                    case "Separation":
                    case "DeviceN":
                      var name = xref.fetchIfRef(cs[1]);
                      numComps = Array.isArray(name) ? name.length : 1;
                      alt = ColorSpace2.parseToIR(cs[2], xref, res, pdfFunctionFactory);
                      var tintFn = pdfFunctionFactory.create(xref.fetchIfRef(cs[3]));
                      return ["AlternateCS", numComps, alt, tintFn];
                    case "Lab":
                      params = xref.fetchIfRef(cs[1]);
                      whitePoint = params.getArray("WhitePoint");
                      blackPoint = params.getArray("BlackPoint");
                      var range = params.getArray("Range");
                      return ["LabCS", whitePoint, blackPoint, range];
                    default:
                      throw new _util.FormatError('unimplemented color space object "' + mode + '"');
                  }
                }
                throw new _util.FormatError('unrecognized color space object: "' + cs + '"');
              };
              ColorSpace2.isDefaultDecode = function ColorSpace_isDefaultDecode(decode, n) {
                if (!Array.isArray(decode)) {
                  return true;
                }
                if (n * 2 !== decode.length) {
                  (0, _util.warn)("The decode map is not the correct length");
                  return true;
                }
                for (var i = 0, ii = decode.length; i < ii; i += 2) {
                  if (decode[i] !== 0 || decode[i + 1] !== 1) {
                    return false;
                  }
                }
                return true;
              };
              ColorSpace2.singletons = {
                get gray() {
                  return (0, _util.shadow)(this, "gray", new DeviceGrayCS());
                },
                get rgb() {
                  return (0, _util.shadow)(this, "rgb", new DeviceRgbCS());
                },
                get cmyk() {
                  return (0, _util.shadow)(this, "cmyk", new DeviceCmykCS());
                }
              };
              return ColorSpace2;
            }();
            var AlternateCS = function AlternateCSClosure() {
              function AlternateCS2(numComps, base, tintFn) {
                this.name = "Alternate";
                this.numComps = numComps;
                this.defaultColor = new Float32Array(numComps);
                for (var i = 0; i < numComps; ++i) {
                  this.defaultColor[i] = 1;
                }
                this.base = base;
                this.tintFn = tintFn;
                this.tmpBuf = new Float32Array(base.numComps);
              }
              AlternateCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function AlternateCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  var tmpBuf = this.tmpBuf;
                  this.tintFn(src, srcOffset, tmpBuf, 0);
                  this.base.getRgbItem(tmpBuf, 0, dest, destOffset);
                },
                getRgbBuffer: function AlternateCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var tintFn = this.tintFn;
                  var base = this.base;
                  var scale = 1 / ((1 << bits) - 1);
                  var baseNumComps = base.numComps;
                  var usesZeroToOneRange = base.usesZeroToOneRange;
                  var isPassthrough = (base.isPassthrough(8) || !usesZeroToOneRange) && alpha01 === 0;
                  var pos = isPassthrough ? destOffset : 0;
                  var baseBuf = isPassthrough ? dest : new Uint8Array(baseNumComps * count);
                  var numComps = this.numComps;
                  var scaled = new Float32Array(numComps);
                  var tinted = new Float32Array(baseNumComps);
                  var i, j;
                  for (i = 0; i < count; i++) {
                    for (j = 0; j < numComps; j++) {
                      scaled[j] = src[srcOffset++] * scale;
                    }
                    tintFn(scaled, 0, tinted, 0);
                    if (usesZeroToOneRange) {
                      for (j = 0; j < baseNumComps; j++) {
                        baseBuf[pos++] = tinted[j] * 255;
                      }
                    } else {
                      base.getRgbItem(tinted, 0, baseBuf, pos);
                      pos += baseNumComps;
                    }
                  }
                  if (!isPassthrough) {
                    base.getRgbBuffer(baseBuf, 0, count, dest, destOffset, 8, alpha01);
                  }
                },
                getOutputLength: function AlternateCS_getOutputLength(inputLength, alpha01) {
                  return this.base.getOutputLength(inputLength * this.base.numComps / this.numComps, alpha01);
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function AlternateCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return AlternateCS2;
            }();
            var PatternCS = function PatternCSClosure() {
              function PatternCS2(baseCS) {
                this.name = "Pattern";
                this.base = baseCS;
              }
              PatternCS2.prototype = {};
              return PatternCS2;
            }();
            var IndexedCS = function IndexedCSClosure() {
              function IndexedCS2(base, highVal, lookup) {
                this.name = "Indexed";
                this.numComps = 1;
                this.defaultColor = new Uint8Array(this.numComps);
                this.base = base;
                this.highVal = highVal;
                var baseNumComps = base.numComps;
                var length = baseNumComps * highVal;
                if ((0, _primitives.isStream)(lookup)) {
                  this.lookup = new Uint8Array(length);
                  var bytes = lookup.getBytes(length);
                  this.lookup.set(bytes);
                } else if ((0, _util.isString)(lookup)) {
                  this.lookup = new Uint8Array(length);
                  for (var i = 0; i < length; ++i) {
                    this.lookup[i] = lookup.charCodeAt(i);
                  }
                } else if (lookup instanceof Uint8Array || lookup instanceof Array) {
                  this.lookup = lookup;
                } else {
                  throw new _util.FormatError("Unrecognized lookup table: " + lookup);
                }
              }
              IndexedCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function IndexedCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  var numComps = this.base.numComps;
                  var start = src[srcOffset] * numComps;
                  this.base.getRgbBuffer(this.lookup, start, 1, dest, destOffset, 8, 0);
                },
                getRgbBuffer: function IndexedCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var base = this.base;
                  var numComps = base.numComps;
                  var outputDelta = base.getOutputLength(numComps, alpha01);
                  var lookup = this.lookup;
                  for (var i = 0; i < count; ++i) {
                    var lookupPos = src[srcOffset++] * numComps;
                    base.getRgbBuffer(lookup, lookupPos, 1, dest, destOffset, 8, alpha01);
                    destOffset += outputDelta;
                  }
                },
                getOutputLength: function IndexedCS_getOutputLength(inputLength, alpha01) {
                  return this.base.getOutputLength(inputLength * this.base.numComps, alpha01);
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function IndexedCS_isDefaultDecode(decodeMap) {
                  return true;
                },
                usesZeroToOneRange: true
              };
              return IndexedCS2;
            }();
            var DeviceGrayCS = function DeviceGrayCSClosure() {
              function DeviceGrayCS2() {
                this.name = "DeviceGray";
                this.numComps = 1;
                this.defaultColor = new Float32Array(this.numComps);
              }
              DeviceGrayCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function DeviceGrayCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  var c = src[srcOffset] * 255 | 0;
                  c = c < 0 ? 0 : c > 255 ? 255 : c;
                  dest[destOffset] = dest[destOffset + 1] = dest[destOffset + 2] = c;
                },
                getRgbBuffer: function DeviceGrayCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var scale = 255 / ((1 << bits) - 1);
                  var j = srcOffset, q = destOffset;
                  for (var i = 0; i < count; ++i) {
                    var c = scale * src[j++] | 0;
                    dest[q++] = c;
                    dest[q++] = c;
                    dest[q++] = c;
                    q += alpha01;
                  }
                },
                getOutputLength: function DeviceGrayCS_getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01);
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function DeviceGrayCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return DeviceGrayCS2;
            }();
            var DeviceRgbCS = function DeviceRgbCSClosure() {
              function DeviceRgbCS2() {
                this.name = "DeviceRGB";
                this.numComps = 3;
                this.defaultColor = new Float32Array(this.numComps);
              }
              DeviceRgbCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function DeviceRgbCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  var r = src[srcOffset] * 255 | 0;
                  var g = src[srcOffset + 1] * 255 | 0;
                  var b = src[srcOffset + 2] * 255 | 0;
                  dest[destOffset] = r < 0 ? 0 : r > 255 ? 255 : r;
                  dest[destOffset + 1] = g < 0 ? 0 : g > 255 ? 255 : g;
                  dest[destOffset + 2] = b < 0 ? 0 : b > 255 ? 255 : b;
                },
                getRgbBuffer: function DeviceRgbCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  if (bits === 8 && alpha01 === 0) {
                    dest.set(src.subarray(srcOffset, srcOffset + count * 3), destOffset);
                    return;
                  }
                  var scale = 255 / ((1 << bits) - 1);
                  var j = srcOffset, q = destOffset;
                  for (var i = 0; i < count; ++i) {
                    dest[q++] = scale * src[j++] | 0;
                    dest[q++] = scale * src[j++] | 0;
                    dest[q++] = scale * src[j++] | 0;
                    q += alpha01;
                  }
                },
                getOutputLength: function DeviceRgbCS_getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01) / 3 | 0;
                },
                isPassthrough: function DeviceRgbCS_isPassthrough(bits) {
                  return bits === 8;
                },
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function DeviceRgbCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return DeviceRgbCS2;
            }();
            var DeviceCmykCS = function DeviceCmykCSClosure() {
              function convertToRgb(src, srcOffset, srcScale, dest, destOffset) {
                var c = src[srcOffset + 0] * srcScale;
                var m = src[srcOffset + 1] * srcScale;
                var y = src[srcOffset + 2] * srcScale;
                var k = src[srcOffset + 3] * srcScale;
                var r = c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747) + 255 | 0;
                var g = c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) + k * (-20.737325471181034 * k - 187.80453709719578) + 255 | 0;
                var b = c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505) + k * (-22.33816807309886 * k - 180.12613974708367) + 255 | 0;
                dest[destOffset] = r > 255 ? 255 : r < 0 ? 0 : r;
                dest[destOffset + 1] = g > 255 ? 255 : g < 0 ? 0 : g;
                dest[destOffset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;
              }
              function DeviceCmykCS2() {
                this.name = "DeviceCMYK";
                this.numComps = 4;
                this.defaultColor = new Float32Array(this.numComps);
                this.defaultColor[3] = 1;
              }
              DeviceCmykCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function DeviceCmykCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  convertToRgb(src, srcOffset, 1, dest, destOffset);
                },
                getRgbBuffer: function DeviceCmykCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var scale = 1 / ((1 << bits) - 1);
                  for (var i = 0; i < count; i++) {
                    convertToRgb(src, srcOffset, scale, dest, destOffset);
                    srcOffset += 4;
                    destOffset += 3 + alpha01;
                  }
                },
                getOutputLength: function DeviceCmykCS_getOutputLength(inputLength, alpha01) {
                  return inputLength / 4 * (3 + alpha01) | 0;
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function DeviceCmykCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return DeviceCmykCS2;
            }();
            var CalGrayCS = function CalGrayCSClosure() {
              function CalGrayCS2(whitePoint, blackPoint, gamma) {
                this.name = "CalGray";
                this.numComps = 1;
                this.defaultColor = new Float32Array(this.numComps);
                if (!whitePoint) {
                  throw new _util.FormatError("WhitePoint missing - required for color space CalGray");
                }
                blackPoint = blackPoint || [0, 0, 0];
                gamma = gamma || 1;
                this.XW = whitePoint[0];
                this.YW = whitePoint[1];
                this.ZW = whitePoint[2];
                this.XB = blackPoint[0];
                this.YB = blackPoint[1];
                this.ZB = blackPoint[2];
                this.G = gamma;
                if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
                  throw new _util.FormatError("Invalid WhitePoint components for " + this.name + ", no fallback available");
                }
                if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
                  (0, _util.info)("Invalid BlackPoint for " + this.name + ", falling back to default");
                  this.XB = this.YB = this.ZB = 0;
                }
                if (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) {
                  (0, _util.warn)(this.name + ", BlackPoint: XB: " + this.XB + ", YB: " + this.YB + ", ZB: " + this.ZB + ", only default values are supported.");
                }
                if (this.G < 1) {
                  (0, _util.info)("Invalid Gamma: " + this.G + " for " + this.name + ", falling back to default");
                  this.G = 1;
                }
              }
              function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
                var A = src[srcOffset] * scale;
                var AG = Math.pow(A, cs.G);
                var L = cs.YW * AG;
                var val = Math.max(295.8 * Math.pow(L, 0.3333333333333333) - 40.8, 0) | 0;
                dest[destOffset] = val;
                dest[destOffset + 1] = val;
                dest[destOffset + 2] = val;
              }
              CalGrayCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function CalGrayCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  convertToRgb(this, src, srcOffset, dest, destOffset, 1);
                },
                getRgbBuffer: function CalGrayCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var scale = 1 / ((1 << bits) - 1);
                  for (var i = 0; i < count; ++i) {
                    convertToRgb(this, src, srcOffset, dest, destOffset, scale);
                    srcOffset += 1;
                    destOffset += 3 + alpha01;
                  }
                },
                getOutputLength: function CalGrayCS_getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01);
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function CalGrayCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return CalGrayCS2;
            }();
            var CalRGBCS = function CalRGBCSClosure() {
              var BRADFORD_SCALE_MATRIX = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
              var BRADFORD_SCALE_INVERSE_MATRIX = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]);
              var SRGB_D65_XYZ_TO_RGB_MATRIX = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]);
              var FLAT_WHITEPOINT_MATRIX = new Float32Array([1, 1, 1]);
              var tempNormalizeMatrix = new Float32Array(3);
              var tempConvertMatrix1 = new Float32Array(3);
              var tempConvertMatrix2 = new Float32Array(3);
              var DECODE_L_CONSTANT = Math.pow((8 + 16) / 116, 3) / 8;
              function CalRGBCS2(whitePoint, blackPoint, gamma, matrix) {
                this.name = "CalRGB";
                this.numComps = 3;
                this.defaultColor = new Float32Array(this.numComps);
                if (!whitePoint) {
                  throw new _util.FormatError("WhitePoint missing - required for color space CalRGB");
                }
                blackPoint = blackPoint || new Float32Array(3);
                gamma = gamma || new Float32Array([1, 1, 1]);
                matrix = matrix || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                var XW = whitePoint[0];
                var YW = whitePoint[1];
                var ZW = whitePoint[2];
                this.whitePoint = whitePoint;
                var XB = blackPoint[0];
                var YB = blackPoint[1];
                var ZB = blackPoint[2];
                this.blackPoint = blackPoint;
                this.GR = gamma[0];
                this.GG = gamma[1];
                this.GB = gamma[2];
                this.MXA = matrix[0];
                this.MYA = matrix[1];
                this.MZA = matrix[2];
                this.MXB = matrix[3];
                this.MYB = matrix[4];
                this.MZB = matrix[5];
                this.MXC = matrix[6];
                this.MYC = matrix[7];
                this.MZC = matrix[8];
                if (XW < 0 || ZW < 0 || YW !== 1) {
                  throw new _util.FormatError("Invalid WhitePoint components for " + this.name + ", no fallback available");
                }
                if (XB < 0 || YB < 0 || ZB < 0) {
                  (0, _util.info)("Invalid BlackPoint for " + this.name + " [" + XB + ", " + YB + ", " + ZB + "], falling back to default");
                  this.blackPoint = new Float32Array(3);
                }
                if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
                  (0, _util.info)("Invalid Gamma [" + this.GR + ", " + this.GG + ", " + this.GB + "] for " + this.name + ", falling back to default");
                  this.GR = this.GG = this.GB = 1;
                }
                if (this.MXA < 0 || this.MYA < 0 || this.MZA < 0 || this.MXB < 0 || this.MYB < 0 || this.MZB < 0 || this.MXC < 0 || this.MYC < 0 || this.MZC < 0) {
                  (0, _util.info)("Invalid Matrix for " + this.name + " [" + this.MXA + ", " + this.MYA + ", " + this.MZA + this.MXB + ", " + this.MYB + ", " + this.MZB + this.MXC + ", " + this.MYC + ", " + this.MZC + "], falling back to default");
                  this.MXA = this.MYB = this.MZC = 1;
                  this.MXB = this.MYA = this.MZA = this.MXC = this.MYC = this.MZB = 0;
                }
              }
              function matrixProduct(a, b, result) {
                result[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
                result[1] = a[3] * b[0] + a[4] * b[1] + a[5] * b[2];
                result[2] = a[6] * b[0] + a[7] * b[1] + a[8] * b[2];
              }
              function convertToFlat(sourceWhitePoint, LMS, result) {
                result[0] = LMS[0] * 1 / sourceWhitePoint[0];
                result[1] = LMS[1] * 1 / sourceWhitePoint[1];
                result[2] = LMS[2] * 1 / sourceWhitePoint[2];
              }
              function convertToD65(sourceWhitePoint, LMS, result) {
                var D65X = 0.95047;
                var D65Y = 1;
                var D65Z = 1.08883;
                result[0] = LMS[0] * D65X / sourceWhitePoint[0];
                result[1] = LMS[1] * D65Y / sourceWhitePoint[1];
                result[2] = LMS[2] * D65Z / sourceWhitePoint[2];
              }
              function sRGBTransferFunction(color) {
                if (color <= 31308e-7) {
                  return adjustToRange(0, 1, 12.92 * color);
                }
                return adjustToRange(0, 1, (1 + 0.055) * Math.pow(color, 1 / 2.4) - 0.055);
              }
              function adjustToRange(min, max, value) {
                return Math.max(min, Math.min(max, value));
              }
              function decodeL(L) {
                if (L < 0) {
                  return -decodeL(-L);
                }
                if (L > 8) {
                  return Math.pow((L + 16) / 116, 3);
                }
                return L * DECODE_L_CONSTANT;
              }
              function compensateBlackPoint(sourceBlackPoint, XYZ_Flat, result) {
                if (sourceBlackPoint[0] === 0 && sourceBlackPoint[1] === 0 && sourceBlackPoint[2] === 0) {
                  result[0] = XYZ_Flat[0];
                  result[1] = XYZ_Flat[1];
                  result[2] = XYZ_Flat[2];
                  return;
                }
                var zeroDecodeL = decodeL(0);
                var X_DST = zeroDecodeL;
                var X_SRC = decodeL(sourceBlackPoint[0]);
                var Y_DST = zeroDecodeL;
                var Y_SRC = decodeL(sourceBlackPoint[1]);
                var Z_DST = zeroDecodeL;
                var Z_SRC = decodeL(sourceBlackPoint[2]);
                var X_Scale = (1 - X_DST) / (1 - X_SRC);
                var X_Offset = 1 - X_Scale;
                var Y_Scale = (1 - Y_DST) / (1 - Y_SRC);
                var Y_Offset = 1 - Y_Scale;
                var Z_Scale = (1 - Z_DST) / (1 - Z_SRC);
                var Z_Offset = 1 - Z_Scale;
                result[0] = XYZ_Flat[0] * X_Scale + X_Offset;
                result[1] = XYZ_Flat[1] * Y_Scale + Y_Offset;
                result[2] = XYZ_Flat[2] * Z_Scale + Z_Offset;
              }
              function normalizeWhitePointToFlat(sourceWhitePoint, XYZ_In, result) {
                if (sourceWhitePoint[0] === 1 && sourceWhitePoint[2] === 1) {
                  result[0] = XYZ_In[0];
                  result[1] = XYZ_In[1];
                  result[2] = XYZ_In[2];
                  return;
                }
                var LMS = result;
                matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
                var LMS_Flat = tempNormalizeMatrix;
                convertToFlat(sourceWhitePoint, LMS, LMS_Flat);
                matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_Flat, result);
              }
              function normalizeWhitePointToD65(sourceWhitePoint, XYZ_In, result) {
                var LMS = result;
                matrixProduct(BRADFORD_SCALE_MATRIX, XYZ_In, LMS);
                var LMS_D65 = tempNormalizeMatrix;
                convertToD65(sourceWhitePoint, LMS, LMS_D65);
                matrixProduct(BRADFORD_SCALE_INVERSE_MATRIX, LMS_D65, result);
              }
              function convertToRgb(cs, src, srcOffset, dest, destOffset, scale) {
                var A = adjustToRange(0, 1, src[srcOffset] * scale);
                var B = adjustToRange(0, 1, src[srcOffset + 1] * scale);
                var C = adjustToRange(0, 1, src[srcOffset + 2] * scale);
                var AGR = Math.pow(A, cs.GR);
                var BGG = Math.pow(B, cs.GG);
                var CGB = Math.pow(C, cs.GB);
                var X = cs.MXA * AGR + cs.MXB * BGG + cs.MXC * CGB;
                var Y = cs.MYA * AGR + cs.MYB * BGG + cs.MYC * CGB;
                var Z = cs.MZA * AGR + cs.MZB * BGG + cs.MZC * CGB;
                var XYZ = tempConvertMatrix1;
                XYZ[0] = X;
                XYZ[1] = Y;
                XYZ[2] = Z;
                var XYZ_Flat = tempConvertMatrix2;
                normalizeWhitePointToFlat(cs.whitePoint, XYZ, XYZ_Flat);
                var XYZ_Black = tempConvertMatrix1;
                compensateBlackPoint(cs.blackPoint, XYZ_Flat, XYZ_Black);
                var XYZ_D65 = tempConvertMatrix2;
                normalizeWhitePointToD65(FLAT_WHITEPOINT_MATRIX, XYZ_Black, XYZ_D65);
                var SRGB = tempConvertMatrix1;
                matrixProduct(SRGB_D65_XYZ_TO_RGB_MATRIX, XYZ_D65, SRGB);
                var sR = sRGBTransferFunction(SRGB[0]);
                var sG = sRGBTransferFunction(SRGB[1]);
                var sB = sRGBTransferFunction(SRGB[2]);
                dest[destOffset] = Math.round(sR * 255);
                dest[destOffset + 1] = Math.round(sG * 255);
                dest[destOffset + 2] = Math.round(sB * 255);
              }
              CalRGBCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function CalRGBCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  convertToRgb(this, src, srcOffset, dest, destOffset, 1);
                },
                getRgbBuffer: function CalRGBCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var scale = 1 / ((1 << bits) - 1);
                  for (var i = 0; i < count; ++i) {
                    convertToRgb(this, src, srcOffset, dest, destOffset, scale);
                    srcOffset += 3;
                    destOffset += 3 + alpha01;
                  }
                },
                getOutputLength: function CalRGBCS_getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01) / 3 | 0;
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function CalRGBCS_isDefaultDecode(decodeMap) {
                  return ColorSpace.isDefaultDecode(decodeMap, this.numComps);
                },
                usesZeroToOneRange: true
              };
              return CalRGBCS2;
            }();
            var LabCS = function LabCSClosure() {
              function LabCS2(whitePoint, blackPoint, range) {
                this.name = "Lab";
                this.numComps = 3;
                this.defaultColor = new Float32Array(this.numComps);
                if (!whitePoint) {
                  throw new _util.FormatError("WhitePoint missing - required for color space Lab");
                }
                blackPoint = blackPoint || [0, 0, 0];
                range = range || [-100, 100, -100, 100];
                this.XW = whitePoint[0];
                this.YW = whitePoint[1];
                this.ZW = whitePoint[2];
                this.amin = range[0];
                this.amax = range[1];
                this.bmin = range[2];
                this.bmax = range[3];
                this.XB = blackPoint[0];
                this.YB = blackPoint[1];
                this.ZB = blackPoint[2];
                if (this.XW < 0 || this.ZW < 0 || this.YW !== 1) {
                  throw new _util.FormatError("Invalid WhitePoint components, no fallback available");
                }
                if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
                  (0, _util.info)("Invalid BlackPoint, falling back to default");
                  this.XB = this.YB = this.ZB = 0;
                }
                if (this.amin > this.amax || this.bmin > this.bmax) {
                  (0, _util.info)("Invalid Range, falling back to defaults");
                  this.amin = -100;
                  this.amax = 100;
                  this.bmin = -100;
                  this.bmax = 100;
                }
              }
              function fn_g(x) {
                var result;
                if (x >= 6 / 29) {
                  result = x * x * x;
                } else {
                  result = 108 / 841 * (x - 4 / 29);
                }
                return result;
              }
              function decode(value, high1, low2, high2) {
                return low2 + value * (high2 - low2) / high1;
              }
              function convertToRgb(cs, src, srcOffset, maxVal, dest, destOffset) {
                var Ls = src[srcOffset];
                var as = src[srcOffset + 1];
                var bs = src[srcOffset + 2];
                if (maxVal !== false) {
                  Ls = decode(Ls, maxVal, 0, 100);
                  as = decode(as, maxVal, cs.amin, cs.amax);
                  bs = decode(bs, maxVal, cs.bmin, cs.bmax);
                }
                as = as > cs.amax ? cs.amax : as < cs.amin ? cs.amin : as;
                bs = bs > cs.bmax ? cs.bmax : bs < cs.bmin ? cs.bmin : bs;
                var M = (Ls + 16) / 116;
                var L = M + as / 500;
                var N = M - bs / 200;
                var X = cs.XW * fn_g(L);
                var Y = cs.YW * fn_g(M);
                var Z = cs.ZW * fn_g(N);
                var r, g, b;
                if (cs.ZW < 1) {
                  r = X * 3.1339 + Y * -1.617 + Z * -0.4906;
                  g = X * -0.9785 + Y * 1.916 + Z * 0.0333;
                  b = X * 0.072 + Y * -0.229 + Z * 1.4057;
                } else {
                  r = X * 3.2406 + Y * -1.5372 + Z * -0.4986;
                  g = X * -0.9689 + Y * 1.8758 + Z * 0.0415;
                  b = X * 0.0557 + Y * -0.204 + Z * 1.057;
                }
                dest[destOffset] = r <= 0 ? 0 : r >= 1 ? 255 : Math.sqrt(r) * 255 | 0;
                dest[destOffset + 1] = g <= 0 ? 0 : g >= 1 ? 255 : Math.sqrt(g) * 255 | 0;
                dest[destOffset + 2] = b <= 0 ? 0 : b >= 1 ? 255 : Math.sqrt(b) * 255 | 0;
              }
              LabCS2.prototype = {
                getRgb: ColorSpace.prototype.getRgb,
                getRgbItem: function LabCS_getRgbItem(src, srcOffset, dest, destOffset) {
                  convertToRgb(this, src, srcOffset, false, dest, destOffset);
                },
                getRgbBuffer: function LabCS_getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) {
                  var maxVal = (1 << bits) - 1;
                  for (var i = 0; i < count; i++) {
                    convertToRgb(this, src, srcOffset, maxVal, dest, destOffset);
                    srcOffset += 3;
                    destOffset += 3 + alpha01;
                  }
                },
                getOutputLength: function LabCS_getOutputLength(inputLength, alpha01) {
                  return inputLength * (3 + alpha01) / 3 | 0;
                },
                isPassthrough: ColorSpace.prototype.isPassthrough,
                fillRgb: ColorSpace.prototype.fillRgb,
                isDefaultDecode: function LabCS_isDefaultDecode(decodeMap) {
                  return true;
                },
                usesZeroToOneRange: false
              };
              return LabCS2;
            }();
            exports2.ColorSpace = ColorSpace;
          },
          /* 28 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var ExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
            var MacExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall"];
            var MacRomanEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
            var StandardEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls"];
            var WinAnsiEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
            var SymbolSetEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt"];
            var ZapfDingbatsEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191"];
            function getEncoding(encodingName) {
              switch (encodingName) {
                case "WinAnsiEncoding":
                  return WinAnsiEncoding;
                case "StandardEncoding":
                  return StandardEncoding;
                case "MacRomanEncoding":
                  return MacRomanEncoding;
                case "SymbolSetEncoding":
                  return SymbolSetEncoding;
                case "ZapfDingbatsEncoding":
                  return ZapfDingbatsEncoding;
                case "ExpertEncoding":
                  return ExpertEncoding;
                case "MacExpertEncoding":
                  return MacExpertEncoding;
                default:
                  return null;
              }
            }
            exports2.WinAnsiEncoding = WinAnsiEncoding;
            exports2.StandardEncoding = StandardEncoding;
            exports2.MacRomanEncoding = MacRomanEncoding;
            exports2.SymbolSetEncoding = SymbolSetEncoding;
            exports2.ZapfDingbatsEncoding = ZapfDingbatsEncoding;
            exports2.ExpertEncoding = ExpertEncoding;
            exports2.getEncoding = getEncoding;
          },
          /* 29 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = function(bitmap, value) {
              return {
                enumerable: !(bitmap & 1),
                configurable: !(bitmap & 2),
                writable: !(bitmap & 4),
                value
              };
            };
          },
          /* 30 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var IObject = __w_pdfjs_require__(37);
            var defined = __w_pdfjs_require__(38);
            module2.exports = function(it) {
              return IObject(defined(it));
            };
          },
          /* 31 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var toInteger = __w_pdfjs_require__(18);
            var max = Math.max;
            var min = Math.min;
            module2.exports = function(index, length) {
              index = toInteger(index);
              return index < 0 ? max(index + length, 0) : min(index, length);
            };
          },
          /* 32 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var cof = __w_pdfjs_require__(25);
            var TAG = __w_pdfjs_require__(4)("toStringTag");
            var ARG = cof(/* @__PURE__ */ function() {
              return arguments;
            }()) == "Arguments";
            var tryGet = function tryGet2(it, key) {
              try {
                return it[key];
              } catch (e) {
              }
            };
            module2.exports = function(it) {
              var O, T, B;
              return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = tryGet(O = Object(it), TAG)) == "string" ? T : ARG ? cof(O) : (B = cof(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
            };
          },
          /* 33 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var ctx = __w_pdfjs_require__(13);
            var call = __w_pdfjs_require__(107);
            var isArrayIter = __w_pdfjs_require__(56);
            var anObject = __w_pdfjs_require__(9);
            var toLength = __w_pdfjs_require__(14);
            var getIterFn = __w_pdfjs_require__(60);
            var BREAK = {};
            var RETURN = {};
            var _exports = module2.exports = function(iterable, entries, fn, that, ITERATOR) {
              var iterFn = ITERATOR ? function() {
                return iterable;
              } : getIterFn(iterable);
              var f = ctx(fn, that, entries ? 2 : 1);
              var index = 0;
              var length, step, iterator, result;
              if (typeof iterFn != "function") throw TypeError(iterable + " is not iterable!");
              if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
                result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
                if (result === BREAK || result === RETURN) return result;
              }
              else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
                result = call(iterator, f, step.value, entries);
                if (result === BREAK || result === RETURN) return result;
              }
            };
            _exports.BREAK = BREAK;
            _exports.RETURN = RETURN;
          },
          /* 34 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.Parser = exports2.Linearization = exports2.Lexer = void 0;
            var _stream = __w_pdfjs_require__(5);
            var _util = __w_pdfjs_require__(0);
            var _primitives = __w_pdfjs_require__(2);
            var _ccitt_stream = __w_pdfjs_require__(130);
            var _jbig2_stream = __w_pdfjs_require__(132);
            var MAX_LENGTH_TO_CACHE = 1e3;
            var Parser = function ParserClosure() {
              function Parser2(lexer, allowStreams, xref, recoveryMode) {
                this.lexer = lexer;
                this.allowStreams = allowStreams;
                this.xref = xref;
                this.recoveryMode = recoveryMode || false;
                this.imageCache = /* @__PURE__ */ Object.create(null);
                this.refill();
              }
              Parser2.prototype = {
                refill: function Parser_refill() {
                  this.buf1 = this.lexer.getObj();
                  this.buf2 = this.lexer.getObj();
                },
                shift: function Parser_shift() {
                  if ((0, _primitives.isCmd)(this.buf2, "ID")) {
                    this.buf1 = this.buf2;
                    this.buf2 = null;
                  } else {
                    this.buf1 = this.buf2;
                    this.buf2 = this.lexer.getObj();
                  }
                },
                tryShift: function Parser_tryShift() {
                  try {
                    this.shift();
                    return true;
                  } catch (e) {
                    if (e instanceof _util.MissingDataException) {
                      throw e;
                    }
                    return false;
                  }
                },
                getObj: function Parser_getObj(cipherTransform) {
                  var buf1 = this.buf1;
                  this.shift();
                  if (buf1 instanceof _primitives.Cmd) {
                    switch (buf1.cmd) {
                      case "BI":
                        return this.makeInlineImage(cipherTransform);
                      case "[":
                        var array = [];
                        while (!(0, _primitives.isCmd)(this.buf1, "]") && !(0, _primitives.isEOF)(this.buf1)) {
                          array.push(this.getObj(cipherTransform));
                        }
                        if ((0, _primitives.isEOF)(this.buf1)) {
                          if (!this.recoveryMode) {
                            throw new _util.FormatError("End of file inside array");
                          }
                          return array;
                        }
                        this.shift();
                        return array;
                      case "<<":
                        var dict = new _primitives.Dict(this.xref);
                        while (!(0, _primitives.isCmd)(this.buf1, ">>") && !(0, _primitives.isEOF)(this.buf1)) {
                          if (!(0, _primitives.isName)(this.buf1)) {
                            (0, _util.info)("Malformed dictionary: key must be a name object");
                            this.shift();
                            continue;
                          }
                          var key = this.buf1.name;
                          this.shift();
                          if ((0, _primitives.isEOF)(this.buf1)) {
                            break;
                          }
                          dict.set(key, this.getObj(cipherTransform));
                        }
                        if ((0, _primitives.isEOF)(this.buf1)) {
                          if (!this.recoveryMode) {
                            throw new _util.FormatError("End of file inside dictionary");
                          }
                          return dict;
                        }
                        if ((0, _primitives.isCmd)(this.buf2, "stream")) {
                          return this.allowStreams ? this.makeStream(dict, cipherTransform) : dict;
                        }
                        this.shift();
                        return dict;
                      default:
                        return buf1;
                    }
                  }
                  if (Number.isInteger(buf1)) {
                    var num = buf1;
                    if (Number.isInteger(this.buf1) && (0, _primitives.isCmd)(this.buf2, "R")) {
                      var ref = new _primitives.Ref(num, this.buf1);
                      this.shift();
                      this.shift();
                      return ref;
                    }
                    return num;
                  }
                  if ((0, _util.isString)(buf1)) {
                    var str = buf1;
                    if (cipherTransform) {
                      str = cipherTransform.decryptString(str);
                    }
                    return str;
                  }
                  return buf1;
                },
                findDefaultInlineStreamEnd: function findDefaultInlineStreamEnd(stream) {
                  var E = 69, I = 73, SPACE = 32, LF = 10, CR = 13;
                  var n = 10, NUL = 0;
                  var startPos = stream.pos, state = 0, ch = void 0, maybeEIPos = void 0;
                  while ((ch = stream.getByte()) !== -1) {
                    if (state === 0) {
                      state = ch === E ? 1 : 0;
                    } else if (state === 1) {
                      state = ch === I ? 2 : 0;
                    } else {
                      (0, _util.assert)(state === 2);
                      if (ch === SPACE || ch === LF || ch === CR) {
                        maybeEIPos = stream.pos;
                        var followingBytes = stream.peekBytes(n);
                        for (var i = 0, ii = followingBytes.length; i < ii; i++) {
                          ch = followingBytes[i];
                          if (ch === NUL && followingBytes[i + 1] !== NUL) {
                            continue;
                          }
                          if (ch !== LF && ch !== CR && (ch < SPACE || ch > 127)) {
                            state = 0;
                            break;
                          }
                        }
                        if (state === 2) {
                          break;
                        }
                      } else {
                        state = 0;
                      }
                    }
                  }
                  if (ch === -1) {
                    (0, _util.warn)("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker");
                    if (maybeEIPos) {
                      (0, _util.warn)('... trying to recover by using the last "EI" occurrence.');
                      stream.skip(-(stream.pos - maybeEIPos));
                    }
                  }
                  return stream.pos - 4 - startPos;
                },
                findDCTDecodeInlineStreamEnd: function Parser_findDCTDecodeInlineStreamEnd(stream) {
                  var startPos = stream.pos, foundEOI = false, b, markerLength, length;
                  while ((b = stream.getByte()) !== -1) {
                    if (b !== 255) {
                      continue;
                    }
                    switch (stream.getByte()) {
                      case 0:
                        break;
                      case 255:
                        stream.skip(-1);
                        break;
                      case 217:
                        foundEOI = true;
                        break;
                      case 192:
                      case 193:
                      case 194:
                      case 195:
                      case 197:
                      case 198:
                      case 199:
                      case 201:
                      case 202:
                      case 203:
                      case 205:
                      case 206:
                      case 207:
                      case 196:
                      case 204:
                      case 218:
                      case 219:
                      case 220:
                      case 221:
                      case 222:
                      case 223:
                      case 224:
                      case 225:
                      case 226:
                      case 227:
                      case 228:
                      case 229:
                      case 230:
                      case 231:
                      case 232:
                      case 233:
                      case 234:
                      case 235:
                      case 236:
                      case 237:
                      case 238:
                      case 239:
                      case 254:
                        markerLength = stream.getUint16();
                        if (markerLength > 2) {
                          stream.skip(markerLength - 2);
                        } else {
                          stream.skip(-2);
                        }
                        break;
                    }
                    if (foundEOI) {
                      break;
                    }
                  }
                  length = stream.pos - startPos;
                  if (b === -1) {
                    (0, _util.warn)("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead.");
                    stream.skip(-length);
                    return this.findDefaultInlineStreamEnd(stream);
                  }
                  this.inlineStreamSkipEI(stream);
                  return length;
                },
                findASCII85DecodeInlineStreamEnd: function Parser_findASCII85DecodeInlineStreamEnd(stream) {
                  var TILDE = 126, GT = 62;
                  var startPos = stream.pos, ch, length;
                  while ((ch = stream.getByte()) !== -1) {
                    if (ch === TILDE && stream.peekByte() === GT) {
                      stream.skip();
                      break;
                    }
                  }
                  length = stream.pos - startPos;
                  if (ch === -1) {
                    (0, _util.warn)("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead.");
                    stream.skip(-length);
                    return this.findDefaultInlineStreamEnd(stream);
                  }
                  this.inlineStreamSkipEI(stream);
                  return length;
                },
                findASCIIHexDecodeInlineStreamEnd: function Parser_findASCIIHexDecodeInlineStreamEnd(stream) {
                  var GT = 62;
                  var startPos = stream.pos, ch, length;
                  while ((ch = stream.getByte()) !== -1) {
                    if (ch === GT) {
                      break;
                    }
                  }
                  length = stream.pos - startPos;
                  if (ch === -1) {
                    (0, _util.warn)("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead.");
                    stream.skip(-length);
                    return this.findDefaultInlineStreamEnd(stream);
                  }
                  this.inlineStreamSkipEI(stream);
                  return length;
                },
                inlineStreamSkipEI: function Parser_inlineStreamSkipEI(stream) {
                  var E = 69, I = 73;
                  var state = 0, ch;
                  while ((ch = stream.getByte()) !== -1) {
                    if (state === 0) {
                      state = ch === E ? 1 : 0;
                    } else if (state === 1) {
                      state = ch === I ? 2 : 0;
                    } else if (state === 2) {
                      break;
                    }
                  }
                },
                makeInlineImage: function Parser_makeInlineImage(cipherTransform) {
                  var lexer = this.lexer;
                  var stream = lexer.stream;
                  var dict = new _primitives.Dict(this.xref);
                  while (!(0, _primitives.isCmd)(this.buf1, "ID") && !(0, _primitives.isEOF)(this.buf1)) {
                    if (!(0, _primitives.isName)(this.buf1)) {
                      throw new _util.FormatError("Dictionary key must be a name object");
                    }
                    var key = this.buf1.name;
                    this.shift();
                    if ((0, _primitives.isEOF)(this.buf1)) {
                      break;
                    }
                    dict.set(key, this.getObj(cipherTransform));
                  }
                  var filter = dict.get("Filter", "F"), filterName;
                  if ((0, _primitives.isName)(filter)) {
                    filterName = filter.name;
                  } else if (Array.isArray(filter)) {
                    var filterZero = this.xref.fetchIfRef(filter[0]);
                    if ((0, _primitives.isName)(filterZero)) {
                      filterName = filterZero.name;
                    }
                  }
                  var startPos = stream.pos, length, i, ii;
                  if (filterName === "DCTDecode" || filterName === "DCT") {
                    length = this.findDCTDecodeInlineStreamEnd(stream);
                  } else if (filterName === "ASCII85Decode" || filterName === "A85") {
                    length = this.findASCII85DecodeInlineStreamEnd(stream);
                  } else if (filterName === "ASCIIHexDecode" || filterName === "AHx") {
                    length = this.findASCIIHexDecodeInlineStreamEnd(stream);
                  } else {
                    length = this.findDefaultInlineStreamEnd(stream);
                  }
                  var imageStream = stream.makeSubStream(startPos, length, dict);
                  var adler32;
                  if (length < MAX_LENGTH_TO_CACHE) {
                    var imageBytes = imageStream.getBytes();
                    imageStream.reset();
                    var a = 1;
                    var b = 0;
                    for (i = 0, ii = imageBytes.length; i < ii; ++i) {
                      a += imageBytes[i] & 255;
                      b += a;
                    }
                    adler32 = b % 65521 << 16 | a % 65521;
                    var cacheEntry = this.imageCache[adler32];
                    if (cacheEntry !== void 0) {
                      this.buf2 = _primitives.Cmd.get("EI");
                      this.shift();
                      cacheEntry.reset();
                      return cacheEntry;
                    }
                  }
                  if (cipherTransform) {
                    imageStream = cipherTransform.createStream(imageStream, length);
                  }
                  imageStream = this.filter(imageStream, dict, length);
                  imageStream.dict = dict;
                  if (adler32 !== void 0) {
                    imageStream.cacheKey = "inline_" + length + "_" + adler32;
                    this.imageCache[adler32] = imageStream;
                  }
                  this.buf2 = _primitives.Cmd.get("EI");
                  this.shift();
                  return imageStream;
                },
                makeStream: function Parser_makeStream(dict, cipherTransform) {
                  var lexer = this.lexer;
                  var stream = lexer.stream;
                  lexer.skipToNextLine();
                  var pos = stream.pos - 1;
                  var length = dict.get("Length");
                  if (!Number.isInteger(length)) {
                    (0, _util.info)("Bad " + length + " attribute in stream");
                    length = 0;
                  }
                  stream.pos = pos + length;
                  lexer.nextChar();
                  if (this.tryShift() && (0, _primitives.isCmd)(this.buf2, "endstream")) {
                    this.shift();
                  } else {
                    stream.pos = pos;
                    var SCAN_BLOCK_SIZE = 2048;
                    var ENDSTREAM_SIGNATURE_LENGTH = 9;
                    var ENDSTREAM_SIGNATURE = [101, 110, 100, 115, 116, 114, 101, 97, 109];
                    var skipped = 0, found = false, i, j;
                    while (stream.pos < stream.end) {
                      var scanBytes = stream.peekBytes(SCAN_BLOCK_SIZE);
                      var scanLength = scanBytes.length - ENDSTREAM_SIGNATURE_LENGTH;
                      if (scanLength <= 0) {
                        break;
                      }
                      found = false;
                      i = 0;
                      while (i < scanLength) {
                        j = 0;
                        while (j < ENDSTREAM_SIGNATURE_LENGTH && scanBytes[i + j] === ENDSTREAM_SIGNATURE[j]) {
                          j++;
                        }
                        if (j >= ENDSTREAM_SIGNATURE_LENGTH) {
                          found = true;
                          break;
                        }
                        i++;
                      }
                      if (found) {
                        skipped += i;
                        stream.pos += i;
                        break;
                      }
                      skipped += scanLength;
                      stream.pos += scanLength;
                    }
                    if (!found) {
                      throw new _util.FormatError("Missing endstream");
                    }
                    length = skipped;
                    lexer.nextChar();
                    this.shift();
                    this.shift();
                  }
                  this.shift();
                  stream = stream.makeSubStream(pos, length, dict);
                  if (cipherTransform) {
                    stream = cipherTransform.createStream(stream, length);
                  }
                  stream = this.filter(stream, dict, length);
                  stream.dict = dict;
                  return stream;
                },
                filter: function Parser_filter(stream, dict, length) {
                  var filter = dict.get("Filter", "F");
                  var params = dict.get("DecodeParms", "DP");
                  if ((0, _primitives.isName)(filter)) {
                    if (Array.isArray(params)) {
                      (0, _util.warn)("/DecodeParms should not contain an Array, when /Filter contains a Name.");
                    }
                    return this.makeFilter(stream, filter.name, length, params);
                  }
                  var maybeLength = length;
                  if (Array.isArray(filter)) {
                    var filterArray = filter;
                    var paramsArray = params;
                    for (var i = 0, ii = filterArray.length; i < ii; ++i) {
                      filter = this.xref.fetchIfRef(filterArray[i]);
                      if (!(0, _primitives.isName)(filter)) {
                        throw new _util.FormatError("Bad filter name: " + filter);
                      }
                      params = null;
                      if (Array.isArray(paramsArray) && i in paramsArray) {
                        params = this.xref.fetchIfRef(paramsArray[i]);
                      }
                      stream = this.makeFilter(stream, filter.name, maybeLength, params);
                      maybeLength = null;
                    }
                  }
                  return stream;
                },
                makeFilter: function Parser_makeFilter(stream, name, maybeLength, params) {
                  if (maybeLength === 0) {
                    (0, _util.warn)('Empty "' + name + '" stream.');
                    return new _stream.NullStream(stream);
                  }
                  try {
                    var xrefStreamStats = this.xref.stats.streamTypes;
                    if (name === "FlateDecode" || name === "Fl") {
                      xrefStreamStats[_util.StreamType.FLATE] = true;
                      if (params) {
                        return new _stream.PredictorStream(new _stream.FlateStream(stream, maybeLength), maybeLength, params);
                      }
                      return new _stream.FlateStream(stream, maybeLength);
                    }
                    if (name === "LZWDecode" || name === "LZW") {
                      xrefStreamStats[_util.StreamType.LZW] = true;
                      var earlyChange = 1;
                      if (params) {
                        if (params.has("EarlyChange")) {
                          earlyChange = params.get("EarlyChange");
                        }
                        return new _stream.PredictorStream(new _stream.LZWStream(stream, maybeLength, earlyChange), maybeLength, params);
                      }
                      return new _stream.LZWStream(stream, maybeLength, earlyChange);
                    }
                    if (name === "DCTDecode" || name === "DCT") {
                      xrefStreamStats[_util.StreamType.DCT] = true;
                      return new _stream.JpegStream(stream, maybeLength, stream.dict, params);
                    }
                    if (name === "JPXDecode" || name === "JPX") {
                      xrefStreamStats[_util.StreamType.JPX] = true;
                      return new _stream.JpxStream(stream, maybeLength, stream.dict, params);
                    }
                    if (name === "ASCII85Decode" || name === "A85") {
                      xrefStreamStats[_util.StreamType.A85] = true;
                      return new _stream.Ascii85Stream(stream, maybeLength);
                    }
                    if (name === "ASCIIHexDecode" || name === "AHx") {
                      xrefStreamStats[_util.StreamType.AHX] = true;
                      return new _stream.AsciiHexStream(stream, maybeLength);
                    }
                    if (name === "CCITTFaxDecode" || name === "CCF") {
                      xrefStreamStats[_util.StreamType.CCF] = true;
                      return new _ccitt_stream.CCITTFaxStream(stream, maybeLength, params);
                    }
                    if (name === "RunLengthDecode" || name === "RL") {
                      xrefStreamStats[_util.StreamType.RL] = true;
                      return new _stream.RunLengthStream(stream, maybeLength);
                    }
                    if (name === "JBIG2Decode") {
                      xrefStreamStats[_util.StreamType.JBIG] = true;
                      return new _jbig2_stream.Jbig2Stream(stream, maybeLength, stream.dict, params);
                    }
                    (0, _util.warn)('filter "' + name + '" not supported yet');
                    return stream;
                  } catch (ex) {
                    if (ex instanceof _util.MissingDataException) {
                      throw ex;
                    }
                    (0, _util.warn)('Invalid stream: "' + ex + '"');
                    return new _stream.NullStream(stream);
                  }
                }
              };
              return Parser2;
            }();
            var Lexer = function LexerClosure() {
              function Lexer2(stream, knownCommands) {
                this.stream = stream;
                this.nextChar();
                this.strBuf = [];
                this.knownCommands = knownCommands;
              }
              var specialChars = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              function toHexDigit(ch) {
                if (ch >= 48 && ch <= 57) {
                  return ch & 15;
                }
                if (ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102) {
                  return (ch & 15) + 9;
                }
                return -1;
              }
              Lexer2.prototype = {
                nextChar: function Lexer_nextChar() {
                  return this.currentChar = this.stream.getByte();
                },
                peekChar: function Lexer_peekChar() {
                  return this.stream.peekByte();
                },
                getNumber: function Lexer_getNumber() {
                  var ch = this.currentChar;
                  var eNotation = false;
                  var divideBy = 0;
                  var sign = 1;
                  if (ch === 45) {
                    sign = -1;
                    ch = this.nextChar();
                    if (ch === 45) {
                      ch = this.nextChar();
                    }
                  } else if (ch === 43) {
                    ch = this.nextChar();
                  }
                  if (ch === 46) {
                    divideBy = 10;
                    ch = this.nextChar();
                  }
                  if (ch === 10 || ch === 13) {
                    do {
                      ch = this.nextChar();
                    } while (ch === 10 || ch === 13);
                  }
                  if (ch < 48 || ch > 57) {
                    throw new _util.FormatError("Invalid number: " + String.fromCharCode(ch) + " (charCode " + ch + ")");
                  }
                  var baseValue = ch - 48;
                  var powerValue = 0;
                  var powerValueSign = 1;
                  while ((ch = this.nextChar()) >= 0) {
                    if (48 <= ch && ch <= 57) {
                      var currentDigit = ch - 48;
                      if (eNotation) {
                        powerValue = powerValue * 10 + currentDigit;
                      } else {
                        if (divideBy !== 0) {
                          divideBy *= 10;
                        }
                        baseValue = baseValue * 10 + currentDigit;
                      }
                    } else if (ch === 46) {
                      if (divideBy === 0) {
                        divideBy = 1;
                      } else {
                        break;
                      }
                    } else if (ch === 45) {
                      (0, _util.warn)("Badly formatted number");
                    } else if (ch === 69 || ch === 101) {
                      ch = this.peekChar();
                      if (ch === 43 || ch === 45) {
                        powerValueSign = ch === 45 ? -1 : 1;
                        this.nextChar();
                      } else if (ch < 48 || ch > 57) {
                        break;
                      }
                      eNotation = true;
                    } else {
                      break;
                    }
                  }
                  if (divideBy !== 0) {
                    baseValue /= divideBy;
                  }
                  if (eNotation) {
                    baseValue *= Math.pow(10, powerValueSign * powerValue);
                  }
                  return sign * baseValue;
                },
                getString: function Lexer_getString() {
                  var numParen = 1;
                  var done = false;
                  var strBuf = this.strBuf;
                  strBuf.length = 0;
                  var ch = this.nextChar();
                  while (true) {
                    var charBuffered = false;
                    switch (ch | 0) {
                      case -1:
                        (0, _util.warn)("Unterminated string");
                        done = true;
                        break;
                      case 40:
                        ++numParen;
                        strBuf.push("(");
                        break;
                      case 41:
                        if (--numParen === 0) {
                          this.nextChar();
                          done = true;
                        } else {
                          strBuf.push(")");
                        }
                        break;
                      case 92:
                        ch = this.nextChar();
                        switch (ch) {
                          case -1:
                            (0, _util.warn)("Unterminated string");
                            done = true;
                            break;
                          case 110:
                            strBuf.push("\n");
                            break;
                          case 114:
                            strBuf.push("\r");
                            break;
                          case 116:
                            strBuf.push("	");
                            break;
                          case 98:
                            strBuf.push("\b");
                            break;
                          case 102:
                            strBuf.push("\f");
                            break;
                          case 92:
                          case 40:
                          case 41:
                            strBuf.push(String.fromCharCode(ch));
                            break;
                          case 48:
                          case 49:
                          case 50:
                          case 51:
                          case 52:
                          case 53:
                          case 54:
                          case 55:
                            var x = ch & 15;
                            ch = this.nextChar();
                            charBuffered = true;
                            if (ch >= 48 && ch <= 55) {
                              x = (x << 3) + (ch & 15);
                              ch = this.nextChar();
                              if (ch >= 48 && ch <= 55) {
                                charBuffered = false;
                                x = (x << 3) + (ch & 15);
                              }
                            }
                            strBuf.push(String.fromCharCode(x));
                            break;
                          case 13:
                            if (this.peekChar() === 10) {
                              this.nextChar();
                            }
                            break;
                          case 10:
                            break;
                          default:
                            strBuf.push(String.fromCharCode(ch));
                            break;
                        }
                        break;
                      default:
                        strBuf.push(String.fromCharCode(ch));
                        break;
                    }
                    if (done) {
                      break;
                    }
                    if (!charBuffered) {
                      ch = this.nextChar();
                    }
                  }
                  return strBuf.join("");
                },
                getName: function Lexer_getName() {
                  var ch, previousCh;
                  var strBuf = this.strBuf;
                  strBuf.length = 0;
                  while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
                    if (ch === 35) {
                      ch = this.nextChar();
                      if (specialChars[ch]) {
                        (0, _util.warn)("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.");
                        strBuf.push("#");
                        break;
                      }
                      var x = toHexDigit(ch);
                      if (x !== -1) {
                        previousCh = ch;
                        ch = this.nextChar();
                        var x2 = toHexDigit(ch);
                        if (x2 === -1) {
                          (0, _util.warn)("Lexer_getName: Illegal digit (" + String.fromCharCode(ch) + ") in hexadecimal number.");
                          strBuf.push("#", String.fromCharCode(previousCh));
                          if (specialChars[ch]) {
                            break;
                          }
                          strBuf.push(String.fromCharCode(ch));
                          continue;
                        }
                        strBuf.push(String.fromCharCode(x << 4 | x2));
                      } else {
                        strBuf.push("#", String.fromCharCode(ch));
                      }
                    } else {
                      strBuf.push(String.fromCharCode(ch));
                    }
                  }
                  if (strBuf.length > 127) {
                    (0, _util.warn)("name token is longer than allowed by the spec: " + strBuf.length);
                  }
                  return _primitives.Name.get(strBuf.join(""));
                },
                getHexString: function Lexer_getHexString() {
                  var strBuf = this.strBuf;
                  strBuf.length = 0;
                  var ch = this.currentChar;
                  var isFirstHex = true;
                  var firstDigit;
                  var secondDigit;
                  while (true) {
                    if (ch < 0) {
                      (0, _util.warn)("Unterminated hex string");
                      break;
                    } else if (ch === 62) {
                      this.nextChar();
                      break;
                    } else if (specialChars[ch] === 1) {
                      ch = this.nextChar();
                      continue;
                    } else {
                      if (isFirstHex) {
                        firstDigit = toHexDigit(ch);
                        if (firstDigit === -1) {
                          (0, _util.warn)('Ignoring invalid character "' + ch + '" in hex string');
                          ch = this.nextChar();
                          continue;
                        }
                      } else {
                        secondDigit = toHexDigit(ch);
                        if (secondDigit === -1) {
                          (0, _util.warn)('Ignoring invalid character "' + ch + '" in hex string');
                          ch = this.nextChar();
                          continue;
                        }
                        strBuf.push(String.fromCharCode(firstDigit << 4 | secondDigit));
                      }
                      isFirstHex = !isFirstHex;
                      ch = this.nextChar();
                    }
                  }
                  return strBuf.join("");
                },
                getObj: function Lexer_getObj() {
                  var comment = false;
                  var ch = this.currentChar;
                  while (true) {
                    if (ch < 0) {
                      return _primitives.EOF;
                    }
                    if (comment) {
                      if (ch === 10 || ch === 13) {
                        comment = false;
                      }
                    } else if (ch === 37) {
                      comment = true;
                    } else if (specialChars[ch] !== 1) {
                      break;
                    }
                    ch = this.nextChar();
                  }
                  switch (ch | 0) {
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                    case 43:
                    case 45:
                    case 46:
                      return this.getNumber();
                    case 40:
                      return this.getString();
                    case 47:
                      return this.getName();
                    case 91:
                      this.nextChar();
                      return _primitives.Cmd.get("[");
                    case 93:
                      this.nextChar();
                      return _primitives.Cmd.get("]");
                    case 60:
                      ch = this.nextChar();
                      if (ch === 60) {
                        this.nextChar();
                        return _primitives.Cmd.get("<<");
                      }
                      return this.getHexString();
                    case 62:
                      ch = this.nextChar();
                      if (ch === 62) {
                        this.nextChar();
                        return _primitives.Cmd.get(">>");
                      }
                      return _primitives.Cmd.get(">");
                    case 123:
                      this.nextChar();
                      return _primitives.Cmd.get("{");
                    case 125:
                      this.nextChar();
                      return _primitives.Cmd.get("}");
                    case 41:
                      this.nextChar();
                      throw new _util.FormatError("Illegal character: " + ch);
                  }
                  var str = String.fromCharCode(ch);
                  var knownCommands = this.knownCommands;
                  var knownCommandFound = knownCommands && knownCommands[str] !== void 0;
                  while ((ch = this.nextChar()) >= 0 && !specialChars[ch]) {
                    var possibleCommand = str + String.fromCharCode(ch);
                    if (knownCommandFound && knownCommands[possibleCommand] === void 0) {
                      break;
                    }
                    if (str.length === 128) {
                      throw new _util.FormatError("Command token too long: " + str.length);
                    }
                    str = possibleCommand;
                    knownCommandFound = knownCommands && knownCommands[str] !== void 0;
                  }
                  if (str === "true") {
                    return true;
                  }
                  if (str === "false") {
                    return false;
                  }
                  if (str === "null") {
                    return null;
                  }
                  return _primitives.Cmd.get(str);
                },
                skipToNextLine: function Lexer_skipToNextLine() {
                  var ch = this.currentChar;
                  while (ch >= 0) {
                    if (ch === 13) {
                      ch = this.nextChar();
                      if (ch === 10) {
                        this.nextChar();
                      }
                      break;
                    } else if (ch === 10) {
                      this.nextChar();
                      break;
                    }
                    ch = this.nextChar();
                  }
                }
              };
              return Lexer2;
            }();
            var Linearization = {
              create: function LinearizationCreate(stream) {
                function getInt(name, allowZeroValue) {
                  var obj4 = linDict.get(name);
                  if (Number.isInteger(obj4) && (allowZeroValue ? obj4 >= 0 : obj4 > 0)) {
                    return obj4;
                  }
                  throw new Error('The "' + name + '" parameter in the linearization dictionary is invalid.');
                }
                function getHints() {
                  var hints = linDict.get("H"), hintsLength, item;
                  if (Array.isArray(hints) && ((hintsLength = hints.length) === 2 || hintsLength === 4)) {
                    for (var index = 0; index < hintsLength; index++) {
                      if (!(Number.isInteger(item = hints[index]) && item > 0)) {
                        throw new Error("Hint (" + index + ") in the linearization dictionary is invalid.");
                      }
                    }
                    return hints;
                  }
                  throw new Error("Hint array in the linearization dictionary is invalid.");
                }
                var parser = new Parser(new Lexer(stream), false, null);
                var obj1 = parser.getObj();
                var obj2 = parser.getObj();
                var obj3 = parser.getObj();
                var linDict = parser.getObj();
                var obj, length;
                if (!(Number.isInteger(obj1) && Number.isInteger(obj2) && (0, _primitives.isCmd)(obj3, "obj") && (0, _primitives.isDict)(linDict) && (0, _util.isNum)(obj = linDict.get("Linearized")) && obj > 0)) {
                  return null;
                } else if ((length = getInt("L")) !== stream.length) {
                  throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
                }
                return {
                  length,
                  hints: getHints(),
                  objectNumberFirst: getInt("O"),
                  endFirst: getInt("E"),
                  numPages: getInt("N"),
                  mainXRefEntriesOffset: getInt("T"),
                  pageFirst: linDict.has("P") ? getInt("P", true) : 0
                };
              }
            };
            exports2.Lexer = Lexer;
            exports2.Linearization = Linearization;
            exports2.Parser = Parser;
          },
          /* 35 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(3);
            var document2 = __w_pdfjs_require__(1).document;
            var is = isObject(document2) && isObject(document2.createElement);
            module2.exports = function(it) {
              return is ? document2.createElement(it) : {};
            };
          },
          /* 36 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var isObject = __w_pdfjs_require__(3);
            module2.exports = function(it, S) {
              if (!isObject(it)) return it;
              var fn, val;
              if (S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
              if (typeof (fn = it.valueOf) == "function" && !isObject(val = fn.call(it))) return val;
              if (!S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it))) return val;
              throw TypeError("Can't convert object to primitive value");
            };
          },
          /* 37 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var cof = __w_pdfjs_require__(25);
            module2.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
              return cof(it) == "String" ? it.split("") : Object(it);
            };
          },
          /* 38 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = function(it) {
              if (it == void 0) throw TypeError("Can't call method on  " + it);
              return it;
            };
          },
          /* 39 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var shared = __w_pdfjs_require__(54)("keys");
            var uid = __w_pdfjs_require__(17);
            module2.exports = function(key) {
              return shared[key] || (shared[key] = uid(key));
            };
          },
          /* 40 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            module2.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
          },
          /* 41 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var $keys = __w_pdfjs_require__(52);
            var enumBugKeys = __w_pdfjs_require__(40);
            module2.exports = Object.keys || function keys(O) {
              return $keys(O, enumBugKeys);
            };
          },
          /* 42 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var ctx = __w_pdfjs_require__(13);
            var IObject = __w_pdfjs_require__(37);
            var toObject = __w_pdfjs_require__(19);
            var toLength = __w_pdfjs_require__(14);
            var asc = __w_pdfjs_require__(91);
            module2.exports = function(TYPE, $create) {
              var IS_MAP = TYPE == 1;
              var IS_FILTER = TYPE == 2;
              var IS_SOME = TYPE == 3;
              var IS_EVERY = TYPE == 4;
              var IS_FIND_INDEX = TYPE == 6;
              var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
              var create = $create || asc;
              return function($this, callbackfn, that) {
                var O = toObject($this);
                var self2 = IObject(O);
                var f = ctx(callbackfn, that, 3);
                var length = toLength(self2.length);
                var index = 0;
                var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
                var val, res;
                for (; length > index; index++) {
                  if (NO_HOLES || index in self2) {
                    val = self2[index];
                    res = f(val, index, O);
                    if (TYPE) {
                      if (IS_MAP) result[index] = res;
                      else if (res) switch (TYPE) {
                        case 3:
                          return true;
                        case 5:
                          return val;
                        case 6:
                          return index;
                        case 2:
                          result.push(val);
                      }
                      else if (IS_EVERY) return false;
                    }
                  }
                }
                return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
              };
            };
          },
          /* 43 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var anObject = __w_pdfjs_require__(9);
            var aFunction = __w_pdfjs_require__(22);
            var SPECIES = __w_pdfjs_require__(4)("species");
            module2.exports = function(O, D) {
              var C = anObject(O).constructor;
              var S;
              return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? D : aFunction(S);
            };
          },
          /* 44 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var ITERATOR = __w_pdfjs_require__(4)("iterator");
            var SAFE_CLOSING = false;
            try {
              var riter = [7][ITERATOR]();
              riter["return"] = function() {
                SAFE_CLOSING = true;
              };
              Array.from(riter, function() {
                throw 2;
              });
            } catch (e) {
            }
            module2.exports = function(exec, skipClosing) {
              if (!skipClosing && !SAFE_CLOSING) return false;
              var safe = false;
              try {
                var arr = [7];
                var iter = arr[ITERATOR]();
                iter.next = function() {
                  return { done: safe = true };
                };
                arr[ITERATOR] = function() {
                  return iter;
                };
                exec(arr);
              } catch (e) {
              }
              return safe;
            };
          },
          /* 45 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var aFunction = __w_pdfjs_require__(22);
            function PromiseCapability(C) {
              var resolve, reject;
              this.promise = new C(function($$resolve, $$reject) {
                if (resolve !== void 0 || reject !== void 0) throw TypeError("Bad Promise constructor");
                resolve = $$resolve;
                reject = $$reject;
              });
              this.resolve = aFunction(resolve);
              this.reject = aFunction(reject);
            }
            module2.exports.f = function(C) {
              return new PromiseCapability(C);
            };
          },
          /* 46 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var META = __w_pdfjs_require__(17)("meta");
            var isObject = __w_pdfjs_require__(3);
            var has = __w_pdfjs_require__(12);
            var setDesc = __w_pdfjs_require__(15).f;
            var id = 0;
            var isExtensible = Object.isExtensible || function() {
              return true;
            };
            var FREEZE = !__w_pdfjs_require__(11)(function() {
              return isExtensible(Object.preventExtensions({}));
            });
            var setMeta = function setMeta2(it) {
              setDesc(it, META, {
                value: {
                  i: "O" + ++id,
                  w: {}
                }
              });
            };
            var fastKey = function fastKey2(it, create) {
              if (!isObject(it)) return (typeof it === "undefined" ? "undefined" : _typeof(it)) == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
              if (!has(it, META)) {
                if (!isExtensible(it)) return "F";
                if (!create) return "E";
                setMeta(it);
              }
              return it[META].i;
            };
            var getWeak = function getWeak2(it, create) {
              if (!has(it, META)) {
                if (!isExtensible(it)) return true;
                if (!create) return false;
                setMeta(it);
              }
              return it[META].w;
            };
            var onFreeze = function onFreeze2(it) {
              if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
              return it;
            };
            var meta = module2.exports = {
              KEY: META,
              NEED: false,
              fastKey,
              getWeak,
              onFreeze
            };
          },
          /* 47 */
          /***/
          function(module2, exports2, __w_pdfjs_require__) {
            var getLookupTableFactory = __w_pdfjs_require__(0).getLookupTableFactory;
            var getGlyphsUnicode = getLookupTableFactory(function(t) {
              t["A"] = 65;
              t["AE"] = 198;
              t["AEacute"] = 508;
              t["AEmacron"] = 482;
              t["AEsmall"] = 63462;
              t["Aacute"] = 193;
              t["Aacutesmall"] = 63457;
              t["Abreve"] = 258;
              t["Abreveacute"] = 7854;
              t["Abrevecyrillic"] = 1232;
              t["Abrevedotbelow"] = 7862;
              t["Abrevegrave"] = 7856;
              t["Abrevehookabove"] = 7858;
              t["Abrevetilde"] = 7860;
              t["Acaron"] = 461;
              t["Acircle"] = 9398;
              t["Acircumflex"] = 194;
              t["Acircumflexacute"] = 7844;
              t["Acircumflexdotbelow"] = 7852;
              t["Acircumflexgrave"] = 7846;
              t["Acircumflexhookabove"] = 7848;
              t["Acircumflexsmall"] = 63458;
              t["Acircumflextilde"] = 7850;
              t["Acute"] = 63177;
              t["Acutesmall"] = 63412;
              t["Acyrillic"] = 1040;
              t["Adblgrave"] = 512;
              t["Adieresis"] = 196;
              t["Adieresiscyrillic"] = 1234;
              t["Adieresismacron"] = 478;
              t["Adieresissmall"] = 63460;
              t["Adotbelow"] = 7840;
              t["Adotmacron"] = 480;
              t["Agrave"] = 192;
              t["Agravesmall"] = 63456;
              t["Ahookabove"] = 7842;
              t["Aiecyrillic"] = 1236;
              t["Ainvertedbreve"] = 514;
              t["Alpha"] = 913;
              t["Alphatonos"] = 902;
              t["Amacron"] = 256;
              t["Amonospace"] = 65313;
              t["Aogonek"] = 260;
              t["Aring"] = 197;
              t["Aringacute"] = 506;
              t["Aringbelow"] = 7680;
              t["Aringsmall"] = 63461;
              t["Asmall"] = 63329;
              t["Atilde"] = 195;
              t["Atildesmall"] = 63459;
              t["Aybarmenian"] = 1329;
              t["B"] = 66;
              t["Bcircle"] = 9399;
              t["Bdotaccent"] = 7682;
              t["Bdotbelow"] = 7684;
              t["Becyrillic"] = 1041;
              t["Benarmenian"] = 1330;
              t["Beta"] = 914;
              t["Bhook"] = 385;
              t["Blinebelow"] = 7686;
              t["Bmonospace"] = 65314;
              t["Brevesmall"] = 63220;
              t["Bsmall"] = 63330;
              t["Btopbar"] = 386;
              t["C"] = 67;
              t["Caarmenian"] = 1342;
              t["Cacute"] = 262;
           